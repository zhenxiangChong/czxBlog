---
url: /czxBlog/ai/index.md
---
# AI 模型导航
## 国产大模型

\<LinkCard
title="深度求索 DeepSeek"
icon="https://chat.deepseek.com/favicon.svg"
href="https://www.deepseek.com/"

>

**模型名称**：DeepSeek-V3、DeepSeek-R1
**开发机构**：深度求索（DeepSeek）
**特点**：

* **开源模式**：与国外闭源模式不同，采用开源策略，引发国内外复现热潮，成本仅为600万美元，远低于国际巨头。
* **高性能**：在数学、代码、自然语言推理任务中与 OpenAI o1 相当，文科任务表现突出（总分68.3，文科78.2）。
* **算法创新**：通过优化训练策略提升推理能力，减少对昂贵标注数据的依赖。

\<LinkCard
title="通义千问 Qwen"
icon="https://img.alicdn.com/imgextra/i1/O1CN01asLYeX1WhbsyEZn5u\_!!6000000002820-55-tps-56-56.svg"
href="https://tongyi.aliyun.com"

>

**模型名称**：Qwen2-72B、Qwen-max-latest 等
**开发机构**：阿里巴巴
**特点**：

* **国际竞争力**：Qwen2-72B 在 OpenCompass 评测中超越 Meta 的 Llama3-70B ，成为全球下载量最大的中文开源模型。
* **多模态能力**：Qwen-VL 在多模态评测中表现优异，支持图像与文本交互。
* **高性价比**：通过优化架构降低成本，价格降至0.5元/百万 Tokens 以下

\<LinkCard
title="商汤 SenseChat"
icon="https://sensechat-ml.aoss.cn-sh-01.sensecoreapi-oss.cn/chat/prod/wb/favicon\_ml.png"
href="https://chat.sensetime.com/"

>

**模型名称**：SenseChat 5.5-latest
**开发机构**：商汤科技
**特点**：

* **文科优势**：文科得分81.8，超越多数国际模型，擅长自然语言生成与理解。
* **行业应用**：广泛应用于智慧城市、医疗等领域，支持复杂场景的语义分析。

\<LinkCard
title="文心一言 ERNIE"
icon="https://nlp-eb.cdn.bcebos.com/logo/favicon.ico"
href="https://yiyan.baidu.com"

>

**模型名称**：ERNIE-4.0-Turbo、文心一言
**开发机构**：百度
**特点**：

* **中文理解**：在中文语义处理上表现突出，集成于百度搜索、地图等产品中。
* **垂直领域优化**：针对医疗、教育等场景推出专用版本，支持本地化部署。

\<LinkCard
title="星火认知大模型"
icon="https://xinghuo.xfyun.cn/spark-icon.ico"
href="https://xinghuo.xfyun.cn/"

>

**开发机构**：科大讯飞
**特点**：

* **语音交互**：结合讯飞语音技术，在实时翻译、语音助手场景中表现优异。
* **教育领域**：应用于智能教学、个性化学习方案生成。

\<LinkCard
title="混元大模型"
icon="https://xj-psd-1258344703.cos.ap-guangzhou.myqcloud.com/image/hunyuan/brand2024/logo64@3x.png"
href="https://hunyuan.tencent.com/"

>

**开发机构**：腾讯
**特点**：

* **多场景覆盖**：嵌入微信、QQ等社交平台，支持内容生成、智能客服等功能。
* **合成数据应用**：通过生成合成数据降低标注成本，加速模型迭代。

\<LinkCard
title="盘古大模型"
icon="https://www.huaweicloud.com/favicon.ico"
href="https://www.huaweicloud.com/product/pangu.html"

>

**开发机构**：华为
**特点**：

* **工业级应用**：聚焦智能制造、能源等领域，支持复杂工业场景的预测与优化。
* **全栈技术**：结合华为昇腾芯片与AI框架，提供端到端解决方案。

\<LinkCard
title="智谱 GLM"
icon="https://www.zhipuai.cn/assets/images/logo\_icon.jpeg"
href="https://www.zhipuai.cn/"

>

**模型名称**：GLM-4-Plus、GLM-4-9B
**开发机构**：智谱AI
**特点**：

* **高效训练**：通过分布式训练技术降低算力需求，适合中小型企业部署。
* **学术合作**：与高校合作推动开源生态，支持科研场景的模型定制。

\<LinkCard
title="360智脑"
icon="https://p4.ssl.qhimg.com/t110b9a9301d4da7a687593034a.png"
href="https://ai.360.cn/"

>

**模型名称**：360zhinao2-o1
**开发机构**：360公司
**特点**：

* **安全导向**：专注于网络安全领域的威胁检测与防御，支持实时数据分析。
* **低成本API**：提供高性价比的API服务，适合中小企业集成。

\<LinkCard
title="豆包 Doubao"
icon="https://lf-flow-web-cdn.doubao.com/obj/flow-doubao/doubao/web/logo-icon.png"
href="https://www.doubao.com/chat/"

>

**模型名称**：Doubao-pro-32k-241215
**开发机构**：字节跳动
**特点**：

* **短视频与推荐**：优化视频内容理解与推荐算法，提升抖音等平台的个性化体验。
* **多语言支持**：支持东南亚、欧洲等多语言场景，助力国际化业务。

\<LinkCard
title="Kimi AI"
icon="https://statics.moonshot.cn/kimi-chat/favicon.ico"
href="https://kimi.moonshot.cn/"

>

**模型名称**：moonshot-v1-vision-preview、k1.5
**开发机构**：月之暗面科技有限公司
**特点**：

* **超长文本处理**：支持20万汉字输入，长文本处理能力达到国际顶尖水平的10倍，在学术论文解析、法律文件分析、API文档理解等场景中表现突出。
* **工具集成与成本优化**：支持 API Tool Calling 功能，上下文缓存技术降低 90% 的长文本处理成本。

## 海外大模型

\<LinkCard
title="OpenAI"
icon="https://cdn.oaistatic.com/assets/favicon-miwirzcw.ico"
href="https://chatgpt.com/"

>

**模型名称**：GPT-3.5 Turbo、GPT-4、GPT-4o 等
**开发机构**：OpenAI（美国）
**特点**：

* **多模态能力**：从 GPT-3.5 到 GPT-4，逐步支持文本、图像、语音等多模态输入与生成。
* **行业标杆**：GPT-4 在复杂推理、数学和编程任务中表现卓越，总分为80.4（SuperCLUE榜单），尤其在理科任务（87.3分）中领先全球。
* **广泛应用**：集成于 ChatGPT、Microsoft Copilot 等产品，覆盖内容生成、代码编写、教育辅助等领域。

\<LinkCard
title="Claude"
icon="https://claude.ai/images/claude\_app\_icon.png"
href="https://www.anthropic.com/claude"

>

**模型名称**：Claude 3.5 Haiku、Claude 3.5 Sonnet
**开发机构**：Anthropic（美国）
**特点**：

* **安全与可控性**：采用“宪法AI”理念，通过预设规则减少有害内容生成，提升用户控制力。
* **复杂推理优势**：Claude 3.5 Sonnet 在数学、代码等 Hard 任务中得分 54.6，与 OpenAI 模型接近。
* **长上下文支持**：支持超长文本输入，适用于法律文档分析、学术研究等场景。

\<LinkCard
title="Gemini"
icon="https://www.gstatic.com/lamda/images/gemini\_sparkle\_v002\_d4735304ff6292a690345.svg"
href="https://gemini.google.com/app"

>

**模型名称**：Gemini 2.0 Flash
**开发机构**：Google DeepMind（美国）
**特点**：

* **多模态融合**：支持文本、图像、音频、视频的全模态处理，在跨模态推理中表现突出。
* **多语言适配**：覆盖全球主要语言，优化国际化场景应用，如实时翻译和多语言内容生成。
* **模型分层**：提供Ultra（超大模型）、Pro（通用模型）、Nano（轻量化）三种版本，适配不同设备需求。

\<LinkCard
title="LLaMA（Meta AI）"
icon="https://static.xx.fbcdn.net/rsrc.php/ye/r/5SevCzTxl\_y.ico"
href="https://www.meta.ai/"

>

**模型名称**：LLaMA-3.3
**开发机构**：Meta（美国）
**特点**：

* **开源生态**：LLaMA-3.3-70B 等模型开源，吸引全球开发者参与改进，广泛应用于智能客服和文本生成。
* **技术创新**：采用旋转位置编码（RoPE）和 SwiGLU 激活函数，提升模型性能和训练稳定性。
* **垂直领域优化**：在金融、医疗等场景中表现优异，支持本地化部署。

\<LinkCard
title="Copilot"
icon="https://github.githubassets.com/favicons/favicon.svg"
href="https://github.com/copilot"

>

**模型名称**：GPT-4
**开发机构**：GitHub、微软、OpenAI（合作）
**特点**：

* **编程辅助**：基于 GPT-4 Turbo，提供代码自动补全、错误修复和项目适配建议，提升开发效率。
* **跨平台集成**：嵌入 Microsoft 365（Word、Excel等），支持文档生成、数据分析等办公场景。
* **用户个性化**：通过学习用户习惯，生成定制化代码和文档模板。

\<LinkCard
title="Mistral"
icon="https://chat.mistral.ai/favicon.ico"
href="https://chat.mistral.ai/chat"

>

**模型名称**：Codestral、Mistral、Pixtral
**开发机构**：Hugging Face（法国）
**特点**：

* **生成式任务优化**：专注于文本和图像生成，擅长创意内容生产（如广告文案、艺术设计）。
* **轻量化部署**：模型参数规模适中，适合中小企业和开发者快速集成。

\<LinkCard
title="Grok"
icon="https://grok.com/favicon.ico"
href="https://grok.com/"

>

**模型名称**：grok-2-1212、grok-2-vision-1212
**开发机构**：Grok公司（美国）
**特点**：

* **行业深度适配**：在金融风控和医疗诊断中表现突出，支持高频数据分析和模式识别。
* **实时交互**：优化低延迟响应，适用于实时决策场景（如股票交易、急诊诊断）。

\<LinkCard
title="Stable Diffusion"
icon="https://images.squarespace-cdn.com/content/v1/6213c340453c3f502425776e/cfbf5bc5-47d4-4f4a-b133-23bd12a7d7c2/favicon.ico?format=100w"
href="https://stability.ai/"

>

**模型名称**：Stable Diffusion 3.5
**开发机构**：Stability AI（英国）
**特点**：

* **图像生成标杆**：基于扩散模型，生成高质量图像和视频，广泛应用于艺术创作和影视制作。
* **开源社区驱动**：通过社区协作不断迭代模型，支持用户自定义训练和微调。

\<LinkCard
title="Synthesia"
icon="https://cdn.prod.website-files.com/65e89895c5a4b8d764c0d710/664f0f482fa5a4d527d892bc\_Favicon-Web-Security%201.png"
href="https://www.synthesia.io/"

>

**开发机构**：Synthesia（英国）
**特点**：

* **虚拟数字人**：生成逼真虚拟形象视频，支持多语言配音，应用于教育、广告和虚拟客服。
* **无代码操作**：用户可通过文本输入快速生成视频内容，降低制作门槛。

\<LinkCard
title="ElevenLabs语音引擎"
icon="https://elevenlabs.io/favicon.ico"
href="https://elevenlabs.io/"

>

**模型名称**：Multilingual v2、Flash v2.5
**开发机构**：ElevenLabs（美国）
**特点**：

* **语音克隆与合成**：通过15秒音频样本克隆用户音色，支持多语言情感化语音生成。
* **跨场景应用**：集成于有声书制作、虚拟助手和游戏配音等领域。

---

---
url: /czxBlog/algorithm/index.md
---
# 数据结构与算法

---

---
url: /czxBlog/algorithm/backtracking/index.md
---
# 回溯算法
## 概述

\==回溯算法== 是一种通过尝试所有可能的候选解来解决问题的通用算法。

当发现当前候选解不可能满足条件时，会回退（回溯）到上一步，尝试其他选择。
它本质上是 **深度优先搜索（DFS）** 的一种优化形式，通过剪枝减少不必要的搜索。

## 核心思想

* **试错**：逐步构建候选解
* **剪枝**：发现无效解时立即回溯
* **状态管理**：记录当前路径，回溯时撤销选择

```ts
function backtrack(路径: 解的部分, 选择列表: 可用选项): void {
  if (满足结束条件) {
    结果集.push(路径副本) // 保存有效解
    return
  }

  for (选择 of 选择列表) {
    if (无效选择)
      continue // 剪枝

    做选择
    backtrack(新路径, 新选择列表)
    撤销选择 // 关键：状态重置
  }
}
```

## 实现

### 子集问题（无重复元素）

```ts
function subsets(nums: number[]): number[][] {
  const res: number[][] = []

  const backtrack = (start: number, path: number[]) => {
    res.push([...path]) // 保存当前子集

    for (let i = start; i < nums.length; i++) {
      path.push(nums[i]) // 做选择
      backtrack(i + 1, path) // 递归
      path.pop() // 撤销选择
    }
  }

  backtrack(0, [])
  return res
}

// 示例：subsets([1,2,3])
// 输出：[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
```

### 全排列（无重复元素）

```ts
function permute(nums: number[]): number[][] {
  const res: number[][] = []
  const used: boolean[] = Array.from({ length: nums.length }).fill(false)

  const backtrack = (path: number[]) => {
    if (path.length === nums.length) {
      res.push([...path])
      return
    }

    for (let i = 0; i < nums.length; i++) {
      if (used[i])
        continue // 剪枝：已使用

      used[i] = true
      path.push(nums[i])
      backtrack(path)
      path.pop()
      used[i] = false // 关键：撤销状态
    }
  }

  backtrack([])
  return res
}

// 示例：permute([1,2,3])
// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

## 优化技巧

* **剪枝策略**：

  * 提前终止无效路径（如组合总和中的 `sum > target`）
  * 跳过重复解（排序后判断 `if (i > start && nums[i] === nums[i-1])` ）

* **状态存储**：

  * 使用索引（`start`）避免重复组合
  * 使用布尔数组（`used[]`）标记已选元素

* **迭代代替递归**：

  * 对于深度大的问题，可用栈模拟递归

* **记忆化搜索**：

  * 缓存中间结果（适用于重叠子问题）

## 相关问题

[**LeetCode** - 回溯算法](https://leetcode.cn/problem-list/backtracking/){.read-more}

### 组合与求和问题

* **39. 组合总和**（[LeetCode](https://leetcode.cn/problems/combination-sum/)）
* **40. 组合总和 II**（[LeetCode](https://leetcode.cn/problems/combination-sum-ii/)）
* **216. 组合总和 III**（[LeetCode](https://leetcode.cn/problems/combination-sum-iii/)）

### 子集与排列问题

* **78. 子集**（[LeetCode](https://leetcode.cn/problems/subsets/)）
* **90. 子集 II**（[LeetCode](https://leetcode.cn/problems/subsets-ii/)）
* **46. 全排列**（[LeetCode](https://leetcode.cn/problems/permutations/)）
* **47. 全排列 II**（[LeetCode](https://leetcode.cn/problems/permutations-ii/)）

### 字符串与构造问题

* **22. 括号生成**（[LeetCode](https://leetcode.cn/problems/generate-parentheses/)）
* **51. N 皇后**（[LeetCode](https://leetcode.cn/problems/n-queens/)）

---

---
url: /czxBlog/algorithm/binary-search/index.md
---
# 二分查找
## 概述

\==二分查找（Binary Search）==，也称 **折半搜索（half-interval search）**、**对数搜索（logarithmic search）** 。
是一种高效的搜索算法，适用于已排序的数据集（如数组）。
它通过不断将搜索范围减半来定位目标值，时间复杂度为 $O(log n)$ ，远优于线性查找的 $O(n)$ 。

## 核心思想

* **分而治之**：每次比较目标值与数组中间元素。
* **缩小范围**：根据比较结果，将搜索范围缩小一半。
* **终止条件**：找到目标值或范围为空（未找到）。

## 过程

以在一个升序数组中查找一个数为例。

1. 它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；
2. 如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；
3. 如果中间元素大于所查找的值同理，只需到左侧查找。

## 实现

* **循环条件**：`left <= right`

  确保当 `left === right` 时（只剩一个元素）仍会检查。

* **中间索引计算**：

  * `mid = Math.floor((left + right) / 2)` 防止小数索引

    建议写作 `mid = (left + right) >> 1` 。

  * 大数安全写法：`mid = left + Math.floor((right - left) / 2)`（避免溢出）

    建议写作 `mid = left + ((right - left) >> 1)`。

* **边界更新**：

  * 目标在右侧：`left = mid + 1`（跳过已检查的 mid）。
  * 目标在左侧：`right = mid - 1`（同上）。

* **终止条件**：

  * 找到：`arr[mid] === target`。
  * 未找到：`left > right`（范围无效）。

### 迭代实现

```ts
function binarySearch(arr: number[], target: number): number {
  let left = 0
  let right = arr.length - 1

  while (left <= right) {
    const mid = left + ((right - left) >> 1) // 中间索引
    if (arr[mid] === target) {
      return mid // 找到目标
    }
    else if (arr[mid] < target) {
      left = mid + 1 // 目标在右半部分
    }
    else {
      right = mid - 1 // 目标在左半部分
    }
  }
  return -1 // 未找到
}
```

### 递归实现

```ts
function binarySearchRecursive(
  arr: number[],
  target: number,
  left: number = 0,
  right: number = arr.length - 1
): number {
  if (left > right)
    return -1 // 终止条件

  const mid = left + ((right - left) >> 1)
  if (arr[mid] === target) {
    return mid
  }
  else if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, right) // 搜索右半
  }
  else {
    return binarySearchRecursive(arr, target, left, mid - 1) // 搜索左半
  }
}
```

## 最大值最小化

注意，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，
而另一侧都不满足这种条件，也可以看作是一种有序（如果把满足条件看做 1，不满足看做 0，
至少对于这个条件的这一维度是有序的）。换言之，二分搜索法可以用来查找满足某种条件的最大（最小）的值。

要求满足某种条件的最大值的最小可能情况（最大值最小化），首先的想法是从小到大枚举这个作为答案的「最大值」，
然后去判断是否合法。若答案单调，就可以使用二分搜索法来更快地找到答案。
因此，要想使用二分搜索法来解这种「最大值最小化」的题目，需要满足以下三个条件：

* 答案在一个固定区间内；
* 可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值是否是符合条件的；
* 可行解对于区间满足一定的单调性。换言之，如果 x 是符合条件的，那么有 x + 1 或者 x - 1 也符合条件。（这样下来就满足了上面提到的单调性）

当然，最小值最大化是同理的。

## 适用场景

* 有序数据（数组、列表等）。
* 需要高效搜索（如数据库索引、大型数据集）。
* 变体问题：找边界、插入位置）。

## 相关问题

[**LeetCode** - 二分查找](https://leetcode.cn/problem-list/binary-search/){.read-more}

### 基础分治应用

* **169. 多数元素**（[LeetCode](https://leetcode.cn/problems/majority-element/)）
* **50. Pow(x, n)**（[LeetCode](https://leetcode.cn/problems/powx-n/)）

### 最大子数组问题

* **53. 最大子序和**（[LeetCode](https://leetcode.cn/problems/maximum-subarray/)）

### 进阶问题

* **4. 寻找两个有序数组的中位数**（[LeetCode](https://leetcode.cn/problems/median-of-two-sorted-arrays/)）
* **23. 合并 K 个升序链表**（[LeetCode](https://leetcode.cn/problems/merge-k-sorted-lists/)）

### 经典变体（分治思想延伸）

* **215. 数组中的第K个最大元素**（[LeetCode](https://leetcode.cn/problems/kth-largest-element-in-an-array/)）
* **240. 搜索二维矩阵 II**（[LeetCode](https://leetcode.cn/problems/search-a-2d-matrix-ii/)）

---

---
url: /czxBlog/algorithm/breadth-first-search/index.md
---
# 广度优先搜索
## 概述

\==广度优先搜索（Breadth-First Search）（BFS）== 是一种用于遍历或搜索树/图数据结构的算法。

是图上最基础、最重要的搜索算法之一。

所谓广度优先。就是每次都尝试访问同一层的节点。 如果同一层都访问完了，再访问下一层。

这样做的结果是，BFS 算法找到的路径是从起点开始的 最短 合法路径。换言之，这条路径所包含的边数最小。

在 BFS 结束时，每个节点都是通过从起点到该点的最短路径访问的。

## 核心思想

核心思想是 **逐层遍历**：

* 从起点开始，先访问所有直接邻居
* 再访问邻居的邻居
* 使用队列（FIFO）管理待访问节点
* 避免重复访问（通过记录已访问节点）

## 实现

### 图结构定义

```ts
type Graph = Record<string, string[]> // 邻接表表示法

// 示例图结构
const graph: Graph = {
  A: ['B', 'C'],
  B: ['A', 'D', 'E'],
  C: ['A', 'F'],
  D: ['B'],
  E: ['B', 'F'],
  F: ['C', 'E']
}
// A → B → C
// B → D → E
// C → F ← E
```

### BFS基础实现

```ts
function bfs(graph: Graph, start: string): string[] {
  const visited = new Set<string>() // 记录已访问节点
  const queue: string[] = [start] // 初始化队列
  const result: string[] = [] // 存储遍历结果

  visited.add(start)

  while (queue.length > 0) {
    const current = queue.shift()! // 从队列头部取出节点
    result.push(current)

    // 遍历当前节点的所有邻居
    for (const neighbor of graph[current]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor)
        queue.push(neighbor) // 新节点加入队列尾部
      }
    }
  }

  return result
}

// 测试执行
console.log(bfs(graph, 'A'))
// 输出: ['A', 'B', 'C', 'D', 'E', 'F']
```

### 最短路径实现（无权图）

```ts
function shortestPath(
  graph: Graph,
  start: string,
  target: string
): string[] | null {
  const visited = new Set<string>([start])
  const queue: string[] = [start]
  const predecessor: Record<string, string> = {} // 记录前驱节点
  const distance: Record<string, number> = { [start]: 0 } // 记录距离

  while (queue.length > 0) {
    const current = queue.shift()!

    if (current === target) {
      // 回溯构建路径
      const path = [target]
      let node = target
      while (node !== start) {
        node = predecessor[node]
        path.unshift(node)
      }
      return path
    }

    for (const neighbor of graph[current]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor)
        predecessor[neighbor] = current
        distance[neighbor] = distance[current] + 1
        queue.push(neighbor)
      }
    }
  }

  return null // 未找到路径
}

// 测试最短路径
console.log(shortestPath(graph, 'A', 'F'))
// 输出: ['A', 'C', 'F']（最短路径）
```

### 执行过程示例（从A开始）

| 步骤  | 队列状态   | 当前节点 | 新访问节点 | 访问顺序            |
| :---: | :--------- | :------: | :--------: | :------------------ |
|   1   | \[A]       |    A     |    B, C    | \[A]                |
|   2   | \[B, C]    |    B     |    D, E    | \[A, B]             |
|   3   | \[C, D, E] |    C     |     F      | \[A, B, C]          |
|   4   | \[D, E, F] |    D     | (无新节点) | \[A, B, C, D]       |
|   5   | \[E, F]    |    E     | (F已访问)  | \[A, B, C, D, E]    |
|   6   | \[F]       |    F     |     -      | \[A, B, C, D, E, F] |

## 关键解析

* **队列（Queue）**：

  * 使用数组模拟队列（push()入队，shift()出队）
  * 确保先进先出（FIFO）的访问顺序

* **访问记录（Visited Set）**：

  * 防止重复访问和循环
  * 空间换时间（O(1)时间复杂度检查）

* **前驱记录（Predecessor Map）**：

  * 存储节点的来源节点
  * 用于回溯构建完整路径

## 性能优化

* **双向BFS**：从起点和终点同时搜索（适合已知终点的场景）
* **层级记录**：使用level变量替代距离字典减少内存
* **队列选择**：使用链表实现真正O(1)出队的队列
* **剪枝策略**：提前终止不符合条件的路径

## 适用场景

* **社交网络**：查找N度好友关系
* **路径规划**：迷宫最短路径（无权图）
* **网络爬虫**：分层抓取网页
* **连通性检测**：判断岛屿数量（网格BFS）
* **状态转换**：解决华容道/八数码问题

## 相关问题

[**LeetCode** - 广度优先搜索 - Breadth-First Search](https://leetcode.cn/problem-list/breadth-first-search/){.read-more}

### 基础图遍历

* **LCP 07. 传递信息** （[LeetCode](https://leetcode.cn/problems/chuan-di-xin-xi/)）
* **547. 朋友圈**（[LeetCode](https://leetcode.cn/problems/friend-circles/)）

### 网格类问题（矩阵BFS）

* **542. 01 矩阵**（[LeetCode](https://leetcode.cn/problems/01-matrix/)）
* **994. 腐烂的橘子**（[LeetCode](https://leetcode.cn/problems/rotting-oranges/)）
* **1162. 地图分析（最短路径）**（[LeetCode](https://leetcode.cn/problems/maximum-distance-in-arrays/)）

### 二叉树层序遍历

* **199. 二叉树的右视图**（[LeetCode](https://leetcode.cn/problems/binary-tree-right-side-view/)）
* **1609. 奇偶树**（[LeetCode](https://leetcode.cn/problems/even-odd-tree/)）

### 进阶挑战题

* **127. 单词接龙**（[LeetCode](https://leetcode.cn/problems/word-ladder/)）
* **417. 太平洋大西洋水流问题**（[LeetCode](https://leetcode.cn/problems/pacific-atlantic-water-flow/)）

---

---
url: /czxBlog/algorithm/bubble-sort/index.md
---
# 冒泡排序
## 概述

\==冒泡排序（Bubble sort）== 一种基础的比较排序算法。

### 核心思想

**重复遍历数组，依次比较相邻元素，将较大值向后交换**，如同气泡上浮的过程。

## 算法步骤

1. **外层循环**：控制遍历轮数（n-1 轮）
2. **内层循环**：比较相邻元素，将较大值后移
3. **优化点**：每轮结束后，末尾元素已有序，可减少比较范围
4. **提前终止**：当某轮无交换时，说明数组已有序，提前结束

## 时间复杂度

* 在序列完全有序时，冒泡排序只需遍历一遍数组，不用执行任何交换操作，时间复杂度为 $O(n)$。
* 在最坏情况下，冒泡排序要执行 $\frac{(n-1)n}{2}$ 次交换操作，时间复杂度为 $O(n^2)$。
* 冒泡排序的平均时间复杂度为 $O(n^2)$。

## 空间复杂度

$O(1)$（原地排序）

## 稳定性

**稳定**（相同元素顺序不变）

## 伪代码

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements.} \\
2 & \textbf{Output. } A\text{ will be sorted in nondecreasing order stably.} \\
3 & \textbf{Method. }  \\
4 & flag\gets True\\
5 & \textbf{while }flag\\
6 & \qquad flag\gets False\\
7 & \qquad\textbf{for }i\gets1\textbf{ to }n-1\\
8 & \qquad\qquad\textbf{if }A\[i]>A\[i + 1]\\
9 & \qquad\qquad\qquad flag\gets True\\
10 & \qquad\qquad\qquad \text{Swap } A\[i]\text{ and }A\[i + 1]
\end{array}
$$

## 实现

```ts
function bubbleSort(arr: number[]): number[] {
  const n = arr.length
  // 复制数组以避免修改原数组（可选）
  const sortedArr = [...arr]

  // 外层循环：控制遍历轮数（n-1轮）
  for (let i = 0; i < n - 1; i++) {
    let swapped = false // 优化标记

    // 内层循环：比较相邻元素（每轮减少i个已排序元素）
    for (let j = 0; j < n - 1 - i; j++) {
      // 如果前一个元素大于后一个元素
      if (sortedArr[j] > sortedArr[j + 1]) {
        // 交换元素（ES6解构赋值）
        [sortedArr[j], sortedArr[j + 1]] = [sortedArr[j + 1], sortedArr[j]]
        swapped = true // 标记发生交换
      }
    }

    // 如果本轮无交换，说明数组已有序，提前终止
    if (!swapped)
      break
  }

  return sortedArr
}

// 测试示例
const unsortedArray = [64, 34, 25, 12, 22, 11, 90]
const sortedArray = bubbleSort(unsortedArray)
console.log('排序前:', unsortedArray) // [64, 34, 25, 12, 22, 11, 90]
console.log('排序后:', sortedArray) // [11, 12, 22, 25, 34, 64, 90]
```

### 执行过程示例 （`[5, 3, 8, 4]`）

* 第一轮：

  * 比较 $5 > 3$ → 交换 → `[3, 5, 8, 4]`
  * 比较 $5 < 8$ → 不交换
  * 比较 $8 > 4$ → 交换 → `[3, 5, 4, 8]`

* 第二轮：

  * 比较 $3 < 5$ → 不交换
  * 比较 $5 > 4$ → 交换 → `[3, 4, 5, 8]`
  * 检查发现无交换 → 提前终止

## 优化

* **优化内层循环范围**

  ```ts
  for (let j = 0; j < n - 1 - i; j++) {
    // ...
  }
  ```

  每轮结束后，末尾 i 个元素已有序，无需再比较。

* **提前终止**

  ```ts
  if (!swapped)
    break
  ```

  当数组在中间轮次已有序时，避免无效遍历。

---

---
url: /czxBlog/algorithm/bucket-sort/index.md
---
# 桶排序
## 概述

\==桶排序（Bucket Sort）== 是一种分布式排序算法，适用于数据分布均匀的场景。

### 核心思想

将数据分散到多个有序的桶中，对每个桶单独排序，最后合并所有桶。

## 基本原理

* **分桶**：根据元素范围创建固定数量的桶，将元素分配到对应的桶中。
* **桶内排序**：对每个非空桶单独排序（通常用插入排序等简单算法）。
* **合并结果**：按桶顺序合并所有元素。

## 过程

桶排序按下列步骤进行：

1. 设置一个定量的数组当作空桶；
2. 遍历序列，并将元素一个个放到对应的桶中；
3. 对每个不是空的桶进行排序；
4. 从不是空的桶里把元素再放回原来的序列中。

## 时间复杂度

桶排序的平均时间复杂度为 $O(n + n^2/k + k)$（将值域平均分成 $n$ 块 + 排序 + 重新合并元素），当 $k\approx n$ 时为 $O(n)$。

桶排序的最坏时间复杂度为 $O(n^2)$。

## 空间复杂度

桶排序的空间复杂度为 $O(n + k)$。 （需额外存储桶）

## 稳定性

如果使用稳定的内层排序，并且将元素插入桶中时不改变元素间的相对顺序，那么桶排序就是一种稳定的排序算法。

由于每块元素不多，一般使用插入排序。此时桶排序是一种稳定的排序算法。

## 实现

```ts
function bucketSort(arr: number[], bucketSize: number = 5): number[] {
  if (arr.length === 0)
    return arr

  // 1. 计算数组最小/最大值
  let min = arr[0]
  let max = arr[0]
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < min)
      min = arr[i]
    else if (arr[i] > max)
      max = arr[i]
  }

  // 2. 初始化桶
  const bucketCount = Math.floor((max - min) / bucketSize) + 1
  const buckets: number[][] = Array.from({ length: bucketCount })
  for (let i = 0; i < bucketCount; i++) {
    buckets[i] = []
  }

  // 3. 元素分配到桶中
  for (let num of arr) {
    const bucketIndex = Math.floor((num - min) / bucketSize)
    buckets[bucketIndex].push(num)
  }

  // 4. 对每个桶排序并合并
  const sortedArr: number[] = []
  for (let bucket of buckets) {
    if (bucket.length > 0) {
      // 使用插入排序（可替换为其他排序）
      insertionSort(bucket)
      sortedArr.push(...bucket)
    }
  }
  return sortedArr
}

// 插入排序辅助函数
function insertionSort(arr: number[]): void {
  for (let i = 1; i < arr.length; i++) {
    const key = arr[i]
    let j = i - 1
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j]
      j--
    }
    arr[j + 1] = key
  }
}

// 测试用例
const arr = [0.42, 0.32, 0.75, 0.12, 0.98, 0.63]
console.log(bucketSort(arr))
// 输出: [0.12, 0.32, 0.42, 0.63, 0.75, 0.98]
```

## 优化

* **动态桶大小**：根据数据分布动态调整 `bucketSize` 。
* **桶内排序算法**：对大数据桶使用 ==快速排序（QuickSort）== 提升效率。
* **空桶处理**：跳过空桶减少不必要的遍历。

---

---
url: /czxBlog/algorithm/data-structure/array/index.md
---
# 数组
## 概述

\==数组（Array）== 是一种有序的线性数据结构，它的每个元素都是一个独立的数据项，可以通过下标快速访问。

## 核心特性

* **有序性**:数组中的元素按照一定的顺序排列，可以通过下标访问特定位置的元素。
* **线性性**:数组中的元素是连续存储的，可以通过下标访问特定位置的元素。
* **可变性**:数组可以动态增加或删除元素，可以根据需要调整数组的大小。

## 相关问题

[**LeetCode** - 数组](https://leetcode.cn/problem-list/array/){.read-more}

### 基础操作与双指针

* **1. 两数之和**（[LeetCode](https://leetcode.cn/problems/two-sum/)）
* **283. 移动零**（[LeetCode](https://leetcode.cn/problems/move-zeroes/)）
* **11. 盛最多水的容器**（[LeetCode](https://leetcode.cn/problems/container-with-most-water/)）
* **15. 三数之和**（[LeetCode](https://leetcode.cn/problems/3sum/)）

### 二分查找与滑动窗口

* **704. 二分查找**（[LeetCode](https://leetcode.cn/problems/binary-search/)）
* **35. 搜索插入位置**（[LeetCode](https://leetcode.cn/problems/search-insert-position/)）
* **209. 长度最小的子数组**（[LeetCode](https://leetcode.cn/problems/minimum-size-subarray-sum/)）
* **2653. 滑动子数组的美丽值**（[LeetCode](https://leetcode.cn/problems/sliding-subarray-beauty/)）

### 经典多维数组

* **59. 螺旋矩阵 II**（[LeetCode](https://leetcode.cn/problems/spiral-matrix-ii/)）
* **724. 寻找数组的中心索引**（[LeetCode](https://leetcode.cn/problems/find-pivot-index/)）
* **18. 四数之和**（[LeetCode](https://leetcode.cn/problems/4sum/)）
* **26. 删除有序数组中的重复项**（[LeetCode](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)）

---

---
url: /czxBlog/algorithm/data-structure/binary-tree/index.md
---
# 二叉树
## 概述

\==二叉树（Binary Tree）== 是一种非线性数据结构，每个节点最多有两个子节点（左子节点和右子节点）。

## 核心特性

* **度**：节点拥有的子树数（二叉树节点度 ≤ 2）
* **层次**：根节点为第 1 层，逐级递增
* **深度**：从根到节点的路径长度
* **高度**：从节点到最深叶子的路径长度

## 二叉树基础节点实现

```ts
class TreeNode<T> {
  val: T
  left: TreeNode<T> | null
  right: TreeNode<T> | null

  constructor(
    val: T,
    left: TreeNode<T> | null = null,
    right: TreeNode<T> | null = null
  ) {
    this.val = val
    this.left = left
    this.right = right
  }
}
```

## 特殊二叉树

* **完全二叉树**：除最后一层外全满，最后一层左对齐
* **满二叉树**：所有非叶子节点都有两个子节点
* **二叉搜索树 (BST)**：左子树所有值 < 根 < 右子树所有值

## 二叉搜索树的实现

```ts
// 满二叉树：所有非叶子节点都有两个子节点
class FullBinaryTree<T> { /* 实现 */ }

// 完全二叉树：除最后一层外全满，最后一层左对齐
class CompleteBinaryTree<T> { /* 实现 */ }

// 二叉搜索树 (BST)：左子树所有值 < 根 < 右子树所有值
class BinarySearchTree<T> {
  root: TreeNode<T> | null = null

  insert(val: T): void {
    const newNode = new TreeNode(val)
    if (!this.root) {
      this.root = newNode
      return
    }

    let current = this.root
    while (true) {
      if (val < current.val) {
        if (!current.left) {
          current.left = newNode
          break
        }
        current = current.left
      }
      else {
        if (!current.right) {
          current.right = newNode
          break
        }
        current = current.right
      }
    }
  }
}
```

## 二叉树的遍历

访问树的所有节点有三种遍历方式：中序，先序和后序。

* **中序遍历**：以从最小到最大的顺序访问所有节点
* **先序遍历**：以优先于后代节点的顺序访问每个节点
* **后序遍历**：先访问节点的后代节点再访问节点本身

属于何种遍历方式，通常可以根据 根节点 所在的位置：

* **先序遍历**：**根** --> 左子树 --> 右子树
* **中序遍历**：左子树 --> **根** --> \*\*右子树
* **后序遍历**：左子树 --> 右子树 -- > **根**

### 先序遍历（Preorder Traversal）

**访问顺序**：根节点 → 左子树 → 右子树

**应用场景**：创建树副本、序列化树结构、前缀表达式生成

```ts
// 递归实现
function preorder<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  return [
    root.val,
    ...preorder(root.left),
    ...preorder(root.right)
  ]
}

// 迭代实现（使用栈）
function preorderIterative<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  const stack: TreeNode<T>[] = [root]
  const result: T[] = []

  while (stack.length) {
    const node = stack.pop()!
    result.push(node.val)
    if (node.right)
      stack.push(node.right) // 右子先入栈
    if (node.left)
      stack.push(node.left) // 左子后入栈（后进先出）
  }
  return result
}
```

### 中序遍历 (Inorder Traversal)

**访问顺序**：左子树 → 根节点 → 右子树

**应用场景**：二叉搜索树排序输出、表达式树中缀表示

```ts
// 递归实现
function inorder<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  return [
    ...inorder(root.left),
    root.val,
    ...inorder(root.right)
  ]
}

// 迭代实现（使用指针+栈）
function inorderIterative<T>(root: TreeNode<T> | null): T[] {
  const stack: TreeNode<T>[] = []
  const result: T[] = []
  let curr = root

  while (curr || stack.length) {
    // 深入左子树
    while (curr) {
      stack.push(curr)
      curr = curr.left
    }
    // 回溯访问节点
    curr = stack.pop()!
    result.push(curr.val)
    // 转向右子树
    curr = curr.right
  }
  return result
}
```

### 后序遍历（Postorder Traversal）

**访问顺序**：左子树 → 右子树 → 根节点

**应用场景**：释放树内存、计算目录大小、后缀表达式求值

```ts
// 递归实现
function postorder<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  return [
    ...postorder(root.left),
    ...postorder(root.right),
    root.val
  ]
}

// 迭代实现（反转法）
function postorderIterative<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  const stack: TreeNode<T>[] = [root]
  const result: T[] = []

  while (stack.length) {
    const node = stack.pop()!
    result.push(node.val)
    if (node.left)
      stack.push(node.left)
    if (node.right)
      stack.push(node.right)
  }
  return result.reverse() // 反转先序变体结果
}

// 迭代实现（双栈法）
function postorderTwoStacks<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  const stack1: TreeNode<T>[] = [root]
  const stack2: TreeNode<T>[] = []
  const result: T[] = []

  while (stack1.length) {
    const node = stack1.pop()!
    stack2.push(node)
    if (node.left)
      stack1.push(node.left)
    if (node.right)
      stack1.push(node.right)
  }

  while (stack2.length) {
    result.push(stack2.pop()!.val)
  }
  return result
}
```

### 遍历过程

```mermaid
---
title: 示例树
---
graph TD
  A --> B
  A --> C
  B --> D
  B --> E
  C --> F
  C --> G
```

| 遍历方式 | 访问顺序       | 输出结果        |
| -------- | -------------- | --------------- |
| 先序遍历 | A→B→D→E→C→F->G | `[A,B,D,E,C,F]` |
| 中序遍历 | D→B→E→A→C→F->G | `[D,B,E,A,C,F]` |
| 后序遍历 | D→E→B→F→G->C→A | `[D,E,B,F,C,A]` |

## 二叉树的搜索

在二叉树中搜索值是树操作中最基础和重要的操作之一。

### 普通二叉树搜索

::: code-tabs

@tab 递归实现

```ts
function searchBinaryTree<T>(
  root: TreeNode<T> | null,
  target: T
): TreeNode<T> | null {
  if (!root)
    return null

  // 检查当前节点
  if (root.val === target)
    return root

  // 递归搜索左子树
  const leftResult = searchBinaryTree(root.left, target)
  if (leftResult)
    return leftResult

  // 递归搜索右子树
  return searchBinaryTree(root.right, target)
}
```

@tab 迭代实现（使用栈）

```ts
function searchBinaryTreeIterative<T>(
  root: TreeNode<T> | null,
  target: T
): TreeNode<T> | null {
  if (!root)
    return null

  const stack: TreeNode<T>[] = [root]

  while (stack.length) {
    const node = stack.pop()!

    // 检查当前节点
    if (node.val === target)
      return node

    // 将子节点压入栈
    if (node.right)
      stack.push(node.right)
    if (node.left)
      stack.push(node.left)
  }

  return null
}
```

:::

### 二叉搜索树（BST）搜索

二叉搜索树具有有序特性，可以高效搜索：

::: code-tabs

@tab 递归实现

```ts
function searchBST<T>(
  root: TreeNode<T> | null,
  target: T,
  comparator: (a: T, b: T) => number = (a, b) => a === b ? 0 : a > b ? 1 : -1
): TreeNode<T> | null {
  if (!root)
    return null

  const comp = comparator(target, root.val)

  if (comp === 0)
    return root // 找到目标
  if (comp < 0)
    return searchBST(root.left, target, comparator) // 目标小于当前值，搜索左子树
  return searchBST(root.right, target, comparator) // 目标大于当前值，搜索右子树
}
```

@tab 迭代实现

```ts
function searchBSTIterative<T>(
  root: TreeNode<T> | null,
  target: T,
  comparator: (a: T, b: T) => number = (a, b) => a === b ? 0 : a > b ? 1 : -1
): TreeNode<T> | null {
  let current = root

  while (current) {
    const comp = comparator(target, current.val)

    if (comp === 0)
      return current // 找到目标
    if (comp < 0)
      current = current.left // 目标小于当前值，转向左子树
    else current = current.right // 目标大于当前值，转向右子树
  }

  return null // 未找到
}
```

:::

### 搜索路径记录

有时我们需要记录搜索路径而不仅仅是找到节点：

```ts
function searchWithPath<T>(
  root: TreeNode<T> | null,
  target: T
): TreeNode<T>[] | null {
  if (!root)
    return null

  const path: TreeNode<T>[] = []
  let found = false

  function dfs(node: TreeNode<T> | null): boolean {
    if (!node || found)
      return false

    path.push(node)

    if (node.val === target) {
      found = true
      return true
    }

    if (dfs(node.left))
      return true
    if (dfs(node.right))
      return true

    path.pop()
    return false
  }

  dfs(root)
  return found ? path : null
}
```

## 时间复杂度

| 操作      | 平均       | 最差   |
| --------- | ---------- | ------ |
| 访问/搜索 | $O(log n)$ | $O(n)$ |
| 插入/删除 | $O(log n)$ | $O(n)$ |
| 空间      | $O(n)$     | $O(n)$ |

## 适用场景

* **数据库索引**：B/B+ 树（二叉树变种）
* **文件系统**：目录树结构
* **编译器**：语法分析树
* **游戏 AI**：决策树
* **数据压缩**：哈夫曼编码树

## 相关问题

[**LeetCode** - 二叉树](https://leetcode.cn/problem-list/tree/){.read-more}

### 基础操作

* **101. 对称二叉树**（[LeetCode](https://leetcode.cn/problems/symmetric-tree/)）
* **104. 二叉树的最大深度**（[LeetCode](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)）
* **226. 翻转二叉树**（[LeetCode](https://leetcode.cn/problems/invert-binary-tree/)）
* **102. 二叉树的层序遍历**（[LeetCode](https://leetcode.cn/problems/binary-tree-level-order-traversal/)）
* **199. 二叉树的右视图**（[LeetCode](https://leetcode.cn/problems/binary-tree-right-side-view/)）

### 路径、深度与综合应用

* **112. 路径总和**（[LeetCode](https://leetcode.cn/problems/path-sum/)）
* **543. 二叉树的直径**（[LeetCode](https://leetcode.cn/problems/diameter-of-binary-tree/)）
* **110. 平衡二叉树**（[LeetCode](https://leetcode.cn/problems/balanced-binary-tree/)）
* **114. 二叉树展开为链表**（[LeetCode](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)）

### 二叉搜索树（BST）专项

* **98. 验证二叉搜索树**（[LeetCode](https://leetcode.cn/problems/validate-binary-search-tree/)）
* **230. 二叉搜索树中第K小的元素**（[LeetCode](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)）
* **538. 把二叉搜索树转换为累加树**（[LeetCode](https://leetcode.cn/problems/convert-bst-to-greater-tree/)）
* **701. 二叉搜索树中的插入操作**（[LeetCode](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)）

---

---
url: /czxBlog/algorithm/data-structure/graph/index.md
---
# 图
[**维基百科** - 图论](https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA){.read-more}

::: warning 受限于篇幅和作者个人水平，本篇仅粗略的介绍 **图** 的一些基本概念，有兴趣的读者可以自行了解更多的知识。
:::

## 概述

\==图（Graph）== 是一种表示多对多关系的非线性数据结构，由 **顶点（Vertex）** 和 **边（Edge）** 组成。

## 图的核心概念

* **顶点（Vertex）**：图中的基本元素（节点）

* **边（Edge）**：连接两个顶点的关系（可带权重）

* **类型**：

  * **无向图**：边无方向（A-B 表示双向关系）

  * **有向图**：边有方向（A→B 表示单向关系）

* **术语**：

  * **度（Degree）**：顶点连接的边数

  * **路径（Path）**：顶点序列通过边连接

  * **环（Cycle）**：起点=终点的路径

  * **连通图**：任意两顶点间存在路径

## 图的表示方法

### 邻接矩阵（Adjacency Matrix）

```ts
class GraphMatrix {
  private matrix: number[][]
  private vertices: string[]

  constructor(vertices: string[]) {
    this.vertices = vertices
    this.matrix = Array.from({ length: vertices.length })
      .fill(0)
      .map(() => Array.from({ length: vertices.length }).fill(0))
  }

  // 添加边（无向图）
  addEdge(v1: string, v2: string, weight: number = 1) {
    const i = this.vertices.indexOf(v1)
    const j = this.vertices.indexOf(v2)
    this.matrix[i][j] = weight
    this.matrix[j][i] = weight // 有向图时删除此行
  }

  // 打印矩阵
  print() {
    console.log(`  ${this.vertices.join(' ')}`)
    this.matrix.forEach((row, i) => {
      console.log(`${this.vertices[i]} ${row.join(' ')}`)
    })
  }
}

// 使用示例
const graph = new GraphMatrix(['A', 'B', 'C'])
graph.addEdge('A', 'B', 3)
graph.addEdge('B', 'C', 2)
graph.print()
/* 输出：
   A B C
A 0 3 0
B 3 0 2
C 0 2 0
*/
```

### 邻接表（Adjacency List）

```ts
interface Edge { vertex: string, weight: number }
class GraphList {
  private adjacencyList: Map<string, Edge[]> = new Map()

  addVertex(vertex: string): void {
    if (!this.adjacencyList.has(vertex)) {
      this.adjacencyList.set(vertex, [])
    }
  }

  addEdge(v1: string, v2: string, weight: number = 1): void {
    this.adjacencyList.get(v1)?.push({ vertex: v2, weight })
    // 无向图需添加反向边（有向图时删除）
    this.adjacencyList.get(v2)?.push({ vertex: v1, weight })
  }

  getNeighbors(vertex: string): Edge[] {
    return this.adjacencyList.get(vertex) || []
  }

  print() {
    this.adjacencyList.forEach((edges, vertex) => {
      const edgeStr = edges.map(e => `${e.vertex}(${e.weight})`).join(', ')
      console.log(`${vertex} -> ${edgeStr}`)
    })
  }
}

// 使用示例
const graph = new GraphList()
graph.addVertex('A')
graph.addVertex('B')
graph.addVertex('C')
graph.addEdge('A', 'B', 3)
graph.addEdge('B', 'C', 2)
graph.print()
/* 输出：
A -> B(3)
B -> A(3), C(2)
C -> B(2)
*/
```

## 图的应用场景

* **社交网络**：好友关系（顶点=用户，边=关注）
* **路径规划**：地图导航（顶点=地点，边=道路权重）
* **依赖分析**：编译顺序（有向无环图拓扑排序）
* **推荐系统**：用户-商品二部图

## 相关问题

[**LeetCode** - 图](https://leetcode.cn/problem-list/graph/){.read-more}

### 基础遍历与连通性问题

* **200. 岛屿数量**（[LeetCode](https://leetcode.cn/problems/number-of-islands/)）
* **133. 克隆图**（[LeetCode](https://leetcode.cn/problems/clone-graph/)）

### 环检测与树结构判断

* **261. 以图判树**（[LeetCode](https://leetcode.cn/problems/graph-valid-tree/)）
* **207. 课程表**（[LeetCode](https://leetcode.cn/problems/course-schedule/)）

### 最短路径与多源遍历

* **743. 网络延迟时间**（[LeetCode](https://leetcode.cn/problems/network-delay-time/)）
* **994. 腐烂的橘子**（[LeetCode](https://leetcode.cn/problems/oranges-rotting/)）

### 拓扑排序与应用

* **210.课程表 II**（[LeetCode](https://leetcode.cn/problems/course-schedule-ii/)）
* **310. 最小高度树**（[LeetCode](https://leetcode.cn/problems/minimum-height-trees/)）

### 矩阵与隐式图转换

* **417. 太平洋大西洋水流问题**（[LeetCode](https://leetcode.cn/problems/pacific-atlantic-water-flow/)）
* **127. 单词接龙**（[LeetCode](https://leetcode.cn/problems/word-ladder/)）

---

---
url: /czxBlog/algorithm/data-structure/hash-table/index.md
---
# 哈希表
## 概述

\==哈希表（Hash Table）== 是一种基于键值对（key-value）存储的高效数据结构，通过哈希函数将键映射到存储位置，
实现平均时间复杂度 $O(1)$ 的插入、删除和查找操作。

::: center
![hash-table](/images/algorithm/hashtable.svg)
:::

以 `key-value` 形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。
只需要输入查找的键值，就可以快速地找到其对应的 value。
可以把哈希表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。

## 核心特性

### 哈希函数 (Hash Function)

**将任意大小的数据（键）映射到固定大小的值（哈希值）。**

要让键值对应到内存中的位置，就要为键值计算索引，也就是计算这个数据应该放到哪里。
这个根据键值计算索引的函数就叫做哈希函数，也称散列函数。

举个例子，如果键值是一个人的身份证号码，哈希函数就可以是号码的后四位，当然也可以是号码的前四位。
生活中常用的「手机尾号」也是一种哈希函数。
在实际的应用中，键值可能是更复杂的东西，比如浮点数、字符串、结构体等，这时候就要根据具体情况设计合适的哈希函数。
哈希函数应当易于计算，并且尽量使计算出来的索引均匀分布。

**对于 哈希函数，应该满足以下要求**：

* **一致性**：相同的键总是产生相同的哈希值。
* **高效性**：计算速度快。
* **均匀性**：尽可能均匀地分布哈希值，以减少冲突。

### 冲突解决 (Collision Resolution)

如果对于任意的键值，哈希函数计算出来的索引都不相同，那只用根据索引把 $(key, value)$ 放到对应的位置就行了。
但实际上，常常会出现两个不同的键值，他们用哈希函数计算出来的索引是相同的。这时候就需要一些方法来处理冲突。

**常见的冲突解决方法包括**:

* **开散列法（Open hashing）**：也称 **拉链法**，在每个存放数据的地方开一个链表，如果有多个键值索引到同一个地方，
  只用把他们都放到那个位置的链表里就行了。
  查询的时候需要把对应位置的链表整个扫一遍，对其中的每个数据比较其键值与查询的键值是否一致。

  如果索引的范围是 $1\ldots M$，哈希表的大小为 $N$，那么一次 插入/查询 需要进行期望 $O(\frac{N}{M})$ 次比较。

* **闭散列法（Closed hashing）**：把所有记录直接存储在散列表中，如果发生冲突则根据某种方式继续进行探查。

  比如线性探查法：如果在 `d` 处发生冲突，就依次检查 `d + 1`，`d + 2` ……

### 动态扩容 (Rehashing)

当负载因子（元素数/桶数）超过阈值（如 0.75）时，扩容并重新哈希所有元素。

## 哈希表的实现

```ts
type Bucket<K, V> = Array<[K, V]> // 桶结构：存储键值对元组的数组

class HashTable<K, V> {
  private buckets: Array<Bucket<K, V>>
  private capacity: number
  private size: number
  private loadFactor: number = 0.75

  constructor(initialCapacity: number = 16) {
    this.capacity = initialCapacity
    this.size = 0
    this.buckets = Array.from({ length: initialCapacity }, () => [])
  }

  // 哈希函数（简化版，实际需更健壮）
  private hash(key: K): number {
    const keyString = String(key)
    let hash = 0
    for (let i = 0; i < keyString.length; i++) {
      hash = (hash << 5) + keyString.charCodeAt(i)
      hash = hash & hash // 转为32位整数
      hash = Math.abs(hash)
    }
    return hash % this.capacity
  }

  // 插入/更新键值对
  put(key: K, value: V): void {
    const index = this.hash(key)
    const bucket = this.buckets[index]

    // 检查是否已存在相同key
    for (const pair of bucket) {
      if (pair[0] === key) {
        pair[1] = value // 更新值
        return
      }
    }

    // 新增键值对
    bucket.push([key, value])
    this.size++

    // 检查扩容
    if (this.size / this.capacity > this.loadFactor) {
      this.resize()
    }
  }

  // 获取值
  get(key: K): V | undefined {
    const index = this.hash(key)
    const bucket = this.buckets[index]
    for (const [k, v] of bucket) {
      if (k === key)
        return v
    }
    return undefined
  }

  // 删除键值对
  remove(key: K): boolean {
    const index = this.hash(key)
    const bucket = this.buckets[index]
    for (let i = 0; i < bucket.length; i++) {
      if (bucket[i][0] === key) {
        bucket.splice(i, 1)
        this.size--
        return true
      }
    }
    return false
  }

  // 动态扩容
  private resize(): void {
    const oldBuckets = this.buckets
    this.capacity *= 2
    this.buckets = Array.from({ length: this.capacity }, () => [])
    this.size = 0

    // 重新哈希所有元素
    for (const bucket of oldBuckets) {
      for (const [key, value] of bucket) {
        this.put(key, value) // 插入到新桶
      }
    }
  }

  // 当前元素数量
  getSize(): number {
    return this.size
  }
}
```

## 时间复杂度

| 操作     | 时间复杂度                | 说明                    |
| -------- | ------------------------- | ----------------------- |
| put()    | 平均 $O(1)$ ，最坏 $O(n)$ | 哈希计算 + 桶内线性扫描 |
| get()    | 平均 $O(1)$ ，最坏 $O(n)$ | 桶内线性查找            |
| remove() | 平均 $O(1)$ ，最坏 $O(n)$ | 桶内查找后删除          |
| resize() | $O(n)$                    | 所有元素重新哈希        |

## 适用场景

* 高频插入/删除且需快速查找
* 缓存实现（如 LRU Cache）
* 数据库索引
* 字典类应用（词频统计）

## 相关问题

[**LeetCode** - 哈希表](https://leetcode.cn/problem-list/hash-table/){.read-more}
[**LeetCode** - 哈希函数](https://leetcode.cn/problem-list/hash-function/){.read-more}

### 基础操作（数组/集合/映射）

* **1. 两数之和**（[LeetCode](https://leetcode.cn/problems/two-sum/)）
* **242. 有效的字母异位词**（[LeetCode](https://leetcode.cn/problems/valid-anagram/)）
* **349. 两个数组的交集**（[LeetCode](https://leetcode.cn/problems/intersection-of-two-arrays/)）
* **202. 快乐数**（[LeetCode](https://leetcode.cn/problems/happy-number/)）

### 复杂数据结构与策略

* **146. LRU 缓存**（[LeetCode](https://leetcode.cn/problems/lru-cache/)）
* **49. 字母异位词分组**（[LeetCode](https://leetcode.cn/problems/group-anagrams/)）
* **974. 和可被 K 整除的子数组**（[LeetCode](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)）

### 多步骤哈希优化

* **454. 四数相加 II**（[LeetCode](https://leetcode.cn/problems/4sum-ii/)）
* **347. 前 K 个高频元素**（[LeetCode](https://leetcode.cn/problems/top-k-frequent-elements/)）
* **128. 最长连续序列**（[LeetCode](https://leetcode.cn/problems/longest-consecutive-sequence/)）

---

---
url: /czxBlog/algorithm/data-structure/heap/index.md
---
# 堆
::: info 本篇仅讨论 **二叉堆**
:::

## 概述

\==堆（heap）== 是一种完全二叉树结构，满足以下性质：

* **堆序性**：每个节点的值必须满足特定顺序关系

  * **最大堆**：父节点值 ≥ 子节点值（根节点最大）
  * **最小堆**：父节点值 ≤ 子节点值（根节点最小）

* **结构完整性**：除最后一层外，其他层节点必须全满，且最后一层节点靠左排列

## 堆的实现

### 插入操作

**插入操作** 是指向二叉堆中插入一个元素，要保证插入后也是一棵完全二叉树。

最简单的方法就是，最下一层最右边的叶子之后插入。如果最下一层已满，就新增一层。
插入之后如果不满足堆性质，则采用 **向上调整** ：

如果这个节点的权值大于它父节点的权值，就交换，重复此过程直到不满足或者到根。
可以证明，插入之后向上调整后，没有其他接点会不满足堆性质。

**向上调整** 的时间复杂度是 $O(\log n)$ 。

:::center
![插入操作](/images/algorithm/binary-heap-insert.svg)
:::

### 删除操作

**删除操作** 指删除堆中最大的元素，即删除根结点。

但是如果直接删除，则变成了两个堆，难以处理。
所以不妨考虑 **插入操作的逆过程**，设法将根节点移到最后一个结点，然后直接删掉。
然而实际上不好做，我们通常采用的方法是，把根节点和最后一个节点直接交换。
于是直接删掉（在最后一个节点处的）根结点，但是新的根节点可能不满足堆性质。
这时候可以采用 **向下调整** :

在该节点的子节点中，找一个最大的，与该节点交换，重复此过程直到底层。
可以证明，删除并向下调整后，没有其他节点不满足堆性质。

时间复杂度 $O(\log n)$ 。

### 核心特性

* **数组表示**：堆通常使用数组存储（利用完全二叉树特性）

  索引计算（设当前索引为 i）：

  ```ts
  parentIndex = Math.floor((i - 1) / 2)
  leftChildIndex = 2 * i + 1
  rightChildIndex = 2 * i + 2
  ```

### 最大堆实现

```ts :collapsed-lines
class MaxHeap {
  private heap: number[]

  constructor() {
    this.heap = []
  }

  // 获取父节点索引
  private getParentIndex(index: number): number {
    return Math.floor((index - 1) / 2)
  }

  // 获取左子节点索引
  private getLeftChildIndex(index: number): number {
    return 2 * index + 1
  }

  // 获取右子节点索引
  private getRightChildIndex(index: number): number {
    return 2 * index + 2
  }

  // 交换元素
  private swap(i: number, j: number): void {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]]
  }

  // 上浮操作（插入后维护堆）
  private siftUp(): void {
    let currentIndex = this.heap.length - 1
    while (currentIndex > 0) {
      const parentIndex = this.getParentIndex(currentIndex)
      if (this.heap[currentIndex] > this.heap[parentIndex]) {
        this.swap(currentIndex, parentIndex)
        currentIndex = parentIndex
      }
      else {
        break
      }
    }
  }

  // 下沉操作（删除后维护堆）
  private siftDown(): void {
    let currentIndex = 0
    const size = this.heap.length

    while (this.getLeftChildIndex(currentIndex) < size) {
      const leftChildIndex = this.getLeftChildIndex(currentIndex)
      const rightChildIndex = this.getRightChildIndex(currentIndex)
      let largerChildIndex = leftChildIndex

      // 选择较大的子节点
      if (rightChildIndex < size
        && this.heap[rightChildIndex] > this.heap[leftChildIndex]) {
        largerChildIndex = rightChildIndex
      }

      // 与当前节点比较
      if (this.heap[currentIndex] < this.heap[largerChildIndex]) {
        this.swap(currentIndex, largerChildIndex)
        currentIndex = largerChildIndex
      }
      else {
        break
      }
    }
  }

  // 插入元素
  insert(value: number): void {
    this.heap.push(value)
    this.siftUp()
  }

  // 删除并返回堆顶元素
  extractMax(): number | null {
    if (this.heap.length === 0)
      return null

    const max = this.heap[0]
    const last = this.heap.pop()!

    if (this.heap.length > 0) {
      this.heap[0] = last
      this.siftDown()
    }

    return max
  }

  // 获取堆顶元素（不删除）
  peek(): number | null {
    return this.heap[0] ?? null
  }

  // 获取堆大小
  size(): number {
    return this.heap.length
  }

  // 堆排序（原地排序）
  static heapSort(arr: number[]): number[] {
    const heap = new MaxHeap()

    // 构建堆
    for (const num of arr) heap.insert(num)

    // 依次提取最大值
    const sorted: number[] = []
    while (heap.size() > 0) {
      sorted.unshift(heap.extractMax()!)
    }

    return sorted
  }
}
```

### 最小堆实现

最小堆实现进需要在 最大堆 的基础上进行修改，调整比较逻辑：

```ts
class MinHeap {
  private heap: number[] = []

  // ...（索引计算和swap方法同MaxHeap）

  private siftUp() {
    let index = this.heap.length - 1
    while (index > 0) {
      const parentIndex = this.getParentIndex(index)
      if (this.heap[index] < this.heap[parentIndex]) {
        this.swap(index, parentIndex)
        index = parentIndex
      }
      else {
        break
      }
    }
  }

  private siftDown() {
    let index = 0
    const length = this.heap.length

    while (true) {
      const leftChildIndex = this.getLeftChildIndex(index)
      const rightChildIndex = this.getRightChildIndex(index)
      let smallest = index

      if (leftChildIndex < length
        && this.heap[leftChildIndex] < this.heap[smallest]) {
        smallest = leftChildIndex
      }

      if (rightChildIndex < length
        && this.heap[rightChildIndex] < this.heap[smallest]) {
        smallest = rightChildIndex
      }

      if (smallest !== index) {
        this.swap(index, smallest)
        index = smallest
      }
      else {
        break
      }
    }
  }

  // 其他方法与MaxHeap类似
}
```

## 时间复杂度

| 操作           | 时间复杂度   | 说明                          |
| -------------- | ------------ | ----------------------------- |
| `insert()`     | $O(log n)$   | 最坏情况下上浮整棵树高度      |
| `extractMax()` | $O(log n)$   | 最坏情况下下沉整棵树高度      |
| `peek()`       | $O(1) $      | 直接访问数组首元素            |
| `buildHeap()`  | $O(n)$       | Floyd 算法自底向上堆化        |
| `heapSort()`   | $O(n log n)$ | 每次 extractMax 为 $O(log n)$ |

:::warning 注意
虽然单个插入操作是 $O(log n)$ ，但将 n 个元素插入空堆的总体时间复杂度是 $O(n log n)$ ，而 Floyd 建堆算法只需 $O(n)$ 。
:::

## 适用场景

* **优先队列**：

  ```ts
  class PriorityQueue {
    private heap = new MaxHeap()

    enqueue(val: number) { this.heap.insert(val) }
    dequeue() { return this.heap.extractMax() }
  }
  ```

* **堆排序**：

  * 时间复杂度：O(n log n)
  * 空间复杂度：O(1)（原地排序）

  ```ts
  const arr = [4, 10, 3, 5, 1]
  const sorted = MaxHeap.heapSort(arr) // [1, 3, 4, 5, 10]
  ```

* **Top K 问题**：

  ```ts
  function findTopK(nums: number[], k: number): number[] {
    const minHeap = new MinHeap() // 最小堆实现类似
    for (const num of nums) {
      minHeap.insert(num)
      if (minHeap.size() > k)
        minHeap.extractMin()
    }
    return minHeap.toArray()
  }
  ```

* **Dijkstra 算法**：优先队列优化最短路径搜索

## 相关问题

[**LeetCode** - 堆（优先队列）](https://leetcode.cn/problem-list/heap-priority-queue/){.read-more}

### 堆排序与选择问题

* **703. 数据流中的第 K 大元素**（[LeetCode](https://leetcode.cn/problems/kth-largest-element-in-a-stream/)）
* **215. 数组中的第K个最大元素**（[LeetCode](https://leetcode.cn/problems/kth-largest-element-in-an-array/)）
* **347. 前 K 个高频元素**（[LeetCode](https://leetcode.cn/problems/top-k-frequent-elements/)）

### 多堆结构与复杂规则处理

* **23. 合并 K 个升序链表**（[LeetCode](https://leetcode.cn/problems/merge-k-sorted-lists/)）
* **295. 数据流的中位数**（[LeetCode](https://leetcode.cn/problems/find-median-from-data-stream/)）
* **239. 滑动窗口最大值**（[LeetCode](https://leetcode.cn/problems/sliding-window-maximum/)）

### 综合场景

* **313. 超级丑数**（[LeetCode](https://leetcode.cn/problems/super-ugly-number/)）
* **786. 第 K 个最小的素数分数**（[LeetCode](https://leetcode.cn/problems/k-th-smallest-prime-fraction/)）
* **871. 最低加油次数**（[LeetCode](https://leetcode.cn/problems/minimum-number-of-refueling-stops/)）

---

---
url: /czxBlog/algorithm/data-structure/linked-list/index.md
---
# 链表
## 概述

链表是一种用于存储数据的数据结构，通过如链条一般的指针来连接元素。
它的特点是插入与删除数据十分方便，但寻找与读取数据的表现欠佳。

## 核心特性

* **节点（Node）**：

  * 存储数据（value）
  * 指向下一个节点的指针（next）
  * 双向链表额外包含指向前一个节点的指针（prev）

* **头指针（Head）**：

  * 指向链表的第一个节点
  * 链表入口点

* **尾节点（Tail）**：

  * 最后一个节点，其 next 指向 null

## 单向链表

单向链表中包含数据域和指针域，其中数据域用于存放数据，指针域用来连接当前结点和下一节点。

:::center
![linked list](/images/algorithm/linked-list.svg)
:::

### 插入数据

单向链表插入数据的流程大致如下：

::: steps

1. 初始化待插入的数据 node

   ![insert node](/images/algorithm/linked-list-insert-1.svg)

2. 将 node 的 next 指针指向 p 的下一个结点

   ![insert node](/images/algorithm/linked-list-insert-2.svg)

3. 将 p 的 next 指针指向 node

   ![insert node](/images/algorithm/linked-list-insert-3.svg)

:::

对于 **单向循环链表** ，由于链表首尾相连，在插入数据时需要判断原链表是否为空：为空则自身循环，不为空则正常插入数据。

大致流程如下：

1. 初始化待插入的数据 node；
2. 判断给定链表 p 是否为空；
3. 若为空，则将 node 的 next 指针和 p 都指向自己；
4. 否则，将 node 的 next 指针指向 p 的下一个结点；
5. 将 p 的 next 指针指向 node。

::: steps

* ![insert node](/images/algorithm/linked-list-insert-cyclic-1.svg)
* ![insert node](/images/algorithm/linked-list-insert-cyclic-2.svg)
* ![insert node](/images/algorithm/linked-list-insert-cyclic-3.svg)

:::

### 删除数据

设待删除结点为 p，从链表中删除它时，将 p 的下一个结点 p->next 的值覆盖给 p 即可，与此同时更新 p 的下下个结点。

流程大致如下：

1. 将 p 下一个结点的值赋给 p，以抹掉 p->value；
2. 新建一个临时结点 t 存放 p->next 的地址；
3. 将 p 的 next 指针指向 p 的下下个结点，以抹掉 p->next；
4. 删除 t。此时虽然原结点 p 的地址还在使用，删除的是原结点 p->next 的地址，但 p 的数据被 p->next 覆盖，p 名存实亡。

**参考**：

::: steps

* ![delete node](/images/algorithm/linked-list-delete-1.svg)
* ![delete node](/images/algorithm/linked-list-delete-2.svg)
* ![delete node](/images/algorithm/linked-list-delete-3.svg)

:::

### 单向链表实现

1. 定义节点类

```ts
class ListNode<T> {
  value: T
  next: ListNode<T> | null

  constructor(value: T) {
    this.value = value
    this.next = null
  }
}
```

2. 定义链表类

```ts :collapsed-lines
class SinglyLinkedList<T> {
  private head: ListNode<T> | null
  private size: number

  constructor() {
    this.head = null
    this.size = 0
  }

  // 插入到尾部 (O(n))
  append(value: T): void {
    const newNode = new ListNode(value)
    if (!this.head) {
      this.head = newNode
    }
    else {
      let current = this.head
      while (current.next) {
        current = current.next
      }
      current.next = newNode
    }
    this.size++
  }

  // 插入到头部 (O(1))
  prepend(value: T): void {
    const newNode = new ListNode(value)
    newNode.next = this.head
    this.head = newNode
    this.size++
  }

  // 删除节点 (O(n))
  delete(value: T): void {
    if (!this.head)
      return

    if (this.head.value === value) {
      this.head = this.head.next
      this.size--
      return
    }

    let current = this.head
    while (current.next) {
      if (current.next.value === value) {
        current.next = current.next.next
        this.size--
        return
      }
      current = current.next
    }
  }

  // 查找节点 (O(n))
  find(value: T): ListNode<T> | null {
    let current = this.head
    while (current) {
      if (current.value === value)
        return current
      current = current.next
    }
    return null
  }

  // 获取长度 (O(1))
  getLength(): number {
    return this.size
  }

  // 转换为数组 (O(n))
  toArray(): T[] {
    const result: T[] = []
    let current = this.head
    while (current) {
      result.push(current.value)
      current = current.next
    }
    return result
  }
}
```

## 双向链表

双向链表中同样有数据域和指针域。不同之处在于，指针域有左右（或上一个、下一个）之分，用来连接上一个结点、当前结点、下一个结点。

:::center
![double linked list](/images/algorithm/double-linked-list.svg)
:::

### 插入数据

在向双向（循环）链表插入数据时，除了要判断给定链表是否为空外，还要同时修改左、右两个指针。

大致流程如下：

1. 初始化待插入的数据 node；
2. 判断给定链表 p 是否为空；
3. 若为空，则将 node 的 left 和 right 指针，以及 p 都指向自己；
4. 否则，将 node 的 left 指针指向 p;
5. 将 node 的 right 指针指向 p 的右结点；
6. 将 p 右结点的 left 指针指向 node；
7. 将 p 的 right 指针指向 node。

### 删除数据

流程大致如下：

1. 将 p 左结点的右指针指向 p 的右节点；
2. 将 p 右结点的左指针指向 p 的左节点；
3. 新建一个临时结点 t 存放 p 的地址；
4. 将 p 的右节点地址赋给 p，以避免 p 变成悬垂指针；
5. 删除 t。

### 双向链表实现

1. 定义节点类

```ts
class DoublyListNode<T> {
  value: T
  next: DoublyListNode<T> | null
  prev: DoublyListNode<T> | null

  constructor(value: T) {
    this.value = value
    this.next = null
    this.prev = null
  }
}
```

2. 定义双向链表类

```ts :collapsed-lines
class DoublyLinkedList<T> {
  private head: DoublyListNode<T> | null
  private tail: DoublyListNode<T> | null
  private size: number

  constructor() {
    this.head = null
    this.tail = null
    this.size = 0
  }

  // 尾部插入 (O(1))
  append(value: T): void {
    const newNode = new DoublyListNode(value)
    if (!this.tail) {
      this.head = newNode
      this.tail = newNode
    }
    else {
      this.tail.next = newNode
      newNode.prev = this.tail
      this.tail = newNode
    }
    this.size++
  }

  // 头部插入 (O(1))
  prepend(value: T): void {
    const newNode = new DoublyListNode(value)
    if (!this.head) {
      this.head = newNode
      this.tail = newNode
    }
    else {
      newNode.next = this.head
      this.head.prev = newNode
      this.head = newNode
    }
    this.size++
  }

  // 删除节点 (O(n))
  delete(value: T): void {
    if (!this.head)
      return

    let current: DoublyListNode<T> | null = this.head
    while (current) {
      if (current.value === value) {
        if (current === this.head) {
          this.head = current.next
          if (this.head)
            this.head.prev = null
        }
        else if (current === this.tail) {
          this.tail = current.prev
          if (this.tail)
            this.tail.next = null
        }
        else {
          current.prev!.next = current.next
          current.next!.prev = current.prev
        }
        this.size--
        return
      }
      current = current.next
    }
  }
}
```

## 时间复杂度

| 操作     | 单向链表 | 双向链表 |
| -------- | -------- | -------- |
| 插入头部 | $O(1)$   | $O(1)$   |
| 插入尾部 | $O(n)$   | $O(1)$   |
| 删除头部 | $O(1)$   | $O(1)$   |
| 删除尾部 | $O(n)$   | $O(1)$   |
| 随机访问 | $O(n)$   | $O(n)$   |
| 查找元素 | $O(n)$   | $O(n)$   |

## 与数组的区别

链表和数组都可用于存储数据。与链表不同，数组将所有元素按次序依次存储。不同的存储结构令它们有了不同的优势：

* 链表因其链状的结构，能方便地删除、插入数据，操作次数是 $O(1)$ 。
  但也因为这样，寻找、读取数据的效率不如数组高，在随机访问数据中的操作次数是 $O(n)$ 。

* 数组可以方便地寻找并读取数据，在随机访问中操作次数是 $O(1)$ 。但删除、插入的操作次数是 $O(n)$ 次。

| 特性          | 链表               | 数组              |
| ------------- | ------------------ | ----------------- |
| 内存分配      | 动态分配（非连续） | 静态/连续内存     |
| 插入/删除效率 | $O(1)$ 在已知位置  | $O(n)$ 需移动元素 |
| 随机访问      | $O(n)$ 需要遍历    | $O(1)$ 通过索引   |
| 内存开销      | 额外存储指针       | 无额外开销        |
| 缓存友好度    | 差（内存不连续）   | 好（局部性原理）  |

## 应用场景

* **实现栈/队列**：

  ```ts
  // 基于链表的队列
  class Queue<T> {
    private list = new SinglyLinkedList<T>()

    enqueue(value: T) { this.list.append(value) }
    dequeue(): T | undefined { /* ... */ }
  }
  ```

* **LRU缓存淘汰算法**：

  使用双向链表 + HashMap 实现 O(1) 的插入/删除

* **大文件处理**：

  避免数组连续内存限制，分段处理数据

* **撤销操作历史记录**：

  双向链表实现前进/后退功能

## 链表使用技巧

* **虚拟头节点**：

  ```ts
  // 简化边界处理
  const dummyHead = new ListNode(0)
  dummyHead.next = head
  // ...操作后返回 dummyHead.next
  ```

* **快慢指针**：

  ```ts
  // 检测环/找中点
  let slow = head
  let fast = head
  while (fast && fast.next) {
    slow = slow.next!
    fast = fast.next.next!
  }
  ```

* **反转链表**：

  ```ts
  function reverseList<T>(head: ListNode<T> | null): ListNode<T> | null {
    let prev = null
    let current = head
    while (current) {
      const next = current.next
      current.next = prev
      prev = current
      current = next
    }
    return prev
  }
  ```

## 相关问题

[**LeetCode** - 链表](https://leetcode.cn/problem-list/linked-list/){.read-more}

### 基础操作

* **206. 反转链表**（[LeetCode](https://leetcode.cn/problems/reverse-linked-list/)）
* **21. 合并两个有序链表**（[LeetCode](https://leetcode.cn/problems/merge-two-sorted-lists/)）
* **83. 删除排序链表中的重复元素**（[LeetCode](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)）
* **203. 移除链表元素**（[LeetCode](https://leetcode.cn/problems/remove-linked-list-elements/)）

### 双指针技巧

* **141. 环形链表**（[LeetCode](https://leetcode.cn/problems/linked-list-cycle/)）
* **19. 删除链表的倒数第 N 个结点**（[LeetCode](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)）
* **876. 链表的中间结点**（[LeetCode](https://leetcode.cn/problems/middle-of-the-linked-list/)）

### 递归与归并

* **24. 两两交换链表中的节点**（[LeetCode](https://leetcode.cn/problems/swap-nodes-in-pairs/)）
* **23. 合并 K 个升序链表**（[LeetCode](https://leetcode.cn/problems/merge-k-sorted-lists/)）
* **148. 排序链表**（[LeetCode](https://leetcode.cn/problems/sort-list/)）

### 其它

* **138. 复制带随机指针的链表**（[LeetCode](https://leetcode.cn/problems/copy-list-with-random-pointer/)）
* **234. 回文链表**（[LeetCode](https://leetcode.cn/problems/palindrome-linked-list/)）
* **143. 重排链表**（[LeetCode](https://leetcode.cn/problems/reorder-list/)）

---

---
url: /czxBlog/algorithm/data-structure/overview/index.md
---
# 介绍
数据结构是在计算机中存储、组织数据的方式。小到变量、数组，大到线段树、平衡树，都是数据结构。

程序运行离不开数据结构，不同的数据结构又各有优劣，能够处理的问题各不相同，而根据具体问题选取合适的数据结构，
可以大大提升程序的效率。

一般你可以从两个维度来理解它，逻辑结构和存储结构。

## 逻辑结构

逻辑结构指数据之间的关系，逻辑结构大概统一的可以分成两种：线性结构、非线性结构。

* **线性结构**

  一个有序数据元素的集合。
  其中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。

  常用的线性结构有: 栈，队列，链表，线性表。

  ```mermaid
  block-beta
  A B C D E F G H
  ```

* **非线性结构**

  各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。

  常见的非线性结构有 二维数组，树等。

  ```mermaid
  flowchart TD
    A --> B
    A --> C
    B --> D
    B --> E
    C --> F
    C --> G
  ```

## 存储结构

逻辑结构指的是数据间的关系，而存储结构是逻辑结构用计算机语言的实现。

常见的存储结构有顺序存储、链式存储、索引存储以及散列存储。

例如：

* 数组在内存中的位置是连续的，它就属于顺序存储；
* 链表是主动建立数据间的关联关系的，在内存中却不一定是连续的，它属于链式存储；
* 还有顺序和逻辑上都不存在顺序关系，但是你可以通过一定的方式去放问它的哈希表，数据散列存储。

---

---
url: /czxBlog/algorithm/data-structure/queue/index.md
---
# 队列
## 概述

\==队列（Queue）== 是一种 先进先出（FIFO: First-In-First-Out） 的线性数据结构，类似于现实生活中的排队场景。

在队列中，元素从一端（队尾）添加，从另一端（队首）移除。

:::center
![stack](/images/algorithm/queue.svg)
:::

::: tip 提示
当我们在排队买票时，排在队首的人先买票，然后离开队伍。
新来的人需要排到队伍尾部，等待前面的人买完票再轮到他。
:::

## 核心特性

* **操作受限**：只允许在两端操作
* **先进先出**：最早入队的元素最先出队
* **动态大小**：长度随操作变化（非固定容量）

## 时间复杂度

| 操作        | 描述                   | TypeScript 实现示例         |
|-------------|------------------------|----------------------------|
| `enqueue()` | 元素入队（添加到队尾） | `queue.push(item)`         |
| `dequeue()` | 元素出队（移除队首元素）| `queue.shift()`            |
| `peek()`    | 查看队首元素（不移除） | `queue[0]`                 |
| `isEmpty()` | 检查队列是否为空       | `queue.length === 0`       |
| `size()`    | 获取队列长度           | `queue.length`             |

## 队列的实现

### 数组实现

**注意**：`shift()` 操作需要移动所有元素（时间复杂度 O(n)）

```ts
class ArrayQueue<T> {
  private items: T[] = []

  enqueue(item: T): void {
    this.items.push(item)
  }

  dequeue(): T | undefined {
    return this.items.shift()
  }

  peek(): T | undefined {
    return this.items[0]
  }

  get size(): number {
    return this.items.length
  }

  isEmpty(): boolean {
    return this.items.length === 0
  }

  clear(): void {
    this.items = []
  }
}
```

### 链表实现

所有操作时间复杂度均为 O(1)

```ts
class QueueNode<T> {
  constructor(
    public value: T,
    public next: QueueNode<T> | null = null
  ) {}
}

class LinkedListQueue<T> {
  private front: QueueNode<T> | null = null
  private rear: QueueNode<T> | null = null
  private _size = 0

  enqueue(item: T): void {
    const newNode = new QueueNode(item)
    if (this.isEmpty()) {
      this.front = newNode
    }
    else {
      this.rear!.next = newNode
    }
    this.rear = newNode
    this._size++
  }

  dequeue(): T | undefined {
    if (this.isEmpty())
      return undefined

    const removed = this.front!
    this.front = this.front!.next
    this._size--

    if (this.isEmpty())
      this.rear = null
    return removed.value
  }

  peek(): T | undefined {
    return this.front?.value
  }

  get size(): number {
    return this._size
  }

  isEmpty(): boolean {
    return this._size === 0
  }

  clear(): void {
    this.front = null
    this.rear = null
    this._size = 0
  }
}
```

### 循环队列实现

解决数组实现的性能问题，使用环形缓冲区，适用于 **固定容量优化** 的场景

```ts
class CircularQueue<T> {
  private items: (T | undefined)[]
  private front = 0
  private rear = -1
  private count = 0

  constructor(private capacity: number) {
    this.items = Array.from({ length: capacity })
  }

  enqueue(item: T): boolean {
    if (this.isFull())
      return false

    this.rear = (this.rear + 1) % this.capacity
    this.items[this.rear] = item
    this.count++
    return true
  }

  dequeue(): T | undefined {
    if (this.isEmpty())
      return undefined

    const item = this.items[this.front]
    this.front = (this.front + 1) % this.capacity
    this.count--
    return item
  }

  peek(): T | undefined {
    return this.isEmpty() ? undefined : this.items[this.front]
  }

  isFull(): boolean {
    return this.count === this.capacity
  }

  isEmpty(): boolean {
    return this.count === 0
  }

  get size(): number {
    return this.count
  }
}
```

## 应用场景

* **任务调度**：CPU 进程调度、打印机任务队列
* **广度优先搜索**：树/图的层级遍历
* **消息传递**：消息队列（RabbitMQ/Kafka）
* **缓冲区管理**：网络数据包处理
* **撤销操作栈**：编辑器中的撤销历史记录

## 复杂度对比

| 操作        | 数组实现 | 链表实现 | 循环队列 |
|-------------|----------|----------|----------|
| **enqueue** | O(1)\*   | O(1)     | O(1)     |
| **dequeue** | O(n)     | O(1)     | O(1)     |
| **peek**    | O(1)     | O(1)     | O(1)     |
| **空间**    | O(n)     | O(n)     | O(n)     |

::: warning 注：数组的 push() 平均 O(1)，但动态扩容时可能 O(n)
:::

## 相关问题

[**LeetCode** - 队列](https://leetcode.cn/problem-list/queue/){.read-more}

### 基础操作

* **232. 用栈实现队列**（[LeetCode](https://leetcode.cn/problems/implement-queue-using-stacks/)）
* **622. 设计循环队列**（[LeetCode](https://leetcode.cn/problems/design-circular-queue/)）

### 广度优先搜索 (BFS)

* **102. 二叉树的层序遍历**（[LeetCode](https://leetcode.cn/problems/binary-tree-level-order-traversal/)）
* **752. 打开转盘锁**（[LeetCode](https://leetcode.cn/problems/open-the-lock/)）
* **994. 腐烂的橘子**（[LeetCode](https://leetcode.cn/problems/rotting-oranges/)）

### 单调队列

* **239. 滑动窗口最大值**（[LeetCode](https://leetcode.cn/problems/sliding-window-maximum/)）
* **862. 和至少为 K 的最短子数组**（[LeetCode](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)）

---

---
url: /czxBlog/algorithm/data-structure/stack/index.md
---
# 栈
## 概述

\==栈== 是一种遵循 **后进先出（LIFO） 原则** 的线性数据结构，类似于现实中的一摞盘子或书籍。

::: center
![stack](/images/algorithm/stack.svg)
:::

::: tip 提示
想象一下，我们把盘子从上到下依次摆放在桌子上，当我们要用到盘子时，就从最上面取走一个盘子，
放回盘子时，则是把盘子放在最上面。
:::

## 核心特性

* **后进先出（LIFO）**：最后添加的元素最先被移除
* **单端操作**：所有操作（插入/删除/访问）仅在栈顶（Top）进行

## 时间复杂度

* **压栈（Push）**: O(1)
* **弹栈（Pop）**: O(1)
* **查看栈顶（Peek）**: O(1)

## 栈的实现

### 使用数组模拟栈

```ts
class ArrayStack<T> {
  private items: T[]

  constructor() {
    this.items = []
  }

  // 压栈
  push(element: T): void {
    this.items.push(element)
  }

  // 弹栈
  pop(): T | undefined {
    return this.items.pop()
  }

  // 查看栈顶元素
  peek(): T | undefined {
    return this.items[this.items.length - 1]
  }

  // 判断空栈
  isEmpty(): boolean {
    return this.items.length === 0
  }

  // 获取栈大小
  size(): number {
    return this.items.length
  }

  // 清空栈
  clear(): void {
    this.items = []
  }

  // 打印栈内容
  print(): string {
    return this.items.toString()
  }
}
```

### 使用链表模拟栈

```ts
class LinkedNode<T> {
  constructor(
    public value: T,
    public next: LinkedNode<T> | null = null
  ) {}
}

class LinkedListStack<T> {
  private top: LinkedNode<T> | null = null
  private count: number = 0

  push(element: T): void {
    const newNode = new LinkedNode(element)
    newNode.next = this.top
    this.top = newNode
    this.count++
  }

  pop(): T | undefined {
    if (!this.top)
      return undefined
    const value = this.top.value
    this.top = this.top.next
    this.count--
    return value
  }

  peek(): T | undefined {
    return this.top?.value
  }

  isEmpty(): boolean {
    return this.count === 0
  }

  size(): number {
    return this.count
  }

  clear(): void {
    this.top = null
    this.count = 0
  }
}
```

## 应用场景

* **函数调用栈**（程序执行上下文管理）
* **括号匹配校验**（编译器语法检查）
* **撤销操作（Undo）**（编辑器历史记录）
* **深度优先搜索（DFS）**（图遍历算法）
* **表达式求值**（中缀转后缀表达式）
* **浏览器历史记录**（前进/后退功能）

::: important
掌握 **栈** 的关键在于理解其 **LIFO 特性** 和 **受限的操作方式**，
这种特性使其在需要"撤销"或"回溯"的场景中具有天然优势。
:::

## 相关题目

[**LeetCode** - 栈](https://leetcode.cn/problem-list/stack/){.read-more}

### 基础操作

* **20. 有效的括号**（[LeetCode](https://leetcode.cn/problems/valid-parentheses/)）
* **225. 用队列实现栈**（[LeetCode](https://leetcode.cn/problems/implement-stack-using-queues/)）
* **155. 最小栈**（[LeetCode](https://leetcode.cn/problems/min-stack/)）

### 表达式求值

* **150. 逆波兰表达式求值**（[LeetCode](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)）
* **227. 基本计算器 II**（[LeetCode](https://leetcode.cn/problems/basic-calculator-ii/)）

### 单调栈

* **496. 下一个更大元素 I**（[LeetCode](https://leetcode.cn/problems/next-greater-element-i/)）
* **503. 下一个更大元素 II**（[LeetCode](https://leetcode.cn/problems/next-greater-element-ii/)）
* **739. 每日温度**（[LeetCode](https://leetcode.cn/problems/daily-temperatures/)）
* **42. 接雨水**（[LeetCode](https://leetcode.cn/problems/trapping-rain-water/)）

### 深度优先搜索（DFS）

* **94. 二叉树的中序遍历**（[LeetCode](https://leetcode.cn/problems/binary-tree-inorder-traversal/)）
* **144. 二叉树的前序遍历**（[LeetCode](https://leetcode.cn/problems/binary-tree-preorder-traversal/)）
* **341. 扁平化嵌套列表迭代器**（[LeetCode](https://leetcode.cn/problems/flatten-nested-list-iterator/)）

### 特殊栈应用

* **316. 去除重复字母**（[LeetCode](https://leetcode.cn/problems/remove-duplicate-letters/)）
* **394. 字符串解码**（[LeetCode](https://leetcode.cn/problems/decode-string/)）
* **456. 132 模式**（[LeetCode](https://leetcode.cn/problems/132-pattern/)）

---

---
url: /czxBlog/algorithm/depth-first-search/index.md
---
# 深度优先搜索
## 概述

\==深度优先搜索（Depth-First Search）（DFS）== 是一种用于遍历或搜索树或图的算法。

其核心思想是尽可能深地探索分支，直到达到末端，然后回溯并探索其他分支。

::: note 该算法常常与 BFS 并列，但两者除了都能遍历图的连通块以外，用途完全不同，很少有能混用两种算法的情况。
:::

## 过程

DFS 最显著的特征在于其 **递归调用自身**。
同时与 BFS 类似，DFS 会对其访问过的点打上访问标记，在遍历图时跳过已打过标记的点，以确保 **每个点仅访问一次** 。
符合以上两条规则的函数，便是广义上的 DFS。

具体地说，DFS 大致结构如下：

```txt title="伪代码"
DFS(v) // v 可以是图中的一个顶点，也可以是抽象的概念，如 dp 状态等。
  在 v 上打访问标记
  for u in v 的相邻节点
    if u 没有打过访问标记 then
      DFS(u)
    end
  end
end
```

## 核心原理

* **深度优先**：从起始节点开始，沿一条路径不断深入直到末端，再回溯探索其他路径。
* **递归/栈结构**：天然适合递归实现（隐式栈），也可用显式栈迭代实现。
* **回溯机制**：当节点无未访问邻居时，回退到上一个节点。
* **避免重复访问**：需记录已访问节点（通常用 Set 或数组）。

## 复杂度分析

该算法通常的时间复杂度为 $O(n+m)$，空间复杂度为 $O(n)$，其中 $n$ 表示点数，$m$ 表示边数。

注意空间复杂度包含了栈空间，栈空间的空间复杂度是 $O(n)$ 的。
在平均 $O(1)$ 遍历一条边的条件下才能达到此时间复杂度，例如用前向星或邻接表存储图；
如果用邻接矩阵则不一定能达到此复杂度。

## 实现方式

### 递归实现

```ts
type Graph = Record<string, string[]>

function dfsRecursive(
  graph: Graph,
  node: string,
  visited: Set<string> = new Set()
): void {
  // 1. 访问当前节点
  console.log(node)
  visited.add(node)

  // 2. 递归访问所有未访问的邻居
  for (const neighbor of graph[node] || []) {
    if (!visited.has(neighbor)) {
      dfsRecursive(graph, neighbor, visited)
    }
  }
}
```

### 迭代实现（显式栈）

```ts
function dfsIterative(graph: Graph, start: string): void {
  const stack: string[] = [start]
  const visited = new Set<string>()

  while (stack.length > 0) {
    const node = stack.pop()! // 从栈顶弹出节点
    if (visited.has(node))
      continue

    // 访问节点
    console.log(node)
    visited.add(node)

    // 将邻居逆序入栈（保持与递归相同顺序）
    const neighbors = graph[node] || []
    for (let i = neighbors.length - 1; i >= 0; i--) {
      if (!visited.has(neighbors[i])) {
        stack.push(neighbors[i])
      }
    }
  }
}
```

## 注意事项

* **栈溢出**：深度过大时递归可能导致栈溢出，可改用迭代法。
* **环检测**：在递归中若遇到已访问节点且非父节点，说明存在环。
* **非连通图**：需遍历所有未访问节点作为新起点。

## 相关题目

[**LeetCode** - 深度优先搜索 Depth-First Search](https://leetcode.cn/problem-list/depth-first-search/){.read-more}

### 矩阵遍历类（二维网格DFS）

* **200. 岛屿数量**（[LeetCode](https://leetcode.cn/problems/number-of-islands/)）
* **417. 太平洋大西洋水流问题**（[LeetCode](https://leetcode.cn/problems/pacific-atlantic-water-flow/)）
* **LCR 129. 字符迷宫** （[LeetCode](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)）

### 树与图遍历类（递归/隐式栈）

* **1038. 从二叉搜索树到更大树**（[LeetCode](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)）
* **100. 相同的树**（[LeetCode](https://leetcode.cn/problems/same-tree/)）
* **105. 从前序与中序遍历序列构造二叉树**（[LeetCode](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)）


### 回溯与组合类（路径/状态管理）

* **39. 组合总和**（[LeetCode](https://leetcode.cn/problems/combination-sum/)）
* **40. 组合总和 II**（[LeetCode](https://leetcode.cn/problems/combination-sum-ii/)）
* **LCP 07. 传递信息** （[LeetCode](https://leetcode.cn/problems/chuan-di-xin-xi/)）

### 进阶挑战题

* **79. 单词搜索**（[LeetCode](https://leetcode.cn/problems/word-search/)）
* **301. 删除无效的括号**（[LeetCode](https://leetcode.cn/problems/remove-invalid-parentheses/)）
* **694. 不同的岛屿数量**（[LeetCode](https://leetcode.cn/problems/number-of-distinct-islands/)）

---

---
url: /czxBlog/algorithm/divide-and-conquer/index.md
---
# 分治算法
## 概述

\==分治算法（Divide and Conquer）== , 字面上的解释是「分而治之」。
把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

**核心流程包含三步**：

* **分解（Divide）**：将原问题拆分为独立子问题
* **解决（Conquer）**：递归求解子问题
* **合并（Combine）**：将子问题的解合并为原问题的解

## 算法特征

* 该问题的规模缩小到一定的程度就可以容易地解决。
* 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。
* 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

::: warning
如果各子问题是不独立的，则分治法要重复地解公共的子问题，也就做了许多不必要的工作。
此时虽然也可用分治法，但一般用 ==动态规划== 较好。
:::

## 过程

以归并排序为例。

假设实现归并排序的函数名为 `mergeSort`。明确该函数的职责，即 **对传入的一个数组排序**。
这个问题显然可以分解。给一个数组排序等于给该数组的左右两半分别排序，然后合并成一个数组。

```ts
function mergeSort(一个数组) {
  if (可以很容易处理)
    return
  mergeSort(左半个数组)
  mergeSort(右半个数组)
  merge(左半个数组, 右半个数组)
}
```

传给它半个数组，那么处理完后这半个数组就已经被排好了。
注意到，`mergeSort` 与二叉树的后序遍历模板极其相似。
因为分治算法的套路是 **分解 -> 解决（触底）-> 合并（回溯）**，先左右分解，再处理合并，回溯就是在退栈，即相当于后序遍历。

`merge` 函数的实现方式与两个有序链表的合并一致。

## 分治示例

### 归并排序（经典分治）

* **时间复杂度**：$O(n log n)$
* **空间复杂度**：$O(n)$

```ts
function mergeSort(arr: number[]): number[] {
  if (arr.length <= 1)
    return arr // 终止条件

  // 分解阶段
  const mid = Math.floor(arr.length / 2)
  const left = mergeSort(arr.slice(0, mid))
  const right = mergeSort(arr.slice(mid))

  // 合并阶段
  return merge(left, right)
}

function merge(left: number[], right: number[]): number[] {
  let result: number[] = []
  let i = 0
  let j = 0

  // 合并两个有序数组
  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      result.push(left[i++])
    }
    else {
      result.push(right[j++])
    }
  }

  // 处理剩余元素
  return result.concat(left.slice(i)).concat(right.slice(j))
}

// 测试
const arr = [38, 27, 43, 3, 9, 82, 10]
console.log(mergeSort(arr)) // [3, 9, 10, 27, 38, 43, 82]
```

## 分治算法优化技巧

* **避免重复计算**：使用记忆化存储中间结果
* **尾递归优化**：减少递归栈深度
* **迭代替代递归**：降低空间复杂度
* **并行计算**：子问题独立时可并行处理

## 适用场景

* 问题可分解为独立子问题（归并排序、快速排序）
* 子问题结构相似（二叉树遍历）
* 合并操作复杂度低于暴力求解（矩阵乘法）
* 问题具有递归特性（汉诺塔、斐波那契数列）

## 相关问题

[**LeetCode** - 分治](https://leetcode.cn/tag/divide-and-conquer/){.read-more}

### 基础分治应用

* **169. 多数元素**（[LeetCode](https://leetcode.cn/problems/majority-element/)）
* **50. Pow(x, n)**（[LeetCode](https://leetcode.cn/problems/powx-n/)）

### 子问题合并技巧

* **53. 最大子序和**（[LeetCode](https://leetcode.cn/problems/maximum-subarray/)）
* **493. 翻转对**（[LeetCode](https://leetcode.cn/problems/reverse-pairs/)）

### 分治优化：三路划分

* **215. 数组中的第K个最大元素**（[LeetCode](https://leetcode.cn/problems/kth-largest-element-in-an-array/)）
* **75. 颜色分类**（[LeetCode](https://leetcode.cn/problems/sort-colors/)）

### 进阶问题

* **4. 寻找两个有序数组的中位数**（[LeetCode](https://leetcode.cn/problems/median-of-two-sorted-arrays/)）

---

---
url: /czxBlog/algorithm/dynamic-programming/index.md
---
# 动态规划
::: important **动态规划** 学习需要长时间的练习和强化，此篇目前仅处于 ==草稿=={.warning} 状态，在未来会引入更多的 DP 问题进行更为深入的学习。
:::

## 概述

\==动态规划（Dynamic Programming== 一种 **通过将复杂问题分解为重叠子问题，并存储子问题解以避免重复计算的优化技术**。

它适用于具有 **最优子结构** 和 **重叠子问题** 特性的问题。

## 动态规划原理

能用动态规划解决的问题，需要满足三个条件：**最优子结构** ，**无后效性** 和 **子问题重叠** 。

### 最优子结构

具有最优子结构也可能是适合用贪心的方法求解。

注意要确保我们考察了最优解中用到的所有子问题。

1. 证明问题最优解的第一个组成部分是做出一个选择；
2. 对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；
3. 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；
4. 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。

要保持子问题空间尽量简单，只在必要时扩展。

最优子结构的不同体现在两个方面：

1. 原问题的最优解中涉及多少个子问题；
2. 确定最优解使用哪些子问题时，需要考察多少种选择。

子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。

### 无后效性

已经求解的子问题，不会再受到后续决策的影响。

### 子问题重叠

如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。

### 基本思路

对于一个能用动态规划解决的问题，一般采用如下思路解决：

1. 将原问题划分为若干 **阶段**，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 **状态**）；
2. 寻找每一个状态的可能 **决策**，或者说是各状态间的相互转移方式（用数学的语言描述就是 **状态转移方程**）。
3. 按顺序求解每一个阶段的问题。

## 示例

### 斐波那契数列（基础入门）

```ts
// 自底向上（迭代）
function fib(n: number): number {
  if (n < 2)
    return n
  const dp: number[] = [0, 1]
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
}

// 空间优化（滚动数组）
function fibOpt(n: number): number {
  if (n < 2)
    return n
  let prev = 0
  let curr = 1
  for (let i = 2; i <= n; i++) {
    [prev, curr] = [curr, prev + curr]
  }
  return curr
}
```

### 背包问题（0-1 Knapsack）

:::info 有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w\_{i}$ 和价值 $v\_{i}$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。
:::

```ts
function knapSack(
  capacity: number, // 背包的最大容量
  weights: number[], // 每个物品的重量
  values: number[], // 每个物品的价值
  n: number // 物品个数
): number {
  // dp[i][w] 表示前i个物品在容量w时的最大价值
  const dp: number[][] = Array.from({ length: n + 1 })
    .fill(0)
    .map(() => Array.from({ length: capacity + 1 }).fill(0))

  for (let i = 1; i <= n; i++) {
    for (let w = 1; w <= capacity; w++) {
      if (weights[i - 1] <= w) {
        dp[i][w] = Math.max(
          values[i - 1] + dp[i - 1][w - weights[i - 1]],
          dp[i - 1][w]
        )
      }
      else {
        dp[i][w] = dp[i - 1][w]
      }
    }
  }
  return dp[n][capacity]
}

// 使用示例
const values = [60, 100, 120]
const weights = [10, 20, 30]
const capacity = 50
console.log(knapSack(capacity, weights, values, values.length)) // 220
```

### 最长公共子序列（LCS）

:::info 给定一个长度为 $n$ 的序列 $A$ 和一个 长度为 $m$ 的序列 $B \text{（}n,m \leq 5000\text{）}$，求出一个最长的序列，使得该序列既是 $A$ 的子序列，也是 $B$ 的子序列。
:::

```ts
function lcs(text1: string, text2: string): number {
  const m = text1.length
  const n = text2.length
  // dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的 LCS 长度
  const dp: number[][] = Array.from({ length: m + 1 })
    .fill(0)
    .map(() => Array.from({ length: n + 1 }).fill(0))

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1
      }
      else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
      }
    }
  }
  return dp[m][n]
}
```

## 记忆化搜索

\==记忆化搜索== 是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。

因为记忆化搜索确保了每个状态只访问一次，它也是一种常见的动态规划实现方式。

```ts
const memo: number[] = []
function fib(n: number): number {
  if (n < 2)
    return n
  if (memo[n] !== undefined)
    return memo[n]
  memo[n] = fib(n - 1) + fib(n - 2)
  return memo[n]
}
```

## 相关问题

[**LeetCode** - 动态规划](https://leetcode.cn/problem-list/dynamic-programming/){.read-more}

### 基础

* **70. 爬楼梯**（[LeetCode](https://leetcode.cn/problems/climbing-stairs/)）
* **509. 斐波那契数列**（[LeetCode](https://leetcode.cn/problems/fibonacci-number/)）
* **LCR 127. 跳跃训练**（[LeetCode](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof)）
* **118. 杨辉三角**（[LeetCode](https://leetcode.cn/problems/pascals-triangle/)）
* **198. 打家劫舍**（[LeetCode](https://leetcode.cn/problems/house-robber/)）
* **53. 最大子序和**（[LeetCode](https://leetcode.cn/problems/maximum-subarray/)）

### 二维DP (路径、序列)

* **62. 不同路径**（[LeetCode](https://leetcode.cn/problems/unique-paths/)）
* **63. 不同路径 II**（[LeetCode](https://leetcode.cn/problems/unique-paths-ii/)）
* **64. 最小路径和**（[LeetCode](https://leetcode.cn/problems/minimum-path-sum/)）
* **1143. 最长公共子序列**（[LeetCode](https://leetcode.cn/problems/longest-common-subsequence/)）
* **72. 编辑距离**（[LeetCode](https://leetcode.cn/problems/edit-distance/)）
* **5. 最长回文子串**（[LeetCode](https://leetcode.cn/problems/longest-palindromic-substring/)）
* **300. 最长递增子序列**（[LeetCode](https://leetcode.cn/problems/longest-increasing-subsequence/)）

### 背包问题 (组合优化)

* **416. 分割等和子集**（[LeetCode](https://leetcode.cn/problems/partition-equal-subset-sum/)）
* **322. 零钱兑换**（[LeetCode](https://leetcode.cn/problems/coin-change/)）
* **518. 零钱兑换 II**（[LeetCode](https://leetcode.cn/problems/coin-change-2/)）
* **139. 单词拆分**（[LeetCode](https://leetcode.cn/problems/word-break/)）

### 状态机DP (复杂状态转移)

* **121. 买卖股票的最佳时机**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)）
* **122. 买卖股票的最佳时机 II**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)）
* **123. 买卖股票的最佳时机 III**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)）
* **188. 买卖股票的最佳时机 IV**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)）
* **309. 最佳买卖股票时机含冷冻期**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)）
* **714. 最佳买卖股票时机含手续费**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)）

### 其他经典问题

* **322. 零钱兑换**（[LeetCode](https://leetcode.cn/problems/coin-change/)）
* **96. 不同的二叉搜索树**（[LeetCode](https://leetcode.cn/problems/unique-binary-search-trees/)）
* **211. 添加与搜索单词**（[LeetCode](https://leetcode.cn/problems/add-and-search-word-data-structure-design/)）
* **337. 打家劫舍 III**（[LeetCode](https://leetcode.cn/problems/house-robber-iii/)）

---

---
url: /czxBlog/algorithm/greedy/index.md
---
# 贪心算法
## 概述

\==贪心算法（Greedy Algorithm）== 是用计算机来模拟一个 **贪心** 的人做出决策的过程。
这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。

可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。

### 适用范围

贪心算法在 **有最优子结构的问题** 中尤为有效。

最优子结构的意思是 **问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解** 。

### 证明

贪心算法有两种证明方法：反证法和归纳法。一般情况下，一道题只会用到其中的一种方法来证明。

* **反证法**：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。
* **归纳法**：先算得出边界情况（例如 $n = 1$ ）的最优解 $F\_{1}$，
  然后再证明：对于每个 $n$，$F\_{n+1}$ 都可以由 $F\_{n}$ 推导出结果。

## 核心特点

* **局部最优 → 全局最优**：通过局部最优决策的累积达到全局最优
* **不可回溯**：一旦做出选择不再改变
* **高效性**：通常时间复杂度较低
* **不保证全局最优**：仅适用于特定问题类型

## 设计步骤

* **建立数学模型**：明确优化目标
* **分解子问题**：将问题分解为多个决策阶段
* **制定贪心策略**：确定局部最优的选择标准
* **证明正确性**：验证问题具有贪心选择性质
* **实现算法**：编写高效代码实现

## 示例

### 找零问题

用最少硬币数凑出指定金额（假设硬币无限供应）

```ts
function minCoins(coins: number[], amount: number): number {
  coins.sort((a, b) => b - a) // 降序排列
  let count = 0
  let remaining = amount

  for (const coin of coins) {
    while (remaining >= coin) {
      remaining -= coin
      count++
    }
    if (remaining === 0)
      break
  }

  return remaining === 0 ? count : -1
}

// 测试
const coins = [1, 2, 5, 10, 20]
console.log(minCoins(coins, 36)) // 输出：3 (20+10+5+1)
```

### 活动选择问题

在竞争活动中选择最大兼容活动子集

```ts
interface Activity {
  start: number
  end: number
}

function selectActivities(activities: Activity[]): Activity[] {
  activities.sort((a, b) => a.end - b.end) // 按结束时间排序

  const selected: Activity[] = [activities[0]]
  let lastEnd = activities[0].end

  for (let i = 1; i < activities.length; i++) {
    if (activities[i].start >= lastEnd) {
      selected.push(activities[i])
      lastEnd = activities[i].end
    }
  }

  return selected
}

// 测试
const activities: Activity[] = [
  { start: 1, end: 4 },
  { start: 3, end: 5 },
  { start: 0, end: 6 },
  { start: 5, end: 7 },
  { start: 8, end: 9 }
]

console.log(selectActivities(activities))
// 输出：[ {start:1, end:4}, {start:5, end:7}, {start:8, end:9} ]
```

## 局限性

* **非全局最优**：如0-1背包问题无法使用贪心
* **证明困难**：需要严格数学证明正确性
* **策略敏感**：排序方式直接影响结果

## 区别

### 与动态规划的区别

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。

动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

## 相关问题

[**LeetCode** - 贪心算法](https://leetcode.cn/problem-list/greedy/){.read-more}

### 基础（掌握贪心选择策略）

* **455. 分发饼干**（[LeetCode](https://leetcode.cn/problems/assign-cookies/)）
* **860. 柠檬水找零**（[LeetCode](https://leetcode.cn/problems/lemonade-change/)）
* **122. 买卖股票的最佳时机 II**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)）

### 进阶（区间处理与路径选择）

* **435. 无重叠区间**（[LeetCode](https://leetcode.cn/problems/non-overlapping-intervals/)）
* **452. 用最少数量的箭引爆气球**（[LeetCode](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)）
* **55. 跳跃游戏**（[LeetCode](https://leetcode.cn/problems/jump-game/)）
* **45. 跳跃游戏 II**（[LeetCode](https://leetcode.cn/problems/jump-game-ii/)）

### 挑战 （多维度贪心策略）

* **135. 分发糖果**（[LeetCode](https://leetcode.cn/problems/candy/)）
* **406. 根据身高重建队列**（[LeetCode](https://leetcode.cn/problems/queue-reconstruction-by-height/)）
* **765. 情侣牵手**（[LeetCode](https://leetcode.cn/problems/couples-holding-hands/)）

---

---
url: /czxBlog/algorithm/heap-sort/index.md
---
# 堆排序
## 概述

\==堆排序（Heap Sort）== 是一种基于 **二叉堆** 数据结构的高效排序算法。

## 核心思想

* **构建最大堆（Max-Heap）**：将无序数组转换为满足堆性质的结构（父节点 ≥ 子节点）。
* **反复提取最大值**：将堆顶（最大值）与末尾元素交换，缩小堆范围，重新调整堆。
* **重复调整**：直到堆大小为1，数组即有序。

## 时间复杂度

堆排序的最优时间复杂度、平均时间复杂度、最坏时间复杂度均为 $O(n\log n)$。

## 空间复杂度

由于可以在输入数组上建立堆，所以这是一个原地算法。

## 稳定性

同选择排序一样，由于其中交换位置的操作，所以是不稳定的排序算法。

## 实现

```ts
function heapSort(arr: number[]): number[] {
  const n = arr.length

  // 构建最大堆（从最后一个非叶子节点开始）
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i)
  }

  // 逐个提取最大值并调整堆
  for (let i = n - 1; i > 0; i--) {
    // 交换堆顶（最大值）与当前末尾元素
    [arr[0], arr[i]] = [arr[i], arr[0]]
    // 调整剩余元素为最大堆
    heapify(arr, i, 0)
  }
  return arr
}

// 堆调整函数（确保以i为根的子树满足最大堆性质）
function heapify(arr: number[], heapSize: number, i: number): void {
  let largest = i // 初始化最大元素为根节点
  const left = 2 * i + 1 // 左子节点索引
  const right = 2 * i + 2 // 右子节点索引

  // 若左子节点大于根，更新最大值索引
  if (left < heapSize && arr[left] > arr[largest]) {
    largest = left
  }

  // 若右子节点大于当前最大值，更新最大值索引
  if (right < heapSize && arr[right] > arr[largest]) {
    largest = right
  }

  // 如果最大值不是根节点，则交换并递归调整
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]]
    heapify(arr, heapSize, largest) // 递归调整受影响子树
  }
}

// 测试示例
const array = [12, 11, 13, 5, 6, 7]
console.log('排序前:', array)
console.log('排序后:', heapSort(array))
```

### 执行示例（`[12, 11, 13, 5, 6, 7]`）

* `构建堆`：

  ```txt
  [13, 11, 12, 5, 6, 7]  // 初始堆
  ```

* **首轮交换**：13（堆顶）与 7（末尾）交换 → `[7, 11, 12, 5, 6, 13]`

  调整堆：`[12, 11, 7, 5, 6]` → 新堆顶 12

* **次轮交换**：12 与 6 交换 → `[6, 11, 7, 5, 12, 13]`

  调整堆：`[11, 6, 7, 5]` → 新堆顶 11

* **持续交换与调整**：直到堆大小为 1，得到有序数组。

---

---
url: /czxBlog/algorithm/insertion-sort/index.md
---
# 插入排序
## 概述

\==插入排序（Insertion sort）== 是一种简单直观的排序算法。

### 核心思想

将数组分为 **已排序区间** 和 **未排序区间** ，每次从未排序区间取出一个元素，
在已排序区间中找到合适的位置插入（类似整理扑克牌）。

## 时间复杂度

插入排序的最优时间复杂度为 $O(n)$，在数列几乎有序时效率很高。

插入排序的最坏时间复杂度和平均时间复杂度都为 $O(n^2)$。

## 空间复杂度

原地排序, $O(1)$ ，不需要额外空间。

## 稳定性

插入排序是一种稳定的排序算法

## 伪代码

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements.} \\
2 & \textbf{Output. } A\text{ will be sorted in nondecreasing order stably.} \\
3 & \textbf{Method. }  \\
4 & \textbf{for } i\gets 2\textbf{ to }n\\
5 & \qquad key\gets A\[i]\\
6 & \qquad j\gets i-1\\
7 & \qquad\textbf{while }j>0\textbf{ and }A\[j]>key\\
8 & \qquad\qquad A\[j + 1]\gets A\[j]\\
9 & \qquad\qquad j\gets j - 1\\
10 & \qquad A\[j + 1]\gets key
\end{array}
$$

## 实现

```ts
function insertionSort(arr: number[]): number[] {
  // 遍历未排序区间（从第二个元素开始）
  for (let i = 1; i < arr.length; i++) {
    const current = arr[i] // 当前待插入元素
    let j = i - 1 // 从已排序区末尾开始比较

    // 在已排序区间中寻找插入位置
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j] // 元素后移
      j--
    }

    arr[j + 1] = current // 插入到正确位置
  }
  return arr
}

// 测试示例
const testArr = [5, 2, 4, 6, 1, 3]
console.log(insertionSort([...testArr])) // 输出: [1, 2, 3, 4, 5, 6]
```

### 执行过程示例 (`[5, 2, 4, 6, 1, 3]`)

* 初始状态

  ```txt
  已排序区 [5] | 未排序区 [2, 4, 6, 1, 3]
  ```

* 第一轮（插入 $2$ ）：

  * 比较 $5 > 2$ → $5$ 后移
  * 插入 $2$ 到首位 → `[2, 5] | [4, 6, 1, 3]`

* 第二轮（插入 $4$ ）：

  * $5 > 4$ → $5$ 后移
  * $2 < 4$ → 插入到 $5$ 前 → `[2, 4, 5] | [6, 1, 3]`

* 第三轮（插入 $6$ ）：

  * $5 < 6$ → 直接插入末尾 → `[2, 4, 5, 6] | [1, 3]`

* 第四轮（插入 $1$ ）：

  * 依次与 $6/5/4/2$ 比较 → 全部后移
  * 插入到首位 → `[1, 2, 4, 5, 6] | [3]`

* 第五轮（插入 $3$ ）：

  * $6/5/4 > 3$ → 后移，$2 < 3$ → 插入 $4$ 前
  * 最终结果：`[1, 2, 3, 4, 5, 6]`

## 优化

二分查找优化

```ts
// 二分查找优化（查找插入位置）
function insertionSortOptimized(arr: number[]) {
  for (let i = 1; i < arr.length; i++) {
    const current = arr[i]
    const pos = binarySearch(arr, 0, i - 1, current)

    // 整体后移元素
    for (let j = i - 1; j >= pos; j--) {
      arr[j + 1] = arr[j]
    }
    arr[pos] = current
  }
  return arr
}
```

二分插入排序：将比较操作优化至 $O(log n)$，但移动操作仍为 $O(n²)$

---

---
url: /czxBlog/algorithm/intro/index.md
---
# 概述
::: info 这篇笔记将介绍数据结构与算法的基础知识,包括数据结构的概念、算法的概念,以及常见的数据结构和算法的实现。
:::

## 数据结构

数据结构是在计算机中存储、组织数据的方式。小到变量、数组，大到线段树、平衡树，都是数据结构。

程序运行离不开数据结构，不同的数据结构又各有优劣，能够处理的问题各不相同，而根据具体问题选取合适的数据结构，
可以大大提升程序的效率。

## 算法

算法，顾名思义，即计算的方法。

算法通常用于解决特定的计算任务，但与可以直接在计算机上运行的程序不同，
算法使用数学化的描述，更加侧重于思想，可以被看作抽象的程序。

## 为什么学习数据结构和算法？

数据结构和算法是计算机科学中的基础，学习这些知识可以帮助我们理解计算机科学的基本原理，更好地解决实际问题。

> 设计出数据结构， 在施加以算法就行了。

---

---
url: /czxBlog/algorithm/merge-sort/index.md
---
# 归并排序
## 概述

\==归并排序（merge sort）== 是高效的基于比较的稳定排序算法

### 核心思想

**将数组递归拆分为最小单元，再逐步合并有序子序列。**

## 基本原理

### 分解（Divide）

将长度为 n 的数组递归地拆分为两个长度为 n/2 的子数组，直到子数组长度为 1（天然有序）。

### 合并（Merge）

归并排序最核心的部分是合并（merge）过程：将两个有序的数组 `a[i]` 和 `b[j]` 合并为一个有序数组 `c[k]`。

从左往右枚举 `a[i]` 和 `b[j]`，找出最小的值并放入数组 `c[k]`；重复上述过程直到 `a[i]` 和 `b[j]` 有一个为空时，将另一个数组剩下的元素放入 `c[k]`。

为保证排序的稳定性，前段首元素小于或等于后段首元素时（`a[i] <= b[j]`）而非小于时（`a[i] < b[j]`）就要作为最小值放入 `c[k]`。

## 时间复杂度

归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 $O(n \log n)$，空间复杂度为 $O(n)$。

## 空间复杂度

归并排序可以只使用 $O(1)$ 的辅助空间，但为便捷通常使用与原数组等长的辅助数组 $O(n)$。

## 稳定性

归并排序是 稳定的。（合并时左子数组元素优先保证相等元素的原始顺序）

## 实现

```ts
/**
 * 合并两个有序数组
 * @param left 左有序数组
 * @param right 右有序数组
 * @returns 合并后的有序数组
 */
function merge(left: number[], right: number[]): number[] {
  const result: number[] = []
  let leftIndex = 0
  let rightIndex = 0

  // 双指针遍历比较元素
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex])
      leftIndex++
    }
    else {
      result.push(right[rightIndex])
      rightIndex++
    }
  }

  // 处理剩余元素（左或右数组有剩余）
  return result.concat(left.slice(leftIndex), right.slice(rightIndex))
}

/**
 * 归并排序主函数
 * @param arr 待排序数组
 * @returns 排序后的数组
 */
function mergeSort(arr: number[]): number[] {
  // 递归终止条件：数组长度为1时天然有序
  if (arr.length <= 1)
    return arr

  // 分解数组
  const mid = Math.floor(arr.length / 2)
  const left = arr.slice(0, mid) // 左子数组
  const right = arr.slice(mid) // 右子数组

  // 递归分解 + 合并有序子数组
  return merge(mergeSort(left), mergeSort(right))
}

// 测试示例
const array = [38, 27, 43, 3, 9, 82, 10]
console.log('排序前:', array)
console.log('排序后:', mergeSort(array))
// 输出: [3, 9, 10, 27, 38, 43, 82]
```

### 执行过程示例（`[38, 27, 43, 3]`）

```txt
分解过程：
  [38, 27, 43, 3]
    → [38, 27] 和 [43, 3]
      → [38] [27] | [43] [3]

合并过程：
  merge([38], [27]) → [27, 38]
  merge([43], [3])  → [3, 43]
  merge([27, 38], [3, 43]) → [3, 27, 38, 43]
```

## 优化

### 小数组切换插入排序

当子数组长度较小时（如 `< 15`），插入排序的常数因子更优：

```ts
if (arr.length <= 15)
  return insertionSort(arr)
```

### 避免重复分配内存

预分配一个全局临时数组，减少递归中多次创建数组的开销。

### 有序性检测优化

若 `left` 的最大值 `<= right` 的最小值，可直接拼接数组：

```ts
if (left[left.length - 1] <= right[0]) {
  return left.concat(right)
}
```

---

---
url: /czxBlog/algorithm/overview/index.md
---
# 介绍
## 概述

\==算法== ，顾名思义，即计算的方法。

算法通常用于解决特定的计算任务，但与可以直接在计算机上运行的程序不同，算法使用数学化的描述，更加侧重于思想，可以被看作抽象的程序。
同一个算法可以有许多种不同的实现方式，两个不同的程序里也可能使用了同一种算法。

## 复杂度

\==时间复杂度== 和 ==空间复杂度== 是衡量一个算法效率的重要标准。

### 基本操作数

同一个算法在不同的计算机上运行的速度会有一定的差别，并且实际运行速度难以在理论上进行计算，
实际去测量又比较麻烦，所以我们通常考虑的不是算法运行的实际用时，而是算法运行所需要进行的基本操作的数量。

::: note 在普通的计算机上，加减乘除、访问变量（基本数据类型的变量，下同）、给变量赋值等都可以看作基本操作。
:::

对基本操作的计数或是估测可以作为评判算法用时的指标。

### 时间复杂度

衡量一个算法的快慢，一定要考虑数据规模的大小。
所谓数据规模，一般指输入的数字个数、输入中给出的图的点数与边数等等。一般来说，数据规模越大，算法的用时就越长。

我们衡量一个算法的效率时，最重要的不是看它在某个数据规模下的用时，
而是 ==看它的用时随数据规模而增长的趋势==，即 **时间复杂度**。

当然，算法的运行用时并非完全由输入规模决定，而是也与输入的内容相关。所以，时间复杂度又分为几种，例如：

* **最坏时间复杂度**，即每个输入规模下用时最长的输入对应的时间复杂度。在算法竞赛中，由于输入可以在给定的数据范围内任意给定，我们为保证算法能够通过某个数据范围内的任何数据，一般考虑最坏时间复杂度。
* **平均（期望）时间复杂度**，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入下期望用时的复杂度）。

### 空间复杂度

类似地，算法 ==所使用的空间随输入规模变化的趋势== 可以用 **空间复杂度** 来衡量。

---

---
url: /czxBlog/algorithm/quick-sort/index.md
---
# 快速排序
## 概述

\==快速排序（Quick sort）==，又称为 分区交换排序（partition-exchange sort），简称 **快排**，是一种被广泛运用的排序算法。

### 核心思想是

**选择一个基准值，将数组分成两个子数组（小于基准值和大于基准值），然后递归排序子数组。**

## 基本原理

快速排序的工作原理是通过 ==分治== 的方式来将一个数组排序。

快速排序分为三个过程：

* **选择基准值（Pivot）**：从数组中任选一个元素作为基准

* **分区（Partition）**：

  * 将小于基准的元素移到基准左侧
  * 将大于基准的元素移到基准右侧
  * 基准值此时位于最终排序位置

* **递归**：对左右子数组重复上述过程

和 **归并排序**不同，第一步并不是直接分成前后两个序列，而是在分的过程中要保证相对大小关系。
具体来说，第一步要是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。
为了保证平均时间复杂度，一般是随机选择一个数 $m$ 来当做两个子数列的分界。

之后，维护一前一后两个指针 $p$ 和 $q$，依次考虑当前的数是否放在了应该放的位置（前还是后）。
如果当前的数没放对，比如说如果后面的指针 $q$ 遇到了一个比 $m$ 小的数，那么可以交换 $p$ 和 $q$ 位置上的数，
再把 $p$ 向后移一位。当前的数的位置全放对后，再移动指针继续处理，直到两个指针相遇。

快速排序没有指定应如何具体实现第一步，不论是选择 $m$ 的过程还是划分的过程，都有不止一种实现方法。

第三步中的序列已经分别有序且第一个序列中的数都小于第二个数，所以直接拼接起来就好了。

## 时间复杂度

快速排序的最优时间复杂度和平均时间复杂度为 $O(n\log n)$，最坏时间复杂度为 $O(n^2)$。

对于最优情况，每一次选择的分界值都是序列的中位数，此时算法时间复杂度满足的递推式为 $T(n) = 2T(\dfrac{n}{2}) + \Theta(n)$，由主定理，$T(n) = \Theta(n\log n)$。

对于最坏情况，每一次选择的分界值都是序列的最值，此时算法时间复杂度满足的递推式为 $T(n) = T(n - 1) + \Theta(n)$，累加可得 $T(n) = \Theta(n^2)$。

对于平均情况，每一次选择的分界值可以看作是等概率随机的。

## 空间复杂度

$O(log n)$（递归栈空间）

## 稳定性

快速排序是一种不稳定的排序算法。

## 实现

```ts
function quickSort(arr: number[]): number[] {
  if (arr.length <= 1)
    return arr // 基线条件：数组为空或只有一个元素时直接返回

  // 选择基准值（此处取中间元素避免最坏情况）
  const pivotIndex = Math.floor(arr.length / 2)
  const pivot = arr[pivotIndex]

  // 创建左右分区
  const left: number[] = []
  const right: number[] = []

  // 分区操作（跳过基准元素）
  for (let i = 0; i < arr.length; i++) {
    if (i === pivotIndex)
      continue // 跳过基准值本身
    arr[i] < pivot ? left.push(arr[i]) : right.push(arr[i])
  }

  // 递归排序并合并结果
  return [...quickSort(left), pivot, ...quickSort(right)]
}

// 测试用例
const testArr = [3, 7, 2, 5, 1, 4, 9, 6]
console.log(quickSort(testArr)) // 输出: [1, 2, 3, 4, 5, 6, 7, 9]
```

## 优化

### 避免最坏情况

* 三数取中法（选首、尾、中的中位数）

  通过 **三数取中（即选取第一个、最后一个以及中间的元素中的中位数）** 的方法来选择两个子序列的分界元素（即比较基准）。这样可以避免极端数据（如升序序列或降序序列）带来的退化；

  ```ts
  // 三数取中法选择基准
  const mid = Math.floor((low + high) / 2)
  if (arr[low] > arr[high])
    [arr[low], arr[high]] = [arr[high], arr[low]]
  if (arr[mid] > arr[high])
    [arr[mid], arr[high]] = [arr[high], arr[mid]]
  if (arr[low] < arr[mid])
    [arr[low], arr[mid]] = [arr[mid], arr[low]]
  return arr[low] // 此时arr[low]是三者的中位数
  ```

---

---
url: /czxBlog/algorithm/recursion/index.md
---
# 递归
## 概述

\==递归== ，在数学和计算机科学中是指在函数的定义中使用函数自身的方法，
在计算机科学中还额外指一种 **通过重复将问题分解为同类的子问题而解决问题的方法**。

递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。
求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。

## 如何理解递归？

请看下面的例子：

* 点击：递归

* 在 google 中 搜索 **递归** 时，会得到如下结果：

  ![递归](/images/algorithm/recursion-1.png)

* 给一堆数字排序？分成两半，先排左半边再排右半边，最后进行合并。而怎么排左边和右边，重新阅读这句话。

## 递归的要素

* **基线条件（Base Case）**

  递归终止的条件，防止无限递归（栈溢出）。

* **递归条件（Recursive Case）**

  将问题分解为更小的子问题，并调用自身。

* **递归方向（Progress）**

  每次递归必须向基线条件靠近。

## 递归示例

### 阶乘计算

```ts
function factorial(n: number): number {
  // 基线条件：0! = 1, 1! = 1
  if (n <= 1) return 1; 
  
  // 递归条件：n! = n * (n-1)!
  return n * factorial(n - 1); 
}

console.log(factorial(5)); // 120
```

### 斐波那契数列

```ts
function fibonacci(n: number): number {
  // 基线条件
  if (n === 0) return 0;
  if (n === 1) return 1;
  
  // 递归条件：F(n) = F(n-1) + F(n-2)
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(6)); // 8
```

## 递归的优化策略

### 记忆化（Memoization）

缓存计算结果，避免重复递归（适合有重叠子问题的情况）。

```ts
const memo = new Map<number, number>();

function fibonacciMemo(n: number): number {
  if (n <= 1) return n;
  
  // 检查缓存
  if (memo.has(n)) return memo.get(n)!;
  
  // 计算并缓存结果
  const result = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
  memo.set(n, result);
  return result;
}
```

### 尾递归优化（Tail Recursion）

将递归操作置于函数末尾，编译器可优化为迭代（TypeScript 需手动转换）。

```ts
// 阶乘的尾递归实现
function factorialTail(n: number, acc: number = 1): number {
  return n <= 1 ? acc : factorialTail(n - 1, n * acc);
}
```

## 递归的典型应用场景

* **分治算法**

  如归并排序、快速排序。

* **树/图遍历**

  如深度优先搜索（DFS）。

* **回溯算法**

  如八皇后问题、迷宫求解。

* **动态规划**

  通常基于递归定义状态转移方程。

## 递归的优缺点

| 优点                       | 缺点                     |
| -------------------------- | ------------------------ |
| 代码简洁直观，贴近数学定义 | 栈溢出风险（深度过大）   |
| 简化复杂问题的实现         | 重复计算（需记忆化优化） |
| 天然适合处理嵌套结构       | 函数调用开销比循环大     |

## 写递归的要点

* **明确基线条件**：确保递归最终会终止。
* **信任递归**：假设子问题已解决，聚焦当前逻辑。
* **缩小问题规模**：每次递归必须更接近基线条件。
* **避免重复计算**：对重叠子问题使用记忆化。

:::important 明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔。
:::

## 递归与分治的区别

递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想。

## 相关问题

[**LeetCode - 递归**](https://leetcode.cn/tag/recursion/){.read-more}

### 基础递归问题

* **509. 斐波那契数**（[LeetCode](https://leetcode.cn/problems/fibonacci-number/)）
* **70. 爬楼梯**（[LeetCode](https://leetcode.cn/problems/climbing-stairs/)）
* **50. Pow(x, n)**（[LeetCode](https://leetcode.cn/problems/powx-n/)）

### 链表与树结构递归

* **206. 反转链表**（[LeetCode](https://leetcode.cn/problems/reverse-linked-list/)）
* **112. 路径总和**（[LeetCode](https://leetcode.cn/problems/path-sum/)）
* **236. 二叉树的最近公共祖先**（[LeetCode](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)）
* **230. 二叉搜索树中第K小的元素**（[LeetCode](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)）

### 分治与回溯问题

* **169. 多数元素**（[LeetCode](https://leetcode.cn/problems/majority-element/)）
* **22. 括号生成**（[LeetCode](https://leetcode.cn/problems/generate-parentheses/)）
* **46. 全排列**（[LeetCode](https://leetcode.cn/problems/permutations/)）

---

---
url: /czxBlog/algorithm/selection-sort/index.md
---
# 选择排序
## 概述

\==选择排序（Selection sort）== 是一种简单直观的排序算法。

### 核心思想

**每次从未排序部分中选择最小（或最大）元素，将其与未排序部分的起始位置交换。** 重复此过程直到所有元素有序。

## 算法步骤

1. 将数组分为 已排序区（左侧）和 未排序区（右侧）
2. 初始状态：已排序区为空，未排序区为整个数组
3. 遍历未排序区，找到最小元素的索引
4. 将最小元素与未排序区的第一个元素交换
5. 将已排序区向右扩展一位
6. 重复步骤 3-5 直到未排序区为空

## 时间复杂度

选择排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为 $O(n^2)$。

## 空间复杂度

$O(1)$（原地排序，不需要额外空间）

## 稳定性

**不稳定排序**（交换操作可能改变相等元素的原始顺序）

## 伪代码

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements.} \\
2 & \textbf{Output. } A\text{ will be sorted in nondecreasing order.} \\
3 & \textbf{Method. }  \\
4 & \textbf{for } i\gets 1\textbf{ to }n-1\\
5 & \qquad ith\gets i\\
6 & \qquad \textbf{for }j\gets i+1\textbf{ to }n\\
7 & \qquad\qquad\textbf{if }A\[j]\<A\[ith]\\
8 & \qquad\qquad\qquad ith\gets j\\
9 & \qquad \text{swap }A\[i]\text{ and }A\[ith]\\
\end{array}
$$

## 实现

```ts
function selectionSort(arr: number[]): number[] {
  const len = arr.length

  for (let i = 0; i < len - 1; i++) {
    // 1. 在未排序区寻找最小值索引
    let minIndex = i
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j // 更新最小元素索引
      }
    }

    // 2. 将最小值交换到未排序区起始位置
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]] // ES6解构赋值交换
    }
    // 此时 arr[0...i] 成为新的已排序区
  }
  return arr
}

// 测试示例
const testArray = [64, 25, 12, 22, 11]
console.log('排序前:', testArray)
console.log('排序后:', selectionSort(testArray))
```

### 执行过程示例（数组 \[64, 25, 12, 22, 11]）

| 轮次 | 已排序区          | 未排序区          | 最小值 | 交换后数组        |
| ---- | ----------------- | ----------------- | ------ | ----------------- |
| 初始 | \[]                | \[64,25,12,22,11] | -      | \[64,25,12,22,11] |
| 1    | \[11]             | \[25,12,22,64]    | 11     | \[11,25,12,22,64] |
| 2    | \[11,12]          | \[25,22,64]       | 12     | \[11,12,25,22,64] |
| 3    | \[11,12,22]       | \[25,64]          | 22     | \[11,12,22,25,64] |
| 4    | \[11,12,22,25]    | \[64]             | 25     | \[11,12,22,25,64] |
| 结果 | \[11,12,22,25,64] | \[]                | -      | 排序完成          |

## 优点

* **简单易实现**：逻辑清晰，代码量少
* **数据移动最少**：每轮只交换一次元素（ $O(n)$ 次交换）
* **适用场景**：小规模数据或内存受限环境
* **不足**：时间复杂度较高，不适合大规模数据

## 优化

### 双向选择排序

同时寻找最小值和最大值，减少迭代轮次

```ts
function bidirectionalSelectionSort(arr: number[]): number[] {
  let left = 0
  let right = arr.length - 1
  while (left < right) {
    let min = left
    let max = right
    for (let i = left; i <= right; i++) {
      if (arr[i] < arr[min])
        min = i
      if (arr[i] > arr[max])
        max = i
    }
    [arr[left], arr[min]] = [arr[min], arr[left]]
    // 修正最大值被交换的情况
    if (max === left)
      max = min;
    [arr[right], arr[max]] = [arr[max], arr[right]]
    left++
    right--
  }
  return arr
}
```

### 加入有序检查

提前终止已排序数组的遍历

---

---
url: /czxBlog/algorithm/shell-sort/index.md
---
# 希尔排序
## 概述

\==希尔排序（Shell sort）==，也称为缩小增量排序法，是 [插入排序](./3.插入排序.md) 的一种改进版本。
希尔排序以它的发明者 希尔（Donald Shell）命名。

### 核心思想

**让距离较远的元素先部分有序，减少后续插入排序的工作量。**

### 核心概念

* **增量序列 (Gap Sequence)**

  决定如何划分子序列。初始间隔较大，逐步缩小至 1（最后一次为标准的插入排序）。

  **常用序列**：希尔原始序列（N/2, N/4, ..., 1）、Hibbard 序列等。

* **子序列排序**

  对每个增量间隔形成的子序列独立进行插入排序。

* **逐步细化**

  随着增量减小，序列越来越有序，插入排序的效率显著提高。

## 过程

排序对不相邻的记录进行比较和移动：

1. 将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同）；
2. 对这些子序列进行插入排序；
3. 减小每个子序列中元素之间的间距，重复上述过程直至间距减少为 $1$。

## 时间复杂度

取决于增量序列：

* 平均：$O(n log n)$ ~ $O(n²)$
* 最佳：$O(n log n)$

## 空间复杂度

希尔排序的空间复杂度为 $O(1)$。

## 稳定性

希尔排序是一种不稳定的排序算法。

## 实现

### 基础实现（使用希尔原始序列）

```ts
function shellSort(arr: number[]): number[] {
  const n = arr.length
  // 初始增量 gap = n/2，逐步减半直至 1
  for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {
    // 从 gap 开始，对每个子序列执行插入排序
    for (let i = gap; i < n; i++) {
      const temp = arr[i] // 当前待插入元素
      let j = i
      // 在子序列中向前比较并移位
      while (j >= gap && arr[j - gap] > temp) {
        arr[j] = arr[j - gap] // 较大元素后移
        j -= gap
      }
      arr[j] = temp // 插入到正确位置
    }
  }
  return arr
}

// 测试
const arr = [64, 34, 25, 12, 22, 11, 90]
console.log('排序前:', arr)
console.log('排序后:', shellSort(arr))
```

### 优化实现（使用 Knuth 增量序列）

```ts
function shellSortOptimized(arr: number[]): number[] {
  const n = arr.length
  // 生成 Knuth 增量序列：1, 4, 13, 40, 121, ...
  let gap = 1
  while (gap < Math.floor(n / 3)) {
    gap = gap * 3 + 1 // 计算最大有效增量
  }

  while (gap > 0) {
    for (let i = gap; i < n; i++) {
      const temp = arr[i]
      let j = i
      while (j >= gap && arr[j - gap] > temp) {
        arr[j] = arr[j - gap]
        j -= gap
      }
      arr[j] = temp
    }
    gap = Math.floor((gap - 1) / 3) // 缩小增量
  }
  return arr
}
```

### 执行示例（`[8, 3, 5, 1, 4, 2]`）

* **初始 Gap = 3**

  * 子序列 1：`[8, 1]` → 排序后 `[1, 8]`
  * 子序列 2：`[3, 4]` → 排序后 `[3, 4]`
  * 子序列 3：`[5, 2]` → 排序后 `[2, 5]`
  * 新数组：`[1, 3, 2, 8, 4, 5]`

* **Gap = 1**（标准插入排序）

  * 逐步插入排序后得到 \[1, 2, 3, 4, 5, 8]

## 优点

比简单插入排序更快（减少元素移动次数），代码简洁，空间效率高。

## 缺点

时间复杂度依赖增量序列，不稳定。

---

---
url: /czxBlog/article/1w4onzn1/index.md
---
# 为你的站点开启HSTS
`HTTP-Strict-Transport-Security` 简称为 `HSTS`，是一个 HTTP 响应头。
用于通知浏览器应该只通过 HTTPS 访问该站点，并且以后使用 HTTP 访问该站点的所有尝试都应自动转换为 HTTPS。

## 中间人劫持

当用户在未知风险的网络环境中访问 某个网站的时候，如访问 `http://example.com`，在这个未知风险的网络环境中，
可能会被其他人拦截到用户发出的网络请求，然后跳转到一个一模一样的钓鱼网站，或者在请求内容中，注入有危害的代码、广告等，
这种攻击行为，被称为 **中间人劫持**。

当 `example.com` 也支持 `https` 协议进行访问后，如果用户直接通过 `https` 协议访问，那么在一定程度上可以有效防止
`中间人劫持`。

如果用户依然通过 `http` 协议访问，虽然服务器可以重定向到 `https` 请求，然而在这个过程中，中间人依然可以
通过拦截 `http` 请求，然后向服务器发起 `https` 请求获取内容，再注入新的内容 返回给用户。

用户在浏览器地址栏中 输入 `example.com`, 浏览器默认发起的是 `http` 请求，这导致了我们很难要求用户在通过域名访问
网站时，一定要输入 `https://example.com`。

为了限制 `中间人劫持` 这种潜在的攻击手段，一种处理方式就是 强制浏览器使用 `https` 协议访问网站。
为此，我们需要给网站开启 `HSTS`。

## HSTS

`HSTS` 通过声明 `HTTP` 头部字段 `HTTP-Strict-Transport-Security` 来启用和配置策略：

```
Strict-Transport-Security: max-age=<expire-time>
Strict-Transport-Security: max-age=<expire-time>; includeSubDomains
Strict-Transport-Security: max-age=<expire-time>; preload
```

### 指令

#### `max-age=<expire-time>`

设置在浏览器收到这个请求后的`<expire-time>`秒的时间内凡是访问这个域名下的请求都使用 HTTPS 请求。

#### `includeSubDomains` 可选

如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。

#### `preload` 可选

查看 [预加载 HSTS](https://www.chromium.org/hsts/) 获得详情。不是标准的一部分。

### 浏览器处理

> 当网站已开启 `HSTS`

用户在第一次通过 `https` 协议访问网站时，服务器响应`Strict-Transport-Security` 头，浏览器记录下信息，
在以后重新访问访问网站时，会把访问这个网站的 `http` 请求自动替换为 `https`。

当 `HSTS` 头设置的过期时间到了，后面通过 `HTTP` 的访问恢复到正常模式，不会再自动跳转到 `HTTPS。`

每次浏览器接收到 `Strict-Transport-Security` 头，它都会更新这个网站的过期时间，所以网站可以刷新这些信息，防止过期发生。

Chrome、Firefox 等浏览器里，当尝试访问该域名下的内容时，会产生一个 307 Internal Redirect（内部跳转），自动跳转到 HTTPS 请求。

## 预加载

如果用户首次访问网站时，依然使用的是 `http` 协议，浏览器会忽略`Strict-Transport-Security`，而且中间人依然可以劫持请求内容，删除 `Strict-Transport-Security`。

为了进一步处理这个问题， `Google`、`Firefox` 等浏览器厂商，维护了一个 `HSTS` 预加载服务。

你可以将你已开启了 `HSTS` 的 站点域名，提交到 预加载服务中，浏览器将会永不使用非安全的方式连接到你的域名。

但是，这不是 HSTS 标准的一部分，也不该被当作正式的内容。

[`HSTS`预加载服务](https://hstspreload.org/)

## 示例

当前域名，以及所有子域名，开启 `HSTS`, 过期时间为 一年。

```
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

---

---
url: /czxBlog/article/284xp17b/index.md
---
# tsconfig.json 完全使用指南
`TSConfig` 文件是用于表明其所在的目录是一个 `typescript` 或 `javascript` 项目的根目录。
`TSConfig` 文件可以是 `tsconfig.json` 或 `jsconfig.json`，它们的配置和行为相同。

> [官方文档](https://www.typescriptlang.org/tsconfig)

## 基础

使用 `TSConfig` 是一个很容易的事情，只需要在目录下创建一个 `tsconfig.json` 或 `jsconfig.json` 文件即可：

::: code-tabs
@tab tsconfig.json

```json
{}
```

@tab jsconfig.json

```json
{}
```

:::

`TSConfig` 包含了默认配置。

`TSConfig` 主要包含了以下 `top level` 的配置字段：

```json
{
  "extends": "",
  "compilerOptions": {},
  "files": [],
  "include": [],
  "exclude": [],
  "references": [],
  "watchOptions": {},
  "typeAcquisition": {}
}
```

## `extends`

**Type**： `string`

`extends` 属性用于从另一个 `TSConfig` 文件继承配置。它的值是一个路径， 或者是一个 `Node.js` 风格的路径。
如果是一个相对路径，则相对于配置文件对路径进行解析，如果是一个 `Node.js` 风格的路径，则从 `node_modules`解析获取路径。

`extends` 不会继承 配置文件中的 `files`, `include`, `exclude` 字段，同时，不允许配置文件之间循环引用。

### example

`tsconfig.base.json`

```json
{
  "compilerOptions": {
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

`tsconfig.json`

```json
{
  "extends": "./tsconfig.base",
  "files": ["main.ts"]
}
```

`tsconfig.noStrictNullChecks.json`

```json
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "strictNullChecks": false
  }
}
```

## `compilerOptions`

指定 `typescript` 的编译配置。

`compilerOptions` 主要包含以下配置内容：

**Type checking:**

[`allowUnreachableCode`](#allowunreachablecode), [`allowUnusedLabels`](#allowunusedlabels),
[`alwaysStrict`](#alwaysstrict), [`exactOptionalPropertyTypes`](#exactoptionalpropertytypes),
[`noFallthroughCasesInSwitch`](#nofallthroughcasesinswitch), [`noImplicitAny`](#noimplicitany),
[`noImplicitOverride`](#noimplicitoverride), [`noImplicitReturns`](#noimplicitreturns),
[`noImplicitThis`](#noimplicitthis),
[`noPropertyAccessFromIndexSignature`](#nopropertyaccessfromindexsignature),
[`noUncheckedIndexedAccess`](#nouncheckedindexedaccess),[`noUnusedLocals`](#nounusedlocals),
[`noUnusedParameters`](#nounusedparameters), [`strict`](#strict),
[`strictBindCallApply`](#strictbindcallapply), [`strictFunctionTypes`](#strictfunctiontypes),
[`strictNullChecks`](#strictfunctiontypes),
[`strictPropertyInitialization`](#strictpropertyinitialization),
[`useUnknownInCatchVariables`](#useunknownincatchvariables)

**Modules:**

[`allowUmdGlobalAccess`](#allowumdglobalaccess), [`baseUrl`](#baseurl), [`module`](#module),
[`moduleResolution`](#moduleresolution), [`moduleSuffixes`](#modulesuffixes), [`noResolve`](#noresolve),
[`paths`](#paths), [`resolveJsonModule`](#resolvejsonmodule), [`rootDir`](#rootdir),
[`rootDirs`](#rootdirs), [`typeRoots`](#typeroots), [`types`](#types)

**Emit:**

[`declaration`](#declaration), [`declarationDir`](#declarationdir), [`declarationMap`](#declarationmap),
[`downlevelIteration`](#downleveliteration), [`emitBOM`](#emitbom),
[`emitDeclarationOnly`](#emitdeclarationonly), [`importHelpers`](#importhelpers),
[`importsNotUsedAsValues`](#importsnotusedasvalues), [`inlineSourceMap`](#inlinesourcemap),
[`inlineSources`](#inlinesources), [`mapRoot`](#maproot), [`newLine`](#newline), [`noEmit`](#noemit),
[`noEmitHelpers`](#noemithelpers), [`noEmitOnError`](#noemitonerror), [`outDir`](#outdir),
[`outFile`](#outfile), [`preserveConstEnums`](#preserveconstenums),
[`preserveValueImports`](#preservevalueimports), [`removeComments`](#removecomments),
[`sourceMap`](#sourcemap), [`sourceRoot`](#sourceroot), [`stripInternal`](#stripinternal)

**JavaScript Support:**

[`allowJs`](#allowjs), [`checkJs`](#checkjs), [`maxNodeModuleJsDepth`](#maxnodemodulejsdepth)

**Editor Support:**

[`disableSizeLimit`](#disablesizelimit), [`plugins`](#plugins)

**Interop Constraints:**

[`allowSyntheticDefaultImports`](#allowsyntheticdefaultimports), [`esModuleInterop`](#esmoduleinterop),
[`forceConsistentCasingInFileNames`](#forceconsistentcasinginfilenames), [`isolatedModules`](#isolatedmodules), [`preserveSymlinks`](#preservesymlinks)

**Backwards Compatibility:**

[`charset`](#charset), [`keyofStringsOnly`](#keyofstringsonly),
[`noImplicitUseStrict`](#noimplicitusestrict), [`noStrictGenericChecks`](#nostrictgenericchecks),
[`out`](#out), [`suppressExcessPropertyErrors`](#suppressexcesspropertyerrors), [`suppressImplicitAnyIndexErrors`](#suppressimplicitanyindexerrors)

**Language and Environment:**

[`emitDecoratorMetadata`](#emitdecoratormetadata), [`experimentalDecorators`](#experimentaldecorators),
[`jsx`](#jsx), [`jsxFactory`](#jsxfactory), [`jsxFragmentFactory`](#jsxfragmentfactory),
[`jsxImportSource`](#jsximportsource), [`lib`](#lib), [`moduleDetection`](#moduledetection),
[`noLib`](#nolib),[`reactNamespace`](#reactnamespace),[`target`](#target),
[`useDefineForClassFields`](#usedefineforclassfields)

**Compiler Diagnostics:**

[`diagnostics`](#diagnostics), [`explainFiles`](#explainfiles),
[`extendedDiagnostics`](#extendeddiagnostics), [`generateCpuProfile`](#generatecpuprofile),
[`generateCpuProfile`](#generatecpuprofile), [`listFiles`](#listfiles),
[`traceResolution`](#traceresolution)

**Projects:**

[`composite`](#composite), [`disableReferencedProjectLoad`](#disablereferencedprojectload),
[`disableSolutionSearching`](#disablesolutionsearching),
[`disableSourceOfProjectReferenceRedirect`](#disablesourceofprojectreferenceredirect),
[`incremental`](#incremental), [`tsBuildInfoFile`](#tsbuildinfofile)

**Output Formatting:**

[`noErrorTruncation`](#noerrortruncation), [`preserveWatchOutput`](#preservewatchoutput), [`pretty`](#pretty)

**Completeness:**

[`skipDefaultLibCheck`](#skipdefaultlibcheck),[`skipLibCheck`](#skiplibcheck)

**watch options:**

[`assumeChangesOnlyAffectDirectDependencies`](#assumechangesonlyaffectdirectdependencies)

### allowUnreachableCode

是否允许代码中包含不会被执行的代码

* `undefined` default 向编辑器提供建议作为警告
* `true` 允许包含
* `false` 不允许，并给出错误警告

**example** `"allowUnreachableCode": false`

```ts
function fn(n: number) {
  if (n > 5) {
    return true
  }
  else {
    return false
  }
  return true
  // error: Unreachable code detected.
}
```

### allowUnusedLabels

是否允许 未被使用的 `labels`。

* `undefined` default 向编辑器提供建议作为警告
* `true` 允许包含
* `false` 不允许，并给出错误警告

**example:**

```ts
function verifyAge(age: number) {
  // Forgot 'return' statement
  if (age > 18) {
    verified: true
    // error: Unused label.
  }
}
```

### alwaysStrict

确保文件在ECMAScript严格模式下解析，并对每个源文件添加 `use strict`。

### exactOptionalPropertyTypes

如果启用 `exactOptionalPropertyTypes`，`typescript` 将会用更加严格的模式，对 通过 `type` 或者 `interface`
声明的包含 `?` 的可选属性的检查

**example:**

```ts
interface Theme {
  colorThemeOverride?: 'dark' | 'light'
}
```

如果没有启用这个配置，那么 `colorThemeOverride` 的值可以是 `'dark'`, `'light'`, `undefined`。
如果启用了这个配置，则值不能被显式的赋值为 `undefined`。

`"exactOptionalPropertyTypes": true`

```ts
const theme: Theme = {}

theme.colorThemeOverride = 'dark'
theme.colorThemeOverride = 'light'

theme.colorThemeOverride = undefined // error
```

### noFallthroughCasesInSwitch

如果配置为 `true`, 则表示 `switch` 语句中的 任何一个非空的 `case` 分支，都必须包含 `break` 或 `return` 。

### noImplicitAny

在没有类型注释的情况下，`typescript` 在无法推断类型时，会将类型回退到 `any`。这可能会导致一些错误被遗漏。

启用此配置，`typescript` 会在类型回退到 `any` 时报告一个错误。

```ts
function fn(s) {
  // Parameter 's' implicitly has an 'any' type.
  console.log(s.subtr(3))
}
```

### noImplicitOverride

### noImplicitReturns

### noImplicitThis

### noPropertyAccessFromIndexSignature

### noUncheckedIndexedAccess

### noUnusedLocals

### noUnusedParameters

### strict

是否启用 严格模式的类型检查，当开启这个选项时，也会启用所有 `strict` 系列的配置。

### strictBindCallApply

当开启时，`TypeScript` 会检查 `call`、`bind`和`apply`是否使用正确的参数调用底层函数。

### strictFunctionTypes

当开启时，`TypeScript` 会对 函数的参数类型使用更严格的检查。

需要注意的是，该配置只适用于 `function` 语法，而不适用于 `method` 语法。

```ts
function fn(x: string) {
  return x
}
type Fn = (ns: string | number) => string | number

const fn1: Fn = fn // error: Types of parameters 'x' and 'ns' are incompatible.
```

### strictNullChecks

当开启时，`typescript` 会把 `undefined` 和 `null` 作为不同的类型。

### strictPropertyInitialization

当启用时，`typescript` 会检查 在 `class` 中已声明的属性，是否有在 `constructor` 中进行初始化。

### useUnknownInCatchVariables

### allowUmdGlobalAccess

允许 Umd 全局访问。

当 `allowUmdGlobalAccess` 设置为 `true` 时，将允许你在模块文件中以全局变量的形式访问 UMD 的导出。 模块文件是具有或同时导入、导出的文件。当未设置这个选项时，使用 UMD 模块的导出需要首先导入声明。

比如，在一个 Web 项目中， 知道特定的库（如 jQuery 或 Lodash ）在运行时总是可用的，但无法通过导入来使用他们。

### baseUrl

设置解析非绝对路径模块名时的基准目录。

### module

设置程序的模块系统。

可选值包括： `CommonJS`， `UMD`，`AMD`， `System`，`ESNext`， `ES2020`， `ES6/ES2015`，`ES2022`， `Node16`， `NodeNext`， `None`

### moduleResolution

指定模块解析策略。

可选值包括： `node` ，`classic`。

如果未指定值，当 `module` 为 `CommonJS`时，为 `node`，当 `module` 为 `UMD`，`AMD`， `System`，`ESNext`，`ES2015`时，为 `classic` 。

### moduleSuffixes

声明在模块解析时，默认搜索的文件名后缀列表

```json
{
  "compilerOptions": {
    "moduleSuffixes": [".ios", ".native", ""]
  }
}
```

`import * as foo from "./foo";`， `typescript` 将会检索 `./foo.ios.ts`, `./foo.native.ts`, `./foo.ts`。

### noResolve

### paths

路径设置。将模块导入重新映射到相对于 baseUrl 路径的配置。

paths 可以允许你声明 TypeScript 应该如何解析你的 require/import。

```json
{
  "compilerOptions": {
    "baseUrl": ".", // this must be specified if "paths" is specified.
    "paths": {
      "jquery": ["node_modules/jquery/dist/jquery"]
    }
  }
}
```

告诉 TypeScript 文件解析器支持一些自定义的前缀来寻找代码。 这种模式可以避免在你的代码中出现过长的相对路径:

```json
{
  "compilerOptions": {
    "baseUrl": "src",
    "paths": {
      "app/*": ["app/*"],
      "config/*": ["app/_config/*"],
      "environment/*": ["environments/*"],
      "shared/*": ["app/_shared/*"],
      "helpers/*": ["helpers/*"],
      "tests/*": ["tests/*"]
    }
  }
}
```

### resolveJsonModule

允许直接导入 `.json` 模块。并基于json生成静态类型。

### rootDir

根目录。

**默认**: 所有输入的非声明文件中的最长公共路径。若 composite 被指定，则是包含 tsconfig.json 文件的目录。

### rootDirs

根目录。

通过 `rootDirs`，你可以告诉编译器有许多“虚拟”的目录作为一个根目录。
这将会允许编译器在这些“虚拟”目录中解析相对应的模块导入，就像它们被合并到同一目录中一样。

### typeRoots

默认情况下，所有 可见 的 `@types` 包都将包含在你的编译过程中。
在 `node_modules/@types` 中的任何包都被认为是 可见 的。
例如，这意味着包含 `./node_modules/@types/`，`../node_modules/@types/`，`../../node_modules/@types/` 中所有的包。

当 `typeRoots` 被指定，仅有 在 `typeRoots` 下的包会被包含。例如：

```json
{
  "compilerOptions": {
    "typeRoots": ["./typings", "./vendor/types"]
  }
}
```

这个配置文件将包含 `./typings` 和 `./vendor/types` 下的所有包，而不包括 `./node_modules/@types` 下的。其中所有的路径都是相对于 `tsconfig.json`。

### types

默认情况下，所有 可见 的 `@types` 包都将包含在你的编译过程中。
在 `node_modules/@types` 中的任何包都被认为是 可见 的。
例如，这意味着包含 `./node_modules/@types/`，`../node_modules/@types/`，`../../node_modules/@types/` 中所有的包。。

当 types 被指定，则只有列出的包才会被包含在全局范围内。例如：

```json
{
  "compilerOptions": {
    "types": ["node", "jest", "express"]
  }
}
```

这个 `tsconfig.json` 文件将 只会 包含 `./node_modules/@types/node`，`./node_modules/@types/jest`
和 `./node_modules/@types/express`。 其他在 `node_modules/@types/*` 下的包将不会被包含。

此选项不会影响 `@types/*` 如何被包含在你的代码中。

当你设置了这个选项，通过不在 types 数组中包含，它将：

* 不会再你的项目中添加全局声明（例如 node 中的 process 或 Jest 中的 expect）
* 导出不会出现再自动导入的建议中

### declaration

为你工程中的每个 `TypeScript` 或 `JavaScript` 文件生成 `.d.ts`文件。 这些 `.d.ts` 文件是描述模块外部 API 的类型定义文件。 可以通过 `.d.ts` 文件为非类型化的代码提供 `intellisense` 和精确的类型。

### declarationDir

配置 声明文件生成的输出目录。

### declarationMap

### downlevelIteration

`downlevel (降级）` 是 `TypeScript` 的术语，指用于转换到旧版本的 `JavaScript。` 这个选项是为了在旧版 `Javascript` 运行时上更准确的实现现代 `JavaScript` 迭代器的概念。

`ECMAScript 6` 增加了几个新的迭代器原语：`for / of` 循环（`for (el of arr)`），数组展开（`[a, ...b]`），参数展开（`fn(...args)`）和 `Symbol.iterator`。

如果 `Symbol.iterator` 存在的话，`--downlevelIteration` 将允许在 ES5 环境更准确的使用这些迭代原语。

### emitBOM

### emitDeclarationOnly

只生成 `.d.ts` 文件，但不生成 `.js` 文件

### importHelpers

### importsNotUsedAsValues

### inlineSourceMap

是否 内联 `sourceMap`

### inlineSources

### mapRoot

### newLine

指定输出文件时使用的行尾序列: `CRLF` (dos)或 `LF` (unix)。

### noEmit

禁止编译器生成文件，例如 `JavaScript` 代码，`source-map` 或声明。

这为另一个工具提供了空间，例如用 `Babel` 或 `swc` 来处理将 `TypeScript` 转换为可以在 `JavaScript` 环境中运行的文件的过程。

然后你可以使用 `TypeScript` 作为提供编辑器集成的工具，或用来对源码进行类型检查。

### noEmitHelpers

### noEmitOnError

如果报告了任何错误，不允许编译器输出文件，如JavaScript源代码、源映射或声明。
默认为false，这使得在类似监听的环境中使用TypeScript更容易，
在这种环境中，您可能希望在确保所有错误都得到解决之前，再在另一个环境中查看代码更改的结果。

### outDir

如果被指定，`.js` （以及 .d.ts, .js.map 等）将会被生成到这个目录下。
原始源文件的目录将会被保留，如果计算出的根目录不是你想要的，可以查看 [`rootDir`](#rootdir)。

如果没有指定，`.js` 将被生成至于生成它们的 `.ts` 文件相同的目录中。

### outFile

如果被指定，所有 全局 （非模块） 文件将被合并到指定的单个输出文件中。

如果 `module` 为 `system` 或 `amd`，所有模块文件也将在所有全局内容之后被合并到这个文件中。

注：除非 `module` 是 `None``，System` 或 `AMD`， 否则不能使用 `outFile`。 这个选项 不能 用来打包 `CommonJS` 或 `ES6` 模块。

### preserveConstEnums

### preserveValueImports

### removeComments

当转换为 `JavaScript` 时，忽略所有 TypeScript 文件中的注释。默认为 `false`。

### sourceMap

启用生成 `sourcemap files`。 这些文件允许调试器和其他工具在使用实际生成的 `JavaScript` 文件时，
显示原始的 `TypeScript` 代码。 Source map 文件以 `.js.map` （或 `.jsx.map`）文件的形式被生成到相应的 `.js` 文件输出旁。

`.js` 文件将会包含一个 `sourcemap` 注释，以向外部工具表明文件在哪里。

### sourceRoot

### stripInternal

### allowJs

允许 `JavaScript` 文件在你的工程中被引入，而不是仅仅允许 `.ts` 和 `.tsx` 文件。

这个选项是一种可以允许 `.ts` 和 `.tsx` 与现有的 `JavaScript` 文件共存的方式。可以用于逐步将 `TypeScript` 文件逐步添加到 JS 工程中。

### checkJs

与 `allowJs` 配合使用，当 `checkJs` 被启用时，`JavaScript` 文件中会报告错误。也就是相当于在项目中所有 `JavaScript` 文件顶部包含 `// @ts-check`。

### maxNodeModuleJsDepth

### disableSizeLimit

在处理非常大的`JavaScript`项目时，为了避免可能出现的内存膨胀问题，`TypeScript`分配的内存数量有一个上限。
打开此标志将取消限制。

### plugins

可在编辑器内运行的语言服务插件列表。

语言服务插件是一种基于现有 `TypeScript` 文件向用户提供额外信息的方法。它们可以改进 `TypeScript` 和编辑器之间的现有信息，或提供自己的错误信息。

### allowSyntheticDefaultImports

当设置为 true， 并且模块没有显式指定默认导出时，allowSyntheticDefaultImports 可以让你这样写导入：

```ts
import React from 'react'
```

而不是：

```ts
import * as React from 'react'
```

本选项不会影响 `TypeScript` 生成的 `JavaScript`，它仅对类型检查起作用。当你使用 `Babel` 生成额外的默认导出，从而使模块的默认导出更易用时，本选项可以让 `TypeScript` 的行为与 `Babel` 一致。

### esModuleInterop

默认情况下（未设置 `esModuleInterop` 或值为 `false``），TypeScript` 像 ES6 模块一样对待 `CommonJS/AMD/UMD`。这样的行为有两个被证实的缺陷：

* 形如 `import * as moment from "moment"` 这样的命名空间导入等价于 `const moment = require("moment")`

* 形如 `import moment from "moment"` 这样的默认导入等价于 `const moment = require("moment").default`

这种错误的行为导致了这两个问题：

* ES6 模块规范规定，命名空间导入（`import * as x`）只能是一个对象。TypeScript 把它处理成 `= require("x")` 的行为允许把导入当作一个可调用的函数，这样不符合规范。

* 虽然 `TypeScript` 准确实现了 `ES6` 模块规范，但是大多数使用 `CommonJS/AMD/UMD` 模块的库并没有像 `TypeScript` 那样严格遵守。

开启 `esModuleInterop` 选项将会修复 `TypeScript` 转译中的这两个问题。

### forceConsistentCasingInFileNames

### isolatedModules

虽然你可以使用 `TypeScript` 来从 `TypeScript` 中生成 `JavaScript` 代码，
但是使用其他转译器例如 `Babel` 也很常见。 但其他转译器一次只能在一个文件上操作，
这意味着它们不能进行基于完全理解类型系统后的代码转译。
这个限制也同样适用于被一些构建工具使用的 `TypeScript` 的 `ts.transpileModule` 接口。

这些限制可能会导致一些 `TypeScript` 特性的运行时问题，例如 `const enum` 和 `namespace`。 设置 `isolatedModules` `选项后，TypeScript` 将会在当你写的某些代码不能被单文件转译的过程正确处理时警告你。

它不会改变你代码的行为，也不会影响 `TypeScript` 的检查和代码生成过程。

如果设置了 `isolatedModules`，则所有的实现文件必须是 模块 （也就是它有某种形式的 `import/export`）。

### preserveSymlinks

### charset

配置从磁盘读取文本文件时使用的编码。

### keyofStringsOnly

### noImplicitUseStrict

### noStrictGenericChecks

### out

已弃用。

### suppressExcessPropertyErrors

### suppressImplicitAnyIndexErrors

### emitDecoratorMetadata

启用对使用`reflect-metadata`模块的装饰器发射类型元数据的实验性支持。

### experimentalDecorators

### jsx

控制 JSX 在 JavaScript 文件中的输出方式。 这只影响 .tsx 文件的 JS 文件输出。

* `react`: 将 JSX 改为等价的对 `React.createElement` 的调用并生成 .js 文件。
* `react-jsx`: 改为 `__jsx` 调用并生成 .js 文件。
* `react-jsxdev`: 改为 `__jsx` 调用并生成 .js 文件。
* `preserve`: 不对 JSX 进行改变并生成 .jsx 文件。
* `react-native`: 不对 JSX 进行改变并生成 .js 文件。

### jsxFactory

更改使用经典JSX运行时编译JSX Elements时在.js文件中调用的函数。
最常见的变化是使用`h`或`preact.h`而不是默认的`React`。

### jsxFragmentFactory

### jsxImportSource

### lib

`TypeScript` 包括一组默认的内建 JS 接口（例如 Math）的类型定义，以及在浏览器环境中存在的对象的类型定义
（例如 `document`）。 `TypeScript` 还包括与你指定的 `target` 选项相匹配的较新的 JS 特性的 API。
例如如果`target` 为 `ES6` 或更新的环境，那么 Map 的类型定义是可用的。

你可能出于某些原因改变这些：

* 你的程序不运行在浏览器中，因此你不想要 "dom" 类型定义。
* 你的运行时平台提供了某些 JavaScript API 对象（也许通过 polyfill），但还不支持某个 ECMAScript 版本的完整语法。
* 你有一些 （但不是全部）对于更高级别的 ECMAScript 版本的 polyfill 或本地实现。

**高阶库:**

| 名称       | 内容                                                                                                                        |
| ---------- | --------------------------------------------------------------------------------------------------------------------------- |
| ES5        | ES3 和 ES5 的核心功能定义                                                                                                   |
| ES2015     | ES2015 中额外提供的 API (又被称为 ES6) —— array.find， Promise，Proxy，Symbol，Map，Set，Reflect 等。                       |
| ES6        | ES2015 的别名。                                                                                                             |
| ES2016     | ES2016 中额外提供的 API —— array.include 等。                                                                               |
| ES7        | ES2016 的别名。                                                                                                             |
| ES2017     | ES2017 中额外提供的 API —— Object.entries，Object.values，Atomics，SharedArrayBuffer，date.formatToParts，typed arrays 等。 |
| ES2018     | ES2018 中额外提供的 API —— async iterables，promise.finally，Intl.PluralRules，rexexp.groups 等。                           |
| ES2019     | ES2019 中额外提供的 API —— array.flat，array.flatMap，Object.fromEntries，string.trimStart，string.trimEnd 等。             |
| ES2020     | ES2020 中额外提供的 API —— string.matchAll 等。                                                                             |
| ESNext     | ESNext 中额外提供的 API —— 随着 JavaScript 的发展，这些会发生变化。                                                         |
| DOM        | DOM 定义 —— window，document 等。                                                                                           |
| WebWorker  | WebWorker 上下文中存在的 API。                                                                                              |
| ScriptHost | Windows Script Hosting System 的 API。                                                                                      |

**库的各个组件:**

`DOM.Iterable`， `ES2015.Core`， `ES2015.Collection`， `ES2015.Generator`， `ES2015.Iterable`，
`ES2015.Promise`， `ES2015.Proxy`， `ES2015.Reflect`， `ES2015.Symbol`，
`ES2015.Symbol.WellKnown`， `ES2016.Array.Include`， `ES2017.object`，
`ES2017.Intl`， `ES2017.SharedMemory`， `ES2017.String`， `ES2017.TypedArrays`，
`ES2018.Intl`， `ES2018.Promise`， `ES2018.RegExp`， `ES2019.Array`，
`ES2019.Full`， `ES2019.Object`， `ES2019.String`， `ES2019.Symbol`，
`ES2020.Full`， `ES2020.String`， `ES2020.Symbol.wellknown`， `ESNext.AsyncIterable`，
`ESNext.Array`， `ESNext.Intl`， `ESNext.Symbol`

### moduleDetection

模块检查。

* `auto` (default): `typescript` 会不仅检查 `import` 或 `export` 语句，
  还会检查 `package.json` 是否有 `type` 字段，且当 配置文件中 `module` 值是否为 `nodenext` 或 `node16`时，`type` 字段值为 `module`。以及检查。
  当使用 `jsx: react-jsx` 配置时，当前文件是否是 `jsx` 文件。

* `legacy`: 检查文件是否包含 检查 `import` 或 `export` 语句。

* `force` : 确保每个非声明文件都被视为是一个模块。

### noLib

禁用自动包含任何库文件。如果设置了该选项，lib将被忽略。

### reactNamespace

已弃用，改用 [\`jsxFactory](#jsxfactory)

### target

编译目标

现代浏览器支持全部 `ES6` 的功能，所以 `ES6` 是一个不错的选择。 如果你的代码部署在旧的环境中，你可以选择设置一个更低的目标；如果你的代码保证会运行在新的环境中，你可以选择一个更高的目标。

`target` 的配置将会改变哪些 JS 特性会被降级，而哪些会被完整保留 例如，如果 `target` 是 `ES5` 或更低版本，箭头函数 `() => this` 会被转换为等价的 函数 表达式。

改变 `target` 也会改变 `lib` 选项的默认值。 你可以根据需要混搭 `target` 和 `lib` 的配置，你也可以为了方便只设置 `target`。

特殊的 `ESNext` 值代表你的 `TypeScript` 所支持的最高版本。这个配置应当被谨慎使用，因为它在不同的 `TypeScript` 版本之间的含义不同，并且会导致升级更难预测。

可选值： `es3` (default)， `es5`， `es6/es2015`， `es2016`， `es2017`， `es2018`， `es2019`， `es2020`， `es2021`， `es2022`， `esnext`

### useDefineForClassFields

### diagnostics

### explainFiles

### extendedDiagnostics

### generateCpuProfile

### listEmittedFiles

### listFiles

### traceResolution

### composite

`composite` 选项会强制执行某些约束，使得构建工具（包括 在 `--build` 模式下的 `TypeScript` 本身）可以快速确定一个工程是否已经建立。

当此设置开启时：

* 如果没有明确指定 `rootDir`，则默认为包含 `tsconfig.json` 文件的目录。

* 所有实现的文件必须由 `include` 来匹配，或在 `files` 数组中指定。如果违反了这一约束，`tsc` 将告诉你哪些文件没有被指定。

* `declaration` 默认为 `true`。

### disableReferencedProjectLoad

### disableSolutionSearching

### disableSourceOfProjectReferenceRedirect

### incremental

使 TypeScript 将上次编译的工程图信息保存到磁盘上的文件中。这将会在您编译输出的同一文件夹中创建一系列 `.tsbuildinfo` 文件。 它们不会再运行时被您的 `JavaScript` 使用，并且可以被安全的删除。

### tsBuildInfoFile

这个选项可以让您指定一个文件来存储增量编译信息，以作为复合工程的一部分，从而可以更快的构建更大的 `TypeScript` 代码库。

这个选项提供了一种方法，可以配置 `TypeScript` 追踪它存储在磁盘上的文件的位置，用来指示项目的构建状态。—— 默认情况下，它们与你生成的 `JavaScript` 在同一个文件夹中。

### noErrorTruncation

启用时，错误信息不会被截断。

### preserveWatchOutput

是否在控制台保留历史监听信息，而不是清空它们。

### pretty

是否使用 颜色和样式 格式化 输出信息。

### skipDefaultLibCheck

使用 `skipLibCheck` 此配置。

### skipLibCheck

跳过声明文件的类型检查。

这可以在编译期间节省时间，但代价是类型系统的准确性。例如，两个库可以以不一致的方式定义同一类型的两个副本。TypeScript不会对所有`d.ts`文件进行全面检查，而是会对你在应用源代码中特别引用的代码进行类型检查。

### assumeChangesOnlyAffectDirectDependencies

当这个选项被启用时，TypeScript将避免重新检查/重建所有可能真正受影响的文件，只检查/重建已经更改的文件以及直接导入这些文件的文件。

这可以被认为是监视算法的“快速和松散”实现，它可以大幅减少增量重建时间，代价是不得不偶尔运行完整的构建以获得所有编译器错误消息。

## `files`

**Types**： `string[]`

显式的指定需要编译的文件列表。

如果列表中的文件不存在，则会发生错误。

### example

```json
{
  "files": ["main.ts", "core.ts", "shared.ts", "utils.ts"]
}
```

## `include`

**Type**: `string[]`

指定需要编译的文件列表，可以是目录，文件，也可以是模式匹配。
这些文件路径是相对于包含`tsconfig.json`的目录进行解析。

### example

```json
{
  "include": ["src/**/*.ts", "test/**/*.ts"]
}
```

它将会匹配：

```sh
.
├── scripts                ⨯
│   ├── lint.ts            ⨯
│   ├── update_deps.ts     ⨯
│   └── utils.ts           ⨯
├── src                    ✓
│   ├── client             ✓
│   │    ├── index.ts      ✓
│   │    └── utils.ts      ✓
│   ├── server             ✓
│   │    └── index.ts      ✓
├── tests                  ✓
│   ├── app.test.ts        ✓
│   ├── utils.ts           ✓
│   └── tests.d.ts         ✓
├── package.json
├── tsconfig.json
└── yarn.lock
```

### patterns

`include` 和 `exclude` 支持使用 通配符 模式匹配：

* `*` 匹配零个到多个字符（不包含目录分隔符）
* `?` 匹配任意一个字符（不包含目录分隔符）
* `**/` 匹配任意嵌套深度的目录

## `exclude`

**Type**: `string[]`

指定在解析 `include` 包含的文件时，应该跳过的文件列表，可以是目录，文件，也可以是模式匹配。

### example

```json
{
  "exclude": ["src/**/*.spec.ts"]
}
```

**提示**：
`exclude` 仅排除已包含在 `include` 设置中的文件。
但有时候即使`exclude` 已配置了排除某个文件，但在代码中仍然使用`import` 语句引入该文件，或在 `types` 中包含该文件， 或通过 `/// <reference` 引入， `typescript` 仍然会编译它。

`exclude` 并不是一个阻止文件被包含代码组织里的机制，它只是作用于 `include` 查找文件时排除文件。

## `references`

**Type**： `{ path: string }[]`

项目引用是一种将TypeScript项目解构为更小片段的方法。
使用项目引用可以大大提高构建和编辑器交互时间，加强组件之间的逻辑分离，并以新方式改进代码组织。

## `watchOptions`

配置`typescript`编译器 监听 文件和目录 的行为。

当使用 命令行 `--watch` 启用 编译器编译器会使用 `fs.watch` 和 `fs.watchFile` 对 文件和目录进行监听，
但两种方式各有利弊。

`fs.watch` 使用 **file system events** 通知 文件和目录的变更。
但它依赖于操作系统，并且通知并不可靠，在许多操作系统上并不能正常工作。
此外，它还限制了创建监听数量，在一些操作系统上如 `linux`，我们可能会因为包含很多文件的大型项目而很快耗尽它。
但由于它是使用的 **file system events**，它不会消耗过多的 `CPU cycle` 。
在`typescript`编译器中，使用`fs.watch`用于监听允许精度缺失的 **目录** 变更（配置文件的 `include`，
或者模块解析失败的目录）。

但只有 `Windows` 和 `OSX` 支持 递归监听，这意味着在其他系统上需要通过其它方式来支持 递归监听。

`fa.watchFile` 通过 轮询 的方式实现监听，因此需要消耗比较多的 `CPU cycle` 。但是 `fs.watchFile` 是获取 **目录/文件** 状态更新的最可靠的方式。编译器使用 `fs.watchFile` 监听源文件、配置文件和缺失文件引用。

```json
{
  "watchOptions": {
    "watchFile": "",
    "watchDirectory": "",
    "fallbackPolling": "",
    "synchronousWatchDirectory": true,
    "excludeDirectories": [],
    "excludeFiles": []
  }
}
```

### `watchFile`

配置监听单个文件的策略。支持以下可选值：

|                                      | 描述                                                                                                                                                    |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `fixedPollingInterval`               | 每秒钟以固定时间间隔多次检查文件变更                                                                                                                    |
| `priorityPollingInterval`            | 使用 `fs.watchFile` 轮询检查文件变更。但对 源文件、配置文件、和缺失文件使用不同的时间间隔                                                               |
| `dynamicPriorityPolling`             | 使用动态队列的方式轮询检查文件变更。对于频繁变更的文件使用较短的时间间隔检查，对于低频变更的文件使用较长的时间间隔检查                                  |
| `useFsEvents` default | 使用 `fs.watch`(file system events) 监听文件变更（但在某些操作系统上可能不能正常监听变更）, 当超过了系统允许创建的监听数量限制时使用 `fs.watchFile`替代 |
| `useFsEventsOnParentDirectory`       | 使用 `fs.watch`(file system events) 监听文件的父目录的变更，精度较低                                                                                    |

### `watchDirectory`

配置在缺失递归文件监听功能的系统上，监听整个目录的策略。 支持以下可选值：

|                                      | 描述                                                                                                                   |
| ------------------------------------ | ---------------------------------------------------------------------------------------------------------------------- |
| `fixedPollingInterval`               | 每秒钟以固定时间间隔多次检查所有目录变更                                                                               |
| `dynamicPriorityPolling`             | 使用动态队列的方式轮询检查目录变更。对于频繁变更的目录使用较短的时间间隔检查，对于低频变更的目录使用较长的时间间隔检查 |
| `useFsEvents` default | 使用 `fs.watch`(file system events) 监听目录变更（但在某些操作系统上可能不能正常监听变更）                             |

### `fallbackPolling`

在使用文件系统事件时，此选项指定在系统耗尽本机文件监视器和/或不支持本机文件监视器时使用的轮询策略。

|                             | 描述                                                                                                                                                                    |
| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `fixedPollingInterval`      | 每秒钟以固定时间间隔多次检查文件变更                                                                                                                                    |
| `priorityPollingInterval`   | 使用 `fs.watchFile` 轮询检查文件变更。但对 源文件、配置文件、和缺失文件使用不同的时间间隔                                                                               |
| `dynamicPriorityPolling`    | 使用动态队列的方式轮询检查文件变更。对于频繁变更的文件使用较短的时间间隔检查，对于低频变更的文件使用较长的时间间隔检查                                                  |
| `synchronousWatchDirectory` | 禁用目录的延迟监视。当大量文件更改可能同时发生时(例如，运行npm install导致node\_modules发生更改)，延迟监视是有用的，但在一些不太常见的设置中，你可能想用这个标志禁用它。 |

### `synchronousWatchDirectory`

在不支持本地递归监听的平台上同步调用回调并更新目录监听器的状态。而不是给一个小的超时，以允许在一个文件上可能发生多次编辑。

```json
{
  "watchOptions": {
    "synchronousWatchDirectory": true
  }
}
```

### `excludeDirectories`

**Type**: `string[]`

配置不需要被 监听的 目录。此配置可以减少需要被监听的文件数量。

### `excludeFiles`

**Type**: `string[]`

配置不需要被 监听的 文件。此配置可以减少需要被监听的文件数量。

## `typeAcquisition`

指向项目 类型获取 的行为。

类型获取 只有在 `javascript` 中有重要作用。在 `javascript` 项目中， `typescript` 工具会在后台或者 `node_modules`外部下载模块的类型声明。

而在 `typescript` 项目中，你需要显式的在项目中指定包含的类型。

```json
{
  "typeAcquisition": {
    "enable": true,
    "include": [],
    "exclude": [],
    "disableFilenameBasedTypeAcquisition": true
  }
}
```

### `enable`

指定是否在 `javascript` 项目中是否启用 类型获取。

### `include`

显式的声明需要包含的依赖类型。用于在 `javascript`项目中帮助`typescript`工具理解依赖跟踪，或者 `disableFilenameBasedTypeAcquisition` 设置为`true`时需要手动添加依赖。

#### example

```json
{
  "typeAcquisition": {
    "include": ["lodash"]
  }
}
```

### `exclude`

禁用某些模块的类型获取，这对于在测试基础设施中包含主应用程序不需要的其他库的项目非常有用。

#### example

```json
{
  "typeAcquisition": {
    "exclude": ["jest", "mocha"]
  }
}
```

### `disableFilenameBasedTypeAcquisition`

TypeScript的类型获取可以根据项目中的文件名推断应该添加什么类型。
这意味着在你的项目中有一个像 `JQuery` 这样的文件会自动从 `DefinitelyTyped` 下载`JQuery`的类型。

---

---
url: /czxBlog/article/2f45bq9x/index.md
---
# 跨域资源共享(CORS)
**跨域资源共享（CORS）** 是一种基于 **HTTP Header** 的机制。
该机制通过允许服务器标示除了它自己的 origin（域，协议和端口），使这些 origin 有权限访问加载服务器上的资源。

跨域资源共享 通过 **预检请求** 的机制，检查服务器是否允许要发送的真实请求。
浏览器向服务器发送一个到服务器托管的跨域资源 **预检请求**，
在预检请求中，浏览器发送的头部中标示有HTTP方法和真实请求会用到的头。

## 前言

浏览器出于安全性的原因，会限制脚本内发起的跨域资源请求，
比如 **XMLHttpRequest** 和 **Fetch API** 遵循 **同源策略**，默认情况下不允许发起非同源的资源请求。
使用这些API的Web应用，只能加载从应用程序的同一个域的请求HTTP资源，
**除非响应报文中包含了正确的CORS响应头**

## 概述

跨域资源共享 新增了一组 HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。
同时，对于可能对服务器数据产生副作用的 HTTP 请求方法，浏览器必须首先使用 `OPTIONS` 方法发起一个预检请求，
从而获取服务器是否允许跨域请求，服务器确认允许之后，才发起实际的HTTP请求。

CORS 请求失败会产生错误，但是为了安全，在 JavaScript 代码中，是无法获取具体是哪里出了问题。
我们只能通过查看浏览器的控制台来获取具体出现的错误。

若要开启 CORS ，我们需要配置 CORS 相关的 HTTP首部字段。

## HTTP 响应首部字段

在 CORS 中，HTTP 响应首部字段主要有以下几个：

* **Access-Control-Allow-Origin**
* **Access-Control-Allow-Methods**
* **Access-Control-Allow-Headers**
* **Access-Control-Max-Age**
* **Access-Control-Expose-Headers**
* **Access-Control-Allow-Credentials**

### Access-Control-Allow-Origin

**Access-Control-Allow-Origin** 响应首部字段，用于 **指定允许访问该资源的外域URI**。

对于不需要携带身份凭证的请求，服务器可以指定改字段的值为通配符(`*`)，表示允许来自所有域的请求。

语法：

```
Access-Control-Allow-Origin: <origin>
Access-Control-Allow-Origin: *
```

如果服务器 指定了具体的域名而非 `*`，那么响应首部中的 **Vary** 字段的值必须包含 `Origin`。
用于告诉客户端：服务器对不同的源站返回不同的内容。

::: info 注意
当响应的是附带身份凭证的请求时，服务端 必须 明确 **Access-Control-Allow-Origin** 的值，而不能使用通配符`“*”`。
:::

**示例1：**

允许所有域访问

```
Access-Control-Allow-Origin: *
```

**示例2：**

允许来自 <https://chongzhenxiang.cn> 的请求

```
Access-Control-Allow-Origin: https://chongzhenxiang.cn
Vary: Origin
```

### Access-Control-Allow-Methods

**Access-Control-Allow-Methods** 响应首部字段用于 预检请求的响应。
**指明了实际请求所允许使用的HTTP方法或方法列表**。

语法：

```
Access-Control-Allow-Methods: <method>[, <method>]*
```

示例：

```
Access-Control-Allow-Methods: POST, GET, OPTIONS
```

### Access-Control-Allow-Headers

**Access-Control-Allow-Headers** 响应首部字段用于 预检请求的响应。
**指明了实际请求中允许携带的首部字段**。

语法：

```
Access-Control-Allow-Headers: <header-name>[, header-name]*
Access-Control-Allow-Headers: *
```

以下特定的首部是一直允许的，无需特意声明他们：

* Accept
* Accept-Language
* Content-Language
* Content-Type，但只在其值属于MIME类型 `application/x-www-form-urlencoded`,`multipart/form-data`,`text/pain` 中的一种。

**示例1：**

自定义请求头。 除了 CORS 安全清单列出的请求头外，支持 自定义请求头 X-Custom-Header

```
Access-Control-Allow-Headers: X-Custom-Header
```

**示例2：**

多个自定义请求头。

```
Access-Control-Allow-Headers: X-Custom-Header, X-My-Header
```

### Access-Control-Max-Age

**Access-Control-Max-Age** 响应首部字段表示 **预检请求的返回结果可以被缓存多久**。

返回结果是指： **Access-Control-Allow-Methods** 和 **Access-Control-Allow-Headers** 提供的信息。

语法：

```
Access-Control-Max-Age: <delta-seconds>
```

**delta-seconds** 表示返回结果可以被缓存的最长时间（秒）。
在 Firefox 中， 上限是 **24小时（86400秒）**。
在 Chromium 中，上限是 **2小时（7200秒）**，同时 Chromium 还规定了默认值是 **5秒**。
如果值为 **-1** ， 表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。

**示例：**

将预检请求缓存 10分钟：

```
Access-Control-Max-Age: 600
```

### Access-Control-Expose-Headers

**Access-Control-Expose-Headers** 响应首部字段，列出了 哪些首部可以作为响应的一部分暴露给外部。

在 跨源访问时，XMLHttpRequest 对象的 `getResponseHeader()` 方法默认只能拿到一些最基本的响应头。

默认情况下，只有七种 简单响应首部 可以暴露给外部:

* Cache-Control
* Content-Language
* Content-Length
* Content-Type
* Expires
* Last-Modified
* Pragma

如果期望让客户端可以访问到其他的首部信息，可以将它们 该字段受列出来。

语法：

```
Access-Control-Expose-Headers: <header-name>[, <header-name>]*
```

**示例：**

暴露一个非简单响应首部：

```
Access-Control-Expose-Headers: X-My-Header
```

暴露多个非简单响应首部：

```
Access-Control-Expose-Headers: X-My-Header, X-Custom-Header
```

### Access-Control-Allow-Credentials

**Access-Control-Allow-Credentials** 响应首部字段 用于在 请求包含 Credentials 时，
告知浏览器是否可以将对请求的响应暴露给前端 JavaScript 代码。

当请求的 Credentials 模式 （Request.credentials）为 `include` 时，浏览器尽在相应头 **Access-Control-Allow-Credentials** 的值为 `true` 时将响应暴露给前端的 JavaScript 代码。

Credentials 可以是 `cookies`、 `authorization headers` 或 `TLS client certificates`。

语法：

```
Access-Control-Allow-Credentials: true
```

**Access-Control-Allow-Credentials** 需要与 `XMLHttpRequest.withCredentials`
或 **Fetch API** 的 `Request()` 构造函数中的 `credentials` 选项结合使用。
Credentials 必须在前后端都被配置，才能使带 credentials 的 CORS 请求成功。

**示例：**

允许 credentials

```
Access-Control-Allow-Credentials: true
```

使用带 credentials 的 XHR:

```js
const xhr = new XMLHttpRequest()
xhr.open('GET', 'https://chongzhenxiang.cn', true)
xhr.withCredentials = true
xhr.send(null)
```

使用带 credentials 的 Fetch:

```js
fetch('https://chongzhenxiang.cn', {
  credentials: 'include',
})
```

## HTTP 请求首部字段

在 CORS 中，可用于发起跨域请求的首部字段，如下：

* Origin
* Access-Control-Request-Method
* Access-Control-Request-Headers

这些首部字段无需手动设置。

当开发者使用 XMLHttpRequest 发起跨域请求时，它们已经被设置就绪。

### Origin

**Origin** 请求首部字段表明预检请求或实际请求的源站。

语法：

```
Origin: <origin>
```

origin 参数的值为源站的URI。不包含任何路径信息，仅表示服务器名称。

### Access-Control-Request-Method

**Access-Control-Request-Method** 请求首部字段用于预检请求。作用是 将实际情况所使用的HTTP方法告诉服务器。

语法：

```
Access-Control-Request-Method: <method>
```

### Access-Control-Request-Headers

**Access-Control-Request-Headers** 请求首部字段用于预检请求。作用是 将实际请求所携带的首部字段告诉服务器。

语法：

```
Access-Control-Request-Headers: <header-name>[, <header-name>]*
```

## 预检请求

一个 CORS 预检请求时用于 检查服务器使用支持 CORS， 即 跨域资源共享。

预检请求 通过 发送一个 OPTIONS 请求，请求头部包含了以下字段：

* Access-Control-Request-Method
* Access-Control-Request-Headers
* Origin

浏览器会在有必要的时候，自动发出一个预检请求。

所以在正常情况下，前端开发者不需要自己去发送这样的请求。

### 预检请求与凭据

CORS 预检请求不能包含凭据。预检请求的响应必须指定 Access-Control-Allow-Credentials: true 来表明可以携带凭据进行实际的请求。

## 简单请求

某些情况下，不会触发 CORS预检请求，这样的请求，可表述为 *简单请求*。

若请求满足以下所有条件，则可视为 简单请求：

* 使用 GET, HEAD POST 请求方法
* 除了被用户代理自动设置的首部字段（Connection，User-Agent等），
  以及在 Fetch 规范中定义为 [禁用首部名称](https://fetch.spec.whatwg.org/#forbidden-header-name) 的其他首部，
  允许人为设置的字段为 Fetch 规范定义的 对 [CORS 安全的首部字段集合](https://fetch.spec.whatwg.org/#cors-safelisted-request-header)
* 请求中任意的 XMLHttpRequest 对象均没有注册任何监听事件，
  XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问。
* 请求中没有使用 ReadableStream 对象。

## 附带身份的请求与通配符

在响应附带身份凭证的请求时：

* 服务器不能将 **Access-Control-Allow-Origin** 的值设为通配符 `*`，而应将其设置为特定的域，如：Access-Control-Allow-Origin: <https://chongzhenxiang.cn。>

* 服务器不能将 **Access-Control-Allow-Headers** 的值设为通配符 `*`，而应将其设置为首部名称的列表，如：Access-Control-Allow-Headers: X-Custom-Header, Content-Type

* 服务器不能将 **Access-Control-Allow-Methods** 的值设为通配符 `*`，而应将其设置为特定请求方法名称的列表，如：Access-Control-Allow-Methods: POST, GET

## 需要CORS的场景

1. 使用 **XMLHttpRequest** 发起的 HTTP请求
2. 使用 **Fetch API** 发起的 HTTP 请求
3. Web字体，CSS通过 `@font-face` 使用的跨域字体资源
4. WebGL 贴图
5. 使用 drawImage 将 Images/video 画面绘制到 canvas
6. 来自图像的 CSS 图形

## 安全

在实际的使用场景中，尽可能的少使用 通配符 `*`，来允许所有域访问，或允许所有自定义首部字段，
这可能在 web 安全上来带风险。

---

---
url: /czxBlog/article/4ef5e74b/index.md
---
# 一文读懂 CSS 自定义滚动条
有时候，为了保持我们的应用程序 UI 交互体验在不同系统的一致性，需要覆盖默认的滚动条，
通过自定义滚动条的方式，获得更好的用户体验。

:::demo-wrapper img
![scrollbar intro](/images/scrollbar/scrollbar-intro.jpg)
:::

## 滚动条的组成

首先，需要了解 滚动条由哪些部分组成的。

滚动条主要包含两个部分： **滚动轨道 Track** 和 **滑块 Thumb**。

:::demo-wrapper img
![scrollbar parts](/images/scrollbar/scrollbar-parts.jpg)
:::

**Track** 是滚动条的底部， **Thumb** 是提供用户交互的， 当用户拖动它控制页面或容器的滚动内容。

滚动条可以出现在 **水平** 或者 **垂直** 方向，而且在 多语言环境下，也会随着 从左到右 `LTR` 和 从右到左 `RTL`
而变化。

:::demo-wrapper img
![scrollbar places dir](/images/scrollbar/scrollbar-places-dir.jpg)
:::

## 自定义滚动条

在过去，能够进行 自定义滚动条的， 只有 基于 `webkit` 内核的浏览器 得到了支持，而像 `Firefox` 和 `IE`
浏览器则不具备 自定义滚动条 的能力。但是，对于 `Firebox`， CSS 有了新的语法帮助我们完成滚动条的自定义。

我将分别介绍 `webkit` 下的旧的语法，然后是 新的语法。

### 旧的语法

#### 滚动条宽度

首先，我们需要定义滚动条的大小，它可以是垂直滚动条的宽度，也可以是水平滚动条的高度。

```css
.container::-webkit-scrollbar {
  width: 10px;
}
```

然后，我们就可以开始自定义滚动条的样式了。

#### 滚动条 Track

Track 表示滚动条的底部，我们可以通过添加 `background-color`、`box-shadow`、 `border-radius` 和 `border` 来控制 Track 的样式。

```css
.container::-webkit-scrollbar-track {
  background-color: darkgrey;
}
```

#### 滚动条 Thumb

准备好 滚动条的底部后，我们还需要设置滚动条 `Thumb` 的样式。用户可以拖动 `Thumb` 来与滚动条进行交互。

```css
.container::-webkit-scrollbar-thumb {
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
}
```

#### 旧语法浏览器兼容

@[caniuse](mdn-css_selectors_-webkit-scrollbar)

至此，我们已经介绍了 CSS 中设置 自定义滚动条的旧语法以及兼容性。
接下来，我们将介绍 CSS 中设置 自定义滚动条的新语法。

### 新语法

#### 滚动条宽度

这定义了滚动条宽度，我们需要关注的值是 `auto` 和 `thin` 。
需要注意的是，我们无法像 `webkit` 语法那样定义一个特定的数字。

```css
.section {
  scrollbar-width: thin;
}
```

#### 滚动条颜色

使用此属性，我们可以将滚动条 `Track` 和 `Thumb` 的颜色定义为成对的值。

```css
.section {
  scrollbar-color: #6969dd #e0e0e0;
}
```

尽管这种语法很简单，但是我们只能使用 纯色，无法添加 阴影、渐变、圆角边框 等其他相关的样式。

#### 滚动条装订线 Gutter

你有没有想过，当内容在滚动容器中增加时，我们如何避免布局变化？让我们以以下案例为例。

:::demo-wrapper img
![scrollbar gutter](/images/scrollbar/scrollbar-gutter-1.jpg)
:::

```css
.box {
  padding: 1rem;
  max-height: 220px;
  overflow-y: auto;
}
```

我们有一个四周都有 1rem 的内边距的容器。到目前为止，内容很短，滚动条不会显示，因为使用了 `overflow-y: auto`。

> \[!note]
> 当我们使用 `overflow-y: auto` ，当内容很短时不会显示滚动条，直到内容超过了容器的高度，滚动条才显示。

当内容增长时，将显示滚动条，从而减少内容的可用空间。

:::demo-wrapper img
![scrollbar gutter](/images/scrollbar/scrollbar-gutter-2.jpg)
:::

可以看到，当内容过长出现滚动条时，内容会发生偏移。
这是由于浏览器为滚动条保留了一个空间，导致内容空间收到挤压变小。

但幸运的是，现在可以通过 [`scrollbar-gutter`](https://developer.mozilla.org/en-US/docs/Web/CSS/scrollbar-gutter) 属性来解决这个问题。它帮助为滚动条提前预留足够的空间。
它的默认值为 `auto`，可选值有 `stable` 和 `both-edges` 。

```css
.box {
  padding: 1rem;
  max-height: 220px;
  overflow-y: auto;
  scrollbar-gutter: stable;
}
```

:::demo-wrapper img
![scrollbar gutter](/images/scrollbar/scrollbar-gutter-3.jpg)
:::

当内容增加时，就不会影响布局的空间变化，因为浏览器已经为 滚动条预留了空间。

:::demo-wrapper
![scrollbar gutter](/images/scrollbar/scrollbar-gutter-4.jpg)
:::

好消息是，`scrollbar-gutter` 的兼容性，从 `Chrome@94` 就开始得到了支持。

#### 新语法浏览器兼容

@[caniuse](mdn-css_properties_scrollbar-width)

## 自定义滚动条的使用范围

有一点需要考虑的，我们的 自定义滚动条，它应该在哪里生效。
是希望所有的 可滚动的元素都应用 自定义滚动条，还是只有特定的元素应用自定义滚动条呢。

### 所有可滚动元素

对于 旧的语法， 想要使所有 可滚动元素都 生效，我们可以直接编写 选择器，而无需将它们附加到元素。

```css
::-webkit-scrollbar {
  width: 10px;
}

::-webkit-scrollbar-track {
  background-color: darkgrey;
}

::-webkit-scrollbar-thumb {
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
}
```

而对于新语法，只需要将它们 应用于 `<html>` 元素即可

```css
html {
  scrollbar-color: #6969dd #e0e0e0;
  scrollbar-width: thin;
}
```

### 特定可滚动元素

对于 旧的语法，想要使特定的 可滚动元素生效，我们在特定元素之后编写 选择器。

```css
.container::-webkit-scrollbar {
  width: 10px;
}

.container::-webkit-scrollbar-track {
  background-color: darkgrey;
}

.container::-webkit-scrollbar-thumb {
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
}
```

对于新语法，也是是相同的。

```css
.container {
  scrollbar-color: #6969dd #e0e0e0;
  scrollbar-width: thin;
}
```

## 设计自定义滚动条

在深入研究 自定义滚动条之前，首先需要了解 默认的滚动条的样式。

默认的滚动条在 不同的操作系统之中是不同的。

在 MacOS Safari 中， Track 两侧都有边框， 背景色为纯色，Thumb 是圆形的，左右两侧都有空间。
:::demo-wrapper img
![scrollbar use case](/images/scrollbar/use-case-1.jpg)
:::
而在 MacOS Chrome 中，Track 是透明的，`Thumb` 是原型的，而且整个滚动条只在滚动时才显示，且不占据空间。

在 Windows 中，Track 是 灰色背景，Thumb 是 矩形的。
::: demo-wrapper img
![scrollbar use case](/images/scrollbar/use-case-1-2.jpg)
:::

### 示例1

以下是根据上面的模型，自定义的滚动条

```css
.container::-webkit-scrollbar {
  width: 16px;
}

.container::-webkit-scrollbar-track {
  background-color: #e4e4e4;
  border-radius: 100px;
}

.container::-webkit-scrollbar-thumb {
  background-color: #d4aa70;
  border-radius: 100px;
}
```

为 `Track` 和 `Thumb` 添加 `border-radius` 是必要的，因为 `border-radius` 无法在 `::-webkit-scrollbar`
上生效。

:::demo-wrapper no-padding

如果是使用的 新的语法，我们不能调整 滚动条的宽度，能做的事情只有设置 `Track` 和 `Thumb` 的颜色：

```css
.container {
  scrollbar-color: #d4aa70 #e4e4e4;
}
```

***

> \[!warning]
> 以下示例仅适用于 `webkit` 内核的浏览器。对于实际项目，你还可以同时添加新的语法支持 `Firefox`。

### 示例2：阴影+渐变

在这个示例中，我们给滚动条添加了 阴影 和 渐变。来看看效果如何：

```css
.container::-webkit-scrollbar-thumb {
  background-image: linear-gradient(180deg, #d0368a 0%, #708ad4 99%);
  box-shadow: inset 2px 2px 5px 0 rgba(#fff, 0.5);
  border-radius: 100px;
}
```

:::demo-wrapper no-padding title="渐变"

### 示例3: 带边框

我们还可以为 `Track` 和 `Thumb` 添加 边框，这可以帮助我们解决一些棘手的设计。

```css
.container::-webkit-scrollbar-thumb {
  border-radius: 100px;
  background: #8070d4;
  border: 6px solid rgba(0, 0, 0, 0.2);
}
```

:::demo-wrapper no-padding

基于相同的示例，我们还可以调整 `Thumb` 的 边框，获得一些有趣的效果。

```css
.container::-webkit-scrollbar-thumb {
  border-radius: 100px;
  background: #8070d4;
  border: 6px solid rgba(0, 0, 0, 0.2);
  border-left: none;
  border-right: none;
}
```

:::demo-wrapper no-padding

### 示例4：Thumb 带间隔

在此示例中，我们希望 `Thumb` 的四周与 `Track` 都带有一定的间隔。 由于它无法与 滚动条一起使用 `padding`。
因此我们需要使用 `border` 和 `background-clip` 实现效果。

```css
.container::-webkit-scrollbar-thumb {
  border: 5px solid transparent;
  border-radius: 100px;
  background-color: #8070d4;
  background-clip: content-box;
}
```

:::demo-wrapper no-padding title="Thumb 带间隔"

## 增加 hover 效果

我们可以为 滚动条添加 `hover` 效果吗?

是的, 可以。我们可以为 新旧的语法添加 `hover` 效果。

```css
/* 旧语法 */
.section::-webkit-scrollbar-thumb:hover {
  background-color: #5749d2;
}

/* 新语法 */
.section {
  scrollbar-color: #d4aa70 #e4e4e4;
  transition: scrollbar-color 0.3s ease-out;
}

.section:hover {
  scrollbar-color: #5749d2;
}
```

同时，在使用新语法上，我们还可以添加 过渡效果，但是在 旧语法 上则不支持。

:::demo-wrapper no-padding title="hover 效果"

## 在需要时显示滚动条

通过向 `overflow` 属性添加值以外的 `visible` 值，可以创建可滚动元素。
建议使用关键字， `auto` 因为它只会在内容超出其容器时显示滚动条。

```css
.container {
  overflow: auto;
}
```

---

---
url: /czxBlog/article/6itrx1jz/index.md
---
# 消除异步传染性
**异步传染性** 是指，当一个函数使用了 `async / await`，其调用者也需要使用 `async / await` 处理异步操作，
这导致了与之相关的整个调用链，都变成了异步的。这种情况可能导致代码变得复杂，不易于维护。

## 概述

在之前的某一个面试中， 恰好遇到了这么一个问题：

> \[!note]
> 我个人是很反感这种类型的面试的，它只会变成面试中的八股文，让人去背答案，
> 但却在大多数的开发场景中，都不会这么去做，甚至于，这道题目本身的答案，可能
> 还会列在开发规范的禁止规则中，以至于无法通过 code-review。
>
> 这道题目虽然可以利用 JavaScript 本身的特性解决，但大多数时候，谁会去这么写代码呢？
> 我是不支持这样去滥用语言特性的，也许你在做一个基础建设时，搭建某些库或框架，不得不去
> 这么做，那么我是支持的，但是，大多数的业务开发，这么写就是在给其他人埋坑。

消除下面代码中的异步传染性， 通过同步调用 打印 正确的结果。

```ts
async function getData() {
  return fetch('/api/data').then(res => res.json())
}

async function foo() {
  // other work
  return await getData()
}

async function bar() {
  // other work
  return await foo()
}

async function main() {
  // other work
  const data = await bar()

  console.log(data)
}

main()
```

期望的结果是：

```ts
function main() {
  // other work
  const data = bar()

  console.log(data) // 打印正确的结果
}
```

这道题目乍一看， `data` 的源头是从 `getData()` 中，调用 服务接口获取的，需要等待 服务器响应后才能
获取数据，那又怎么做到 同步执行获取结果呢？

## 解决方案

在代码中，可以看到，最初的异步是从 `getData()` 函数中的 `fetch()` 发起的，想要解决这个问题，就需要
从这里开始下手。

试想一下，`fetch()` 获取数据结果必然是需要等待时间的，除非它立即抛出了错误:

```ts
async function getData() {
  const res = fetch('/api/data').then(res => res.json())
  throw new Error('error')
  return res // 演示用，实际情况代码不会这么写，因为这里永远不执行
}
```

此时，如果我们不手动捕获该错误，则会导致程序中断。但是可以看到，抛出错误是 立即执行的，符合 同步执行的要求。

那么我们可以沿着这个思路，继续尝试。

我们可以通过 `try {} catch {}` 手动捕获这个错误，然后继续执行其他的代码。但是，应该捕获什么样的错误，才是
我们想要的呢？ 如果仅仅是抛出一个 普通的 请求错误，或者是 执行时错误，这对于 我们的问题 没有任何的用处，
因为它们不能告诉我们 数据准备好了。

那么，谁能告诉我们 数据准备好了？ 还是 只有 `fetch()` 返回给我们的 `Promise` 才能告诉我们数据准备好了。
既然如此，那么我们就直接将 这个 `Promise` 作为 错误抛出，然后再重新捕获它不就好了吗？

```ts
async function getData() {
  const res = fetch('/api/data').then(res => res.json())
  throw res
  return res // 演示用，实际情况代码不会这么写，因为这里永远不执行
}

function main() {
  // other work
  try {
    const data = getData()
    console.log(data)
  }
  catch (err) {
    if (err instanceof Promise) {
      // do something
    }
  }
}
```

接着，我们可以在 `catch` 块中， 检查 `Promise` 是不是有返回结果。这样我们就可以知道 数据是否准备好了。

但是，知道数据准备好了，然后呢？`main()` 方法已经执行完毕了， `console.log(data)` 并没有被执行到。
由此产生了下面的问题：

* 如何让 `console.log(data)` 执行?
* 数据准备好又该从哪里去拿？

重新执行必然需要重新调用 `main()` 函数，但是 重新调用 `main()` 函数，又必然重新抛出错误。
因此，还需要 让 `getData()` 知道什么时候该抛出错误，什么时候不需要抛出错误。

我们可以 增加一个 缓存机制， 当 `Promise` 状态从 `pending` 变更后，将结果 缓存起来。
然后在 `getData()` 中，判断 是否有 缓存，有缓存就直接返回 缓存结果。
当然还有最重要的一步， 将 `Promise` 状态从 `pending` 变更后，需要重新调用一次 `main()` 函数。

```ts
// 缓存数据
let cache = null

function getData() {
  // 发现有缓存立即返回 缓存数据
  if (cache) {
    if (cache.status === 'fulfilled') {
      return cache.data
    }
    else {
      throw new Error(cache.reason)
    }
  }
  const res = fetch('/api/data').then(res => res.json())
  throw res
}

function main() {
  // other work
  try {
    const data = getData()
    console.log(data)
  }
  catch (err) {
    // 捕获 `getData`抛出的错误， 判断 err 是不是 `Promise`
    if (err instanceof Promise) {
      // 对结果进行缓存
      err
        .then(
          (data) => {
            cache = {
              status: 'fulfilled',
              data,
            }
          },
          (reason) => {
            cache = {
              status: 'rejected',
              reason,
            }
          },
        )
        // 重新调用 `main()`
        .finally(() => main())
    }
  }
}
```

::: note
这不能作为最终答案，因为它对 `getData()` 和 `main()` 做了太多的改动。
实际上的答案应该将这部分改写的逻辑封装到一个单独的函数中。

这里就不给出实现代码的示例了，不妨自己尝试一下？
:::

将 `fetch` 部分 替换为一个 假数据接口来进行测试：

```ts
function sleep(num, func) {
  return new Promise((resolve) => {
    setTimeout(() => {
      func?.()
      resolve()
    }, num || 0)
  })
}

async function mockData() {
  await sleep(100)
  return { a: 1 }
}

// 缓存数据
let cache = null

function getData() {
  // 发现有缓存立即返回 缓存数据
  if (cache) {
    if (cache.status === 'fulfilled') {
      return cache.data
    }
    else {
      throw new Error(cache.reason)
    }
  }
  const res = mockData()
  throw res
}

function main() {
  // other work
  try {
    const data = getData()
    console.log(data)
  }
  catch (err) {
    // 判断 错误是不是 `Promise`
    if (err instanceof Promise) {
      // 对结果进行缓存
      err
        .then(
          (data) => {
            cache = {
              status: 'fulfilled',
              data,
            }
          },
          (reason) => {
            cache = {
              status: 'rejected',
              reason,
            }
          },
        )
        // 重新调用 `main()`
        .finally(main)
    }
  }
}

main()
```

> \[!tip]
> 你可以直接复制这段代码到 浏览器的控制台中直接运行，看看结果。

::: code-tabs
@tab Console

```txt
{ a: 1 }
```

:::

## 总结

从代码角度分析，实现的同步执行获取结果的过程中，利用的是 抛出错误会阻断后续代码的执行，
然后捕获错误，在 `catch` 中 等待 异步结果并缓存，最后再重新调用 `main()` 函数，直接返回 缓存结果。

实现了 看似同步执行的结果。实际上， `main()` 函数执行了两次，这就产生了副作用。

如果 `main()` 函数内容 在 `getData()` 调用之前的代码中， 包含了会影响外部作用域的代码，
那么两次执行 `main()` 就可能产生意想不到的影响。

于是，这就又要求了 在 `main()` 的整个调用链上的函数，应该都是 纯函数，不应该有副作用。

---

---
url: /czxBlog/article/6lgzinfk/index.md
---
# React 原理解析：Fiber 架构与双缓冲机制
## Fiber 架构的核心概念

### Fiber 节点的本质

Fiber 节点是 React 16 引入的核心架构元素，它代表了 **组件树中的工作单元** 。
每个 Fiber 节点对应一个 React 元素，构成了一种 **基于链表的虚拟 DOM 实现**。

```javascript
function FiberNode(tag, pendingProps, key, mode) {
  // 树形结构指针
  this.return = null // 指向父节点
  this.child = null // 指向第一个子节点
  this.sibling = null // 指向下一个兄弟节点
  this.index = 0 // 在父节点中的索引位置

  // 静态数据结构
  this.tag = tag // 组件类型标记
  this.key = key // 唯一标识
  this.elementType = null // 元素类型
  this.type = null // 实际类型（函数/类/DOM标签）
  this.stateNode = null // 关联的DOM节点

  // 动态工作单元
  this.pendingProps = pendingProps // 待处理props
  this.memoizedProps = null // 已应用的props
  this.memoizedState = null // 当前状态
  this.updateQueue = null // 状态更新队列
  this.flags = NoFlags // 生命周期标记
  this.subtreeFlags = NoFlags // 子树标记
  this.lanes = NoLanes // 优先级标记
}
```

### Fiber 的三重含义

Fiber 架构包含三个维度的设计理念：

1. **架构层面**：取代传统递归更新（Stack Reconciler）的 **可中断异步架构**
2. **静态数据结构**：表示组件树结构的 **链表节点**
3. **动态工作单元**：封装组件状态、副作用和更新操作的 **执行单元**

这种设计使 React 能够将渲染工作拆分为可增量执行的小任务单元，实现时间切片和优先级调度。

## 双缓冲技术解析

### 双缓冲核心概念

双缓冲（Double Buffering）是一种图形渲染优化技术，在 React 中应用为：

* **当前树（Current Tree）**：代表屏幕上实际渲染的内容
* **工作树（WorkInProgress Tree）**：内存中构建的新树，用于准备下一次更新

两棵树通过 `alternate` 属性相互引用：

```javascript
current.alternate = workInProgress
workInProgress.alternate = current
```

### 双缓冲工作流程

```mermaid
graph TD
    A[开始] --> B{阶段}
    B -->|首次渲染| C[创建FiberRoot]
    C --> D[构建WorkInProgress树]
    D --> E[提交渲染]
    E --> F[切换Current指针]

    B -->|状态更新| G[创建新WorkInProgress树]
    G --> H[复用节点/Diff算法]
    H --> I[提交更新]
    I --> F

    F --> J[结束]
```

## 首次渲染（Mount）流程

### 关键数据结构

```mermaid
classDiagram
    class FiberRootNode {
        +current: FiberNode
        +containerInfo: DOMContainer
    }

    class FiberNode {
        +tag: number
        +key: string
        +stateNode: DOMNode
        +alternate: FiberNode
        +return: FiberNode
        +child: FiberNode
        +sibling: FiberNode
    }

    FiberRootNode --> FiberNode : current
    FiberNode --> FiberNode : alternate
```

### 挂载过程

```javascript
// 创建应用根节点
const root = ReactDOM.createRoot(document.getElementById('root'))

// 内部执行流程
function createFiberRoot() {
  const root = new FiberRootNode()
  const hostRootFiber = createHostRootFiber()

  // 建立关联
  root.current = hostRootFiber
  hostRootFiber.stateNode = root

  return root
}
```

1. **初始化阶段**：

   * 创建 `fiberRootNode`（应用根节点）
   * 创建 `hostRootFiber`（组件树根节点）
   * 建立相互引用关系

2. **渲染阶段**：

   * 基于组件 JSX 深度优先构建 WorkInProgress 树
   * 新节点与 current 树节点建立 `alternate` 关联

3. **提交阶段**：

   * 将 WorkInProgress 树渲染到 DOM
   * 切换 `fiberRootNode.current` 指向新树
   * WorkInProgress 树变为 Current 树

## 更新（Update）流程

### 更新触发机制

当组件状态变更触发更新：

```jsx
function Counter() {
  const [count, setCount] = useState(0)

  return (
    <button onClick={() => setCount(c => c + 1)}>
      Count:
      {' '}
      {count}
    </button>
  )
}
```

### 更新处理流程

```mermaid
sequenceDiagram
    participant User as 用户交互
    participant React as React运行时
    participant Renderer as 渲染器

    User->>React: 触发状态更新
    React->>React: 创建新WorkInProgress树
    React->>React: Diff算法节点复用
    React->>Renderer: 提交更新
    Renderer->>Renderer: DOM操作
    React->>React: 切换Current指针
    React-->>User: 更新完成
```

1. **构建新树**：

   * 基于 current 树创建新 WorkInProgress 树
   * 通过 `alternate` 属性复用现有节点

2. **Diff 算法**：

   * 对比新旧树确定最小变更集
   * 标记需要更新的节点（`flags`）

3. **提交阶段**：

   * 应用 DOM 更新
   * 切换 `fiberRootNode.current` 指针
   * 新树成为 current 树

### 节点复用机制

在更新过程中，React 通过 Diff 算法决定节点复用策略：

```mermaid
flowchart TD
    A[开始更新] --> B{节点是否存在}
    B -->|是| C[检查属性和类型]
    C -->|可复用| D[复用现有节点]
    C -->|不可复用| E[创建新节点]
    B -->|否| F[创建新节点]
    D & E & F --> G[继续处理子节点]
    G --> H[完成更新]
```

## 双缓冲机制的优势

1. **无闪烁更新**：在内存中完成整棵树构建后一次性提交
2. **状态一致性**：确保渲染过程中状态不会部分更新
3. **异步可中断**：允许高优先级任务中断当前渲染
4. **高效回退**：更新失败可回退到完整旧树
5. **资源复用**：节点复用减少内存分配开销

## 总结

React Fiber 架构通过双缓冲机制实现了：

* **增量渲染**：将大型更新拆分为可中断的小任务
* **优先级调度**：确保高优先级交互（如动画）即时响应
* **高效更新**：通过节点复用和精确 DOM 操作优化性能
* **错误隔离**：组件树错误不影响整个应用

双缓冲机制作为核心优化策略，使 React 能够平衡渲染性能与用户体验，为复杂应用提供流畅的交互体验。理解这一机制有助于开发者编写更高效的 React 组件，并深入掌握框架底层原理。

---

---
url: /czxBlog/article/6snk1b6c/index.md
---
# JavaScript进阶（三）— 执行上下文栈
关于 执行上下文，请点击查看[这篇文章](/article/d12xkizf/)。

## 执行上下文栈

`JavaScript` 引擎 创建了 执行上下文栈 来存储并管理 代码执行时创建的所有 执行上下文。

执行上下文栈（Execution context stack，ECS） 是一个种拥有 LIFO(后进先出) 的栈。

我们使用一个数组 模拟 执行上下文栈:

```js
const ECSStack = []
```

当 `JavaScript` 执行时，首先遇到的是 全局代码，初始化时，会首先向 执行上下文栈中压入 全局执行上下文
（global execution context)。它只有在整个程序结束时，才会被清空，所以在程序结束前， `ECSStack` 底部
都会有一个 `globalExecutionContext`

```js
const ECSStack = [globalExecutionContext]
```

当 `JavaScript` 开始执行以下代码时：

```js
function foo() {
  console.log('foo')
}
function bar() {
  foo()
}
function run() {
  bar()
}

run()
```

在这段代码中，`JavaScript` 进行以下处理：

```ts
// 伪代码：

// run()， 创建 函数执行上下文，并压入 执行上下文栈
ECSStack.push(functionExecutionContext<run>)

// run() 中发现需要执行 bar(), 继续创建 函数执行上下文，并压入执行上下文栈
ECSStack.push(functionExecutionContext<bar>)

// bar() 中发现需要执行 foo(), 继续创建 函数执行上下文，并压入执行上下文栈
ECSStack.push(functionExecutionContext<foo>)

/**
 * 此时， ECSStack 的结构，如下：
 * [
 *    globalExecutionContext,
 *    functionExecutionContext<run>,
 *    functionExecutionContext<bar>,
 *    functionExecutionContext<foo>
 * ]
 */

// 当 foo() 执行完毕，从执行上下文栈中移除 functionExecutionContext<foo>
ECSStack.pop()

// 当 bar() 执行完毕，从执行上下文栈中移除 functionExecutionContext<bar>
ECSStack.pop()

// 当 run() 执行完毕，从执行上下文栈中移除 functionExecutionContext<run>
ECSStack.pop()

// 在程序未结束时， ECSStack 底部永远有一个 globalExecutionContext
```

再看下一个例子：

```js
let scope = 'global scope'
function checkScope() {
  let scope = 'local scope'
  function f() {
    return scope
  }
  return f()
}
checkScope()
```

```js
let scope = 'global scope'
function checkScope() {
  let scope = 'local scope'
  function f() {
    return scope
  }
  return f
}
checkScope()()
```

这两段代码，虽然在执行结果是一样的，都是输出 `local scope`， 但是在 执行上下文栈 中的变化不同。

第一段代码， 在 执行上下文栈，模拟处理如下：

```ts
// 执行checkScope()
ECSStack.push(functionExecutionContext<checkScope>)
// 在checkScope执行阶段中执行 f()
ECSStack.push(functionExecutionContext<f>)

ECSStack.pop()
ECSStack.pop()
```

第二段代码， 在执行上下文栈，模拟处理如下：

```ts
// 执行checkScope()
ECSStack.push(functionExecutionContext<checkScope>)
ECSStack.pop()
// 在checkScope 完成后，再执行 f()
ECSStack.push(functionExecutionContext<f>)
ECSStack.pop()
```

可以看出， 函数执行的时机不同，虽然最终结果一致，但是在 执行上下文栈 中的过程是不同的。

## 总结

1. 执行上下文栈，是用于存储和管理所有执行上下文。
2. 在程序没有结束前，执行栈中永远有一个全局执行上下文。
3. 函数执行时，会创建一个新的函数执行上下文，并按顺序压入到执行栈中。
4. 函数执行完成后，对应的函数执行上下文会从执行栈中移除。

---

---
url: /czxBlog/article/7jzjudus/index.md
---
# 在NodeJs项目中使用ECMAScript module
随着 `Nodejs v16` 成为长期稳定支持的版本，`ESM` 也随之成为 `NodeJs` 正式支持的标准化模块系统，这允许我们通过
`ESM` 来开发我们的 `NodeJs` 项目，并在项目中通过`ESM` 来导入其他的`ESM`包。

## 创建项目

我们以新建一个 NodeJs 项目为例， 它有如下的结构：

```sh
./my-esm-package
├── lib
│   ├── resolve.js
│   └── index.js
└── package.json
```

这个项目的功能是导出一个 resolve 方法，是 `path.resolve` 的封装实现。

::: code-tabs
@tab lib/index.js

```js
export * from './resolve.js'
```

@tab lib/resolve.js

```js
import path from 'node:path'

export const resolve = (...arg) => path.resolve(...arg)
```

:::

## package.json

在 `package.json` 中，我们需要进行以下声明：

* 声明 `type` 字段值为 `module`

  这个字段声明了你的包将作为一个 `ECMAScript module` 被`NodeJs` 加载并解析，并允许使用`.mjs`格式的文件。

* 声明 `exports` 字段

  该字段描述了 项目如何导出模块给到其他包使用。

  * 默认导出

    ::: code-tabs
    @tab package.json

    ```json
    {
      "exports": "./lib/index.js"
    }
    ```

    :::

    即当使用`import { resolve } from 'my-esm-package'`时，默认引入的文件是 `lib/index.js`。

  * 导出多个模块

    ::: code-tabs
    @tab package.json

    ```json
    {
      "exports": {
        ".": "./lib/index.js",
        "resolve": "./lib/resolve.js"
      }
    }
    ```

    :::

    声明了导出了两种模块：一个是默认导出，使用`"."` 作为key；一个是具名导出。

    当使用`import { resolve } from 'my-esm-package'`时，默认引入的文件是 `lib/index.js`。

    当使用`import { resolve } from 'my-esm-package/resolve'` 时，引入的文件是 `lib/resolve.js`。

  * `exports` 还支持其他形式的值，这里暂不赘述。

* 声明 `engines` 字段

  由于 `Nodejs` 并不是全版本支持`esm`的，而是从`v14.16.0`版本开始试验性的支持，并到了`v16`版本才作为正式支持，
  且当前`v16`版本作为目前的长期稳定支持的版本。这个项目运行环境的`NodeJs` 版本，最低应该推荐使用 `v16` 以上的版本。
  即它的值应该为 `{ "node": ">=16" }`

到这里，这个项目的`package.json` 文件，包含以下内容:

::: code-tabs
@tab package.json

```json
{
  "name": "my-esm-package",
  "description": "My first esm package.",
  "type": "module",
  "exports": {
    ".": "./lib/index.js",
    "resolve": "./lib/resolve.js"
  },
  "engines": {
    "node": ">=16"
  }
}
```

:::

## 编写项目代码

1. 由于是一个 `esm` 项目，所以理所当然的不能项目中使用 `require()`/`module.exports` 来导入导出模块。
   而是应该全部使用`import`/`export` 的方式来导入导出模块。

2. 不需要在项目代码中 使用 `use strict`。

3. 由于 `esm` 项目中，`NodeJs` 不再支持 `__dirname`/`__filename`，所以有相关场景需要使用时，需要使用其他的方式来实现相同功能：

```js
import { basename, dirname } from 'node:path'
import { fileURLToPath } from 'node:url'

const _dirname = typeof __dirname !== 'undefined' ? __dirname : dirname(fileURLToPath(import.meta.url))

const _filename = typeof __filename !== 'undefined' ? __filename : basename(fileURLToPath(import.meta.url))
```

## TypeScript

如果在项目中使用了 `TypeScript`，那么除了需要遵循以上的内容，还需要在 `tsconfig.json` 配置文件中补充以下配置：

```json
{
  "module": "node16",
  "moduleResolution": "node16"
}
```

并且，应该将 `.ts` 文件，编译为 `.js` 文件，`package.json` 配置的 `exports` 导出的，是编译后的 `.js` 文件。

## 最后

当完成了以上步骤，就可以得到一个`NodeJs ESM` 项目。它也只能在另一个支持 `esm` 的项目中使用。

---

---
url: /czxBlog/article/84nu27cz/index.md
---
# pnpm 包管理器
`pnpm` 是一款新兴不久的包管理器，相比于 `npm` 和 `yarn`，`pnpm` 拥有更快的安装速度，同时节约磁盘空间。

## 介绍

![pnpm](https://pnpm.io/zh/img/pnpm-no-name-with-frame.svg)

`pnpm` 是一个类似于 `npm` 、`yarn` 的包管理器。

`pnpm` 安装的包都会被存储在硬盘的某个相同位置，软甲包通过硬链接到这个位置，实现共享同一版本的依赖，
对于同一依赖的不同版本，`pnpm update` 时，只会向存储中心添加新版本更新的文件，而不是仅仅应为一个文件的改变而复制整个新版本包的内容。

`pnpm` 内置支持 `monorepo`，即单仓库多包。

## 比较

### pnpm/yarn/npm

| 功能                     |              pnpm              |        yarn        |           npm            |
| ------------------------ | :----------------------------: | :----------------: | :----------------------: |
| 工作空间支持（monorepo） |               ✔️               |         ✔️         |            ✔️            |
| 隔离的`node_modules`     |           ✔️ - 默认            |         ✔️         |            ❌            |
| 提升的`node_modules`     |               ✔️               |         ✔️         |         ✔️ -默认         |
| 自动安装peers            | ✔️ - `auto-install-peers=true` |         ❌         |            ✔️            |
| Plug'n'Play              |               ✔️               |     ✔️ - 默认      |            ❌            |
| 零安装                   |               ❌               |         ✔️         |            ❌            |
| 修复依赖项               |               ✔️               |         ✔️         |            ❌            |
| 管理nodejs版本           |               ✔️               |         ❌         |            ❌            |
| 有锁文件                 |     ✔️ - `pnpm-lock.yaml`      |  ✔️ - `yarn.lock`  | ✔️ - `package-lock.json` |
| 支持覆盖                 |               ✔️               | ✔️ - `resolutions` |            ✔️            |
| 内容可寻址存储           |               ✔️               |         ❌         |            ❌            |
| 动态包执行               |        ✔️ - `pnpm dlx`         |  ✔️ - `yarn dlx`   |        ✔️ - `npx`        |
| Side-effects cache       |               ✔️               |         ❌         |            ❌            |

### 区别

与 `yarn/npm` 不同的是，`pnpm` 并非采用 *扁平的`node_modules`* 来管理依赖项，
而是基于符号链接的`node_modules` 结构。

`node_modules` 中每个包的每个文件都是来自内容可寻址存储的硬链接。 假设安装了依赖于 `bar@1.0.0` 的 `foo@1.0.0`。 `pnpm` 会将两个包硬链接到 `node_modules` 如下所示：

```sh
node_modules
└── .pnpm
    ├── bar@1.0.0
    │   └── node_modules
    │       └── bar -> <store>/bar
    │           ├── index.js
    │           └── package.json
    └── foo@1.0.0
        └── node_modules
            └── foo -> <store>/foo
                ├── index.js
                └── package.json
```

这是 `node_modules` 中的唯一的“真实”文件。 一旦所有包都硬链接到 `node_modules`，
就会创建符号链接来构建嵌套的依赖关系图结构。

`bar` 将被符号链接到 `foo@1.0.0/node_modules` 文件夹，然后处理依赖关系，`foo` 将被符号链接至根目录的 `node_modules` 文件夹:

```sh
node_modules
├── foo -> ./.pnpm/foo@1.0.0/node_modules/foo
└── .pnpm
    ├── bar@1.0.0
    │   └── node_modules
    │       └── bar -> <store>/bar
    └── foo@1.0.0
        └── node_modules
            ├── foo -> <store>/foo
            └── bar -> ../../bar@1.0.0/node_modules/bar
```

这种布局的好处在于，只有真正在依赖项中的包才能访问。
如果是平铺的 `node_modules` 结构，所有被提升的包都可以访问。

### 优势

* 节约磁盘空间

  包存储在全局存储中，pnpm 创建从全局存储到项目下 `node_modules` 文件夹的 硬链接，硬链接指向磁盘上原始文件所在的同一位置。不同软件包可以共享相同依赖项所占用的空间。

  如果是单个依赖的不同版本，如版本更新，`pnpm` 仅安装版本更新的文件，而不是全量安装整个新版本的包。

* 安装速度快

  软件包中安装依赖时，如果检索到在本地的全局存储中已安装过该依赖，那么不会从网络下重新安装，而是直接创建硬链接到软件包中。

* 内置支持 monorepo

  支持 单仓库多包，通过 `pnpm-workspace.yaml` 配置工作空间，通过 `workspace:*` 协议引用工作空间的依赖包。

## 安装

### 通过 npm 安装

```sh
npm install -g pnpm
```

### 通过 Corepack 安装

从 v16.13 开始，Node.js 发布了 `Corepack` 来管理包管理器。 这是一项实验性功能，因此需要通过运行如下脚本来启用它：

```sh
corpack enabled
```

这将自动在系统上安装 pnpm。 但是，它可能不是最新版本的 pnpm。
若要升级，请检查 [最新的 pnpm 版本](https://github.com/pnpm/pnpm/releases/tag/v7.9.1) 并运行：

```sh
corepack prepare pnpm@<version> --activate
```

### 使用独立脚本安装

在 POSIX 系统上，即使没有安装 Node.js，也可以使用以下脚本安装 pnpm：

```sh
curl -fsSL https://get.pnpm.io/install.sh | sh -
```

如果没有安装 `curl` ，也可以使用 `wget`:

```sh
wget -qO- https://get.pnpm.io/install.sh | sh -
```

在 Windows 系统中，如果使用 Powershell:

```sh
iwr https://get.pnpm.io/install.ps1 -useb | iex
```

### 使用 Homebrew 安装

```sh
brew install pnpm
```

### 使用 Scoop 安装

```sh
scoop install nodejs-lts pnpm
```

## 使用

`pnpm` 在使用上 与 `npm` 、`yarn` 的使用上差别不大，但需要注意的区别，`pnpm` 会严格校验所有参数，
比如，`pnpm install --target_arch x64` 会执行失败，因为 `--target_arch x64` 不是 `pnpm install` 的有效参数。

### 常用命令

#### `pnpm install`

别名 `pnpm i`

等效于 `npm install` / `yarn`

用于安装项目所有依赖。

[pnpm install 官方文档](https://pnpm.io/zh/cli/install)

#### `pnpm add <pkg>`

安装软件包及其依赖的任何软件包。 默认情况下，任何新软件包都安装为生产依赖项。

[pnpm add 官方文档](https://pnpm.io/zh/cli/add)

#### `pnpm remove`

别名： `rm` `uninstall` `un`

从 `node_modules` 和项目的 `package.json` 中删除相关 packages。

[pnpm remove 官方文档](https://pnpm.io/zh/cli/remove)

#### `pnpm update`

别名： `up` `upgrade`

`pnpm update` 根据指定的范围更新软件包的最新版本。

在不带参数的情况下使用时，将更新所有依赖关系。 您可以使用一些模式来更新特定的依赖项。

[pnpm update 官方文档](https://pnpm.io/zh/cli/update)

更多命令请查阅[官方文档](https://pnpm.io/zh/cli/add)

### 配置

#### `.npmrc`

`pnpm` 从命令行、环境变量和 `.npmrc` 文件中获取其配置。

`pnpm config` 命令可用于更新和编辑 用户和全局 .npmrc 文件的内容。

四个相关文件分别为：

* 每个项目的配置文件（`/path/to/my/project/.npmrc`）
* 每个工作区的配置文件（包含 `pnpm-workspace.yaml` 文件的目录）
* 每位用户的配置文件（ `~/.npmrc` ）
* 全局配置文件（ `/etc/.npmrc` ）

#### `pnpm-workspace.yaml`

`pnpm-workspace.yaml` 定义了 工作空间 的根目录，并能够使工作空间中包含 / 排除目录 。 默认情况下，包含所有子目录。

```yaml
packages:
  # 定义 packages 目录下的所有子目录都为一个 package
  - 'packages/*'
  # 定义 components 目录下的所有子目录都为一个 package
  - 'components/**'
  # 排除任何目录中的 test 目录下的所有目录
  - '!**/test/**'
```

## 工作空间

pnpm 内置了对单一存储库（也称为多包存储库、多项目存储库或单体存储库）的支持， 你可以创建一个 workspace 以将多个项目合并到一个仓库中。

一个 workspace 的根目录下必须有 `pnpm-workspace.yaml` 文件， 也可能会有 `.npmrc` 文件。

### Workspace 协议 (workspace:)

默认情况下，如果可用的 packages 与已声明的可用范围相匹配，pnpm 将从工作区链接这些 packages。
例如，如果 `bar` 中有 `"foo"："^1.0.0"` 的这个依赖项，则 `foo@1.0.0` 链接到 `bar` 。
但是，如果 `bar` 的依赖项中有 `"foo": "2.0.0"`，而 `foo@2.0.0` 在工作空间中并不存在，则将从 `npm registry` 安装 `foo@2.0.0` 。 这种行为带来了一些不确定性。

幸运的是，pnpm 支持 workspace 协议 `workspace:` 。
当使用此协议时，pnpm 将拒绝解析除本地 workspace 包含的 package 之外的任何内容。
因此，如果设置为 `"foo": "workspace:2.0.0"` 时，安装将会失败，因为 `"foo@2.0.0"` 不存在于此 workspace 中。

使用示例：

工作空间中存在以下项目：

```sh
+ packages/
  + foo/
  + bar/
  + qar/
  + zoo/
```

如果各个项目以其目录名作为其 package name，那么可以在其他项目中如下引入依赖：

```json
{
  "dependencies": {
    "foo": "workspace:*",
    "bar": "workspace:~",
    "qar": "workspace:^",
    "zoo": "workspace:^1.5.0"
  }
}
```

::: tip
引入依赖的包名，是由包的 `package.json name` 确定，而不是 workspace 目录下的目录名确定。
:::

### 发布 Workspace

当以上示例进行发布时，会被转换为

```json
{
  "dependencies": {
    "foo": "1.5.0",
    "bar": "~1.5.0",
    "qar": "^1.5.0",
    "zoo": "^1.5.0"
  }
}
```

这个功能允许你发布转化之后的包到远端，并且可以正常使用本地 workspace 中的 packages，而不需要其它中间步骤。包的使用者也可以像常规的包那样正常使用，且仍然可以受益于语义化版本。

---

---
url: /czxBlog/article/8kq3oe32/index.md
---
# React 渲染机制解析：从调度到提交
## 核心概念回顾

在深入渲染流程前，先回顾 Fiber 架构的三个核心模块：

* **Scheduler（调度器）**：基于任务优先级调度任务执行顺序
* **Reconciler（协调器）**：计算新旧虚拟 DOM 树的差异
* **Renderer（渲染器）**：将更新后的虚拟 DOM 转换为实际 UI

这三个模块共同构成了 React 高效灵活的渲染机制。下面通过完整渲染流程解析它们如何协同工作。

## 整体渲染流程概述

React 渲染流程分为两个关键阶段：

```mermaid
graph LR
    A[Scheduler] --> B[Reconciler]
    B --> C[Renderer]
    style A fill:#b8e0b1,stroke:#388E3C
    style B fill:#a3c1e0,stroke:#1976D2
    style C fill:#e3e14d,stroke:#F57C00
```

1. **Render 阶段（协调阶段）**：Reconciler 负责调用组件渲染方法，构建 Fiber 树
2. **Commit 阶段（渲染阶段）**：Renderer 将变更同步应用到真实 DOM

### 示例场景分析

```jsx
export default function CounterApp() {
  const [count, setCount] = useState(0)

  const increment = () => setCount(prev => prev + 1)

  return (
    <div className="counter">
      <h3>
        当前计数:
        {count}
      </h3>
      <button onClick={increment}>增加</button>
    </div>
  )
}
```

当用户点击按钮触发状态更新时：

1. Scheduler 接收更新任务并调度执行
2. Reconciler 计算变更并标记需要更新的部分
3. Renderer 将变更同步应用到真实 DOM

```mermaid
flowchart LR
  I(点击 button<br>count = count + 1)
  Scheduler(**Scheduler**<br>接收到更新，开始调度<br>*没有更高的优先级更新，把 count=count+1交给Reconciler*)
  Reconciler(**Reconciler**<br>接收到更新，计算更新<br>*h3>0 变更为 h3>1 并打上标记 update，把打了标记的 VDom交给 Renderer*)
  Renderer(**Renderer**<br>接收到更新，根据 update 标记执行操作<br>*h3标记了 update，对其执行 DOM 更新操作*)
  I --> Scheduler
  subgraph 随时可以被中断
  Scheduler --> Reconciler
  end
  Reconciler --> Renderer

  style Scheduler fill:#b8e0b1,stroke:#388E3C
  style Reconciler fill:#a3c1e0,stroke:#1976D2
  style Renderer fill:#e3e14d,stroke:#F57C00
```

## 调度器（Scheduler）工作原理

Scheduler 是 React 16 引入的调度系统，核心作用是管理任务优先级和执行时机。虽然浏览器提供了 `requestIdleCallback` API，但 React 基于以下原因实现了自定义调度器：

1. **浏览器兼容性问题**：部分浏览器不支持 `requestIdleCallback`
2. **触发频率不稳定**：原生 API 受多种因素影响
3. **优先级控制需求**：需要更细粒度的任务优先级管理

```mermaid
flowchart TD
    A[高优先级任务] --> B[调度队列]
    C[低优先级任务] --> B
    B --> D{当前帧是否有空闲时间？}
    D -- 是 --> E[执行任务]
    D -- 否 --> F[等待下一帧]
```

Scheduler 采用 **时间切片（Time Slicing）** 技术，将任务分解为小块，在浏览器空闲时执行，避免阻塞主线程。

## 协调器（Reconciler）与 Render 阶段

### 可中断的协调过程

React 16 将协调过程从递归改为可中断的循环：

```js
// 同步模式工作循环
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress)
  }
}

// 并发模式工作循环
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress)
  }
}
```

* `workInProgress`：当前正在处理的 Fiber 节点
* `shouldYield()`：检查当前帧是否有剩余时间
* `performUnitOfWork()`：处理当前 Fiber 节点并连接后续节点

### Fiber 节点处理流程

`performUnitOfWork` 采用深度优先遍历（DFS）策略，分为两个阶段：

```mermaid
sequenceDiagram
    participant Root
    participant A as 组件A
    participant B as 组件B
    participant C as 组件C
    participant D as 叶子组件

    Root->>A: beginWork（递）
    A->>B: beginWork（递）
    B->>C: beginWork（递）
    C->>D: beginWork（递）
    D-->>C: completeWork（归）
    C-->>B: completeWork（归）
    B->>A: 同级节点处理
    A-->>Root: completeWork（归）
```

1. **递阶段（beginWork）**：

   * 从根节点开始深度优先遍历
   * 为每个 Fiber 节点调用 `beginWork`
   * 创建子节点并建立连接
   * 到达叶子节点后进入归阶段

2. **归阶段（completeWork）**：

   * 收集副作用（如 DOM 更新需求）
   * 存在兄弟节点则进入兄弟节点的递阶段
   * 不存在兄弟节点则返回父节点继续归阶段
   * 最终回到根节点完成协调

::: info **设计细节**
Fiber 节点指向父节点的字段名为 `return` 而非 `parent`，因为从子节点角度看，完成工作后是"返回"到父节点继续工作。
:::

## 渲染器（Renderer）与 Commit 阶段

当协调阶段完成，进入不可中断的 Commit 阶段。此阶段将协调结果提交到真实 DOM，分为三个子阶段：

```mermaid
flowchart TD
    A[Commit 阶段] --> B[Before Mutation]
    B --> C[Mutation]
    C --> D[Layout]
    D --> E[结束]
```

### 1. Before Mutation 阶段（DOM 操作前）

* 处理 DOM 渲染/删除后的自动聚焦逻辑
* 调用 `getSnapshotBeforeUpdate` 生命周期
* 调度 `useEffect`

### 2. Mutation 阶段（执行 DOM 操作）

* 根据协调结果执行 DOM 增删改操作
* 解绑旧节点的 ref 引用
* 执行函数组件的销毁清理函数

### 3. Layout 阶段（DOM 操作后）

* 绑定新节点的 ref 引用
* 调用 `componentDidMount`/`componentDidUpdate`
* 执行 `useLayoutEffect` 回调

### 完整 Commit 流程

```mermaid
sequenceDiagram
    participant React
    participant DOM

    React->>DOM: Before Mutation
    Note over React: 准备阶段操作
    React->>DOM: Mutation（DOM 操作）
    Note over DOM: 实际DOM更新
    React->>DOM: Layout
    Note over React: 布局相关操作
    React->>React: 后续处理
    Note over React: useEffect调度等
```

## 关键设计优势

1. **可中断渲染**：
   * Scheduler 和 Reconciler 工作可被高优先级任务中断
   * 所有计算在内存中进行，不会显示中间状态

2. **双缓存机制**：
   * 内存中同时存在两棵 Fiber 树（current 和 workInProgress）
   * 减少界面闪烁，提升用户体验

3. **副作用隔离**：
   * 协调阶段收集副作用（effect）
   * 提交阶段统一执行副作用

## 总结

React 的渲染流程通过精密的模块化设计实现高效渲染：

1. **Scheduler** 智能调度任务，优先处理用户交互
2. **Reconciler** 使用可中断的 DFS 遍历计算变更
3. **Renderer** 通过三阶段提交保证 DOM 更新一致性

```mermaid
flowchart TD
    A[交互事件] --> B[Scheduler]
    B --> C{高优先级?}
    C -- 是 --> D[中断当前任务]
    C -- 否 --> E[Reconciler]
    E --> F[Render阶段]
    F --> G[Commit阶段]
    G --> H[DOM更新]
```

这种架构使 React 能够平衡响应性和性能，在复杂应用场景下仍能保持流畅的用户体验。理解这些底层机制对于优化 React 应用性能和解决渲染相关问题至关重要。

---

---
url: /czxBlog/article/8rv45yuy/index.md
---
# HTML5新特性
## 语义标签

如 `<header>` `<footer>` `<nav>` `<section>` `<article>` `<aside>` `<details>` `<summary>`
`<dialog>` `<figure>` `<main>` `<mark>` `<time>` `<hgroup>` 等

## 增强型表单

### 新增表单元素

`<detailist>` ：数据列表，为input提供输入建议列表

`<progress>`：进度条，展示连接/下载进度

`<meter>`：刻度尺/度量衡，描述数据所处的阶段，红色(危险)=>黄色(警告)=>绿色(优秀)

`<output>`：输出内容，语义上表示此处的数据是经过计算而输出得到的

其他

### 新增表单属性

placehoder： 输入框默认提示文字

required： 要求输入的内容是否可为空

pattern： 描述一个正则表达式验证输入的值

min/max： 设置元素最小/最大值

step： 为输入域规定合法的数字间隔

height/wdith： 用于image类型`<input>`标签图像高度/宽度

autofocus： 规定在页面加载时，域自动获得焦点

multiple： 规定`<input>`元素中可选择多个值

### 新增 input type 类型

color： 颜色选取

date： 日期选择

datetime： 日期选择（UTC时间）

datetime-local： 日期选择（无时区）

month： 月份选择

week： 周和年 选择

time： 选择时间

email： 包含 email的地址输入域

number: 数值选择

url： url输入域

tel： 电话号码和字段

search： 搜索域

range： 数字范围输入域

## 视频和音频

`<audio>` 音频元素

```html
<audio controls>
  <source src="horse.ogg" type="audio/ogg" />
  <source src="horse.mp3" type="audio/mpeg" />
  您的浏览器不支持 audio 元素
</audio>
```

`<video>` 视频元素

```html
<video width="320" height="240" controls>
  <source src="movie.mp4" type="video/mp4" />
  <source src="movie.ogg" type="video/ogg" />
  您的浏览器不支持Video标签。
</video>
```

## Canvas绘图

`<canvas>` 是 HTML5 新增的，一个可以使用脚本(通常为 JavaScript) 在其中绘制图像的 HTML 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。

[](https://www.runoob.com/w3cnote/html5-canvas-intro.html)

## 地理位置

使用getCurrentPosition()方法来获取用户的位置。以实现“LBS服务”

```js
// 监听地理位置变化
window.navigator.geolocation.watchPosition((pos) => {})
// 清除地理位置变化监听
window.navigator.geolocation.clearWatch()
window.navigator.geolocation.getCurrentPosition((pos) => {
  // '定位成功'
  // 定位时间：pos.timestamp
  // 维度：pos.coords.latitude
  // 经度：pos.coords.longitude
  // 海拔：pos.coords.altitude
  // 速度：pos.coods.speed
}, (err) => {
  // '定位失败'
  console.error(err)
})
```

## 拖放API

### 拖动的源对象(source)可能触发的事件

**dragstart**：拖动开始

**drag**：拖动中

**dragend**：拖动结束

### 拖动的目标对象(target)可能触发的事件

**dragenter**：拖动进入

**dragover**：拖动悬停

**drop**：松手释放

**dragleave**：拖动离开

拖放API事件句柄中所有的事件对象都有一个dataTransfer属性（数据运输对象），用于在源对象和目标对象间传递数据。

**源对象**：event.dataTransfer.setData(key, value)

**目标对象**：var value = event.dataTransfer.getData(key)

## WebWorker

[使用 Web Workers - Web API 接口参考 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)

### 背景

Chrome浏览器中发起资源请求的有6个线程；但是只有1个线程负责渲染页面——称为UI主线程——浏览器中所有的代码只能由一个线程来执行。

### 问题

若浏览器加载了一个很耗时的JS文件(可能影响DOM树结构)，浏览器必须等待该文件执行完成才会继续执行后续的代码(HTML/CSS/JS等)——如果一个JS文件要执行10s(可能有很深的循环/递归等科学计算/解密)，会发生什么？——执行耗时JS任务过程中，会暂停页面中一切内容的渲染以及事件的处理。

### 作用

一个执行指定任务的独立线程；且该线程可以与UI主线程进行消息数据传递。

使用方式：

```jsx
// 主线程
let worker = new Worker('xx.js')
worker.postMessage('message') // 发送消息到worker线程
worker.onmessage = function (e) {
  console.log(e.data) // 来自worker线程的信息
}

// worker线程
onmessage = function (e) {
  console.log(e.data) // 接收主线程的消息

  postMessage('message') // 发送消息到主线程
}
```

### 共享 worker

一个共享worker可以被多个脚本使用——即使这些脚本正在被不同的window、iframe或者worker访问。

> 如果共享worker可以被多个浏览上下文调用，所有这些浏览上下文必须属于同源（相同的协议，主机和端口号）。

```js
let myWorker = new SharedWorker('worker.js')

// 主线程中调用
myWorker.port.start()

myWorker.port.postMessage('message')

myWorker.port.onmessage = function (e) {
  console.log('Message received from worker')
}

// worker 线程调用
port.start()
// worker 需要在 onconnect事件处理函数来执行代码
onconnect = function (e) {
  let port = e.ports[0]

  port.onmessage = function (e) {
    let workerResult = `Result: ${e.data}`
    port.postMessage(workerResult)
  }
}
```

## WebStorage

### localStorage

本地跨会话级，持久化存储

### sessionStorage

会话级存储

## WebSocket

在用户的浏览器和服务器之间打开交互式通信会话。

```js
const ws = new WebSocket('wx://xx')
ws.onopen = function () {}
ws.onmessage = function (e) {
  console.log(e.data)
}
```

## History API

对history栈中内容进行操作。

### pushState(stateObj, title, url)

```js
history.pushState({}, 'foo', 'foo.html')
```

添加历史记录条目

### replaceState(stateObj, title, url)

```js
history.replaceState({}, 'bar', 'bar.html')
```

修改历史记录条目，浏览器不会检查替换的路径是否存在。

### popState 事件

每当活动的历史记录项发生变化时， popstate 事件都会被传递给window对象。如果当前活动的历史记录项是被 pushState 创建的，或者是由 replaceState 改变的，那么 popstate 事件的状态属性 state 会包含一个当前历史记录状态对象的拷贝。

### 获取当前状态

页面加载时，或许会有个非null的状态对象。
这是有可能发生的，举个例子，假如页面（通过pushState() 或 replaceState() 方法）设置了状态对象而后用户重启了浏览器。
那么当页面重新加载时，页面会接收一个onload事件，但没有 popstate 事件。
然而，假如你读取了history.state属性，你将会得到如同popstate 被触发时能得到的状态对象。

```js
// 尝试通过 pushState 创建历史条目,然后再刷新页面查看state状态对象变化;
window.addEventListener('load', () => {
  let currentState = history.state
  console.log('currentState', currentState)
})
```

[History API - Web API 接口参考 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API)

---

---
url: /czxBlog/article/8vac55c7/index.md
---
# vite插件推荐
本文列出了一些在工作中常会用到的、比较好用的 `vite` 插件。

## Framework

### Vue

* [@vitejs/plugin-vue](https://github.com/vitejs/vite/tree/main/packages/plugin-vue) - `vue3` 官方支持。
* [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite/tree/main/packages/plugin-vue-jsx) - `vue3` JSX 语法插件，官方支持
* [@vitejs/plugin-vue2](https://github.com/vitejs/vite-plugin-vue2) - vue2 支持
* [vite-plugin-pages](https://github.com/hannoeru/vite-plugin-pages) - 基于文件系统自动创建路由。
* [unplugin-vue-i18n](https://github.com/intlify/bundle-tools/tree/main/packages/unplugin-vue-i18n) - `vue-i18n` 国际化方案的配套插件

### React

* [@vitejs/plugin-react](https://github.com/vitejs/vite/tree/main/packages/plugin-react) - `React` 官方支持
* [vite-plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) - 使用 `swc` 编译 `React`，速度更快

### Preact

* [@preact/preset-vite](https://github.com/preactjs/preset-vite) - `preact` 支持

### Electron

* [electron-vite](https://github.com/alex8088/electron-vite) - `electron` 支持

### Tauri

* [vite-plugin-tauri](https://github.com/amrbashir/vite-plugin-tauri) - `Tauri` 支持

## 常用

* [vite-tsconfig-paths](https://github.com/aleclarson/vite-tsconfig-paths) - 支持 `tsconfig.json`的 `paths` mapping
* [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect) - 审查`vite-plugin`中间状态
* [vite-plugin-mock-dev-server](https://github.com/pengzhanbo/vite-plugin-mock-dev-server) - 在 vite
  开发服务中注入 `mock-server` ，提供 `API Mock data` 支持
* [unplugin-icons](https://github.com/antfu/unplugin-icons) - 将 icons 资源转化为组件
* [vite-plugin-windicss](https://github.com/windicss/vite-plugin-windicss) - widicss 支持
* [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) - 低版本浏览器支持
* [unplugin-auto-import](https://github.com/antfu/unplugin-auto-import) - 自动导入模块
* [vite-plugin-remove-console](https://github.com/xiaoxian521/vite-plugin-remove-console) - 可配置的删除代码中的 `console`

## 其他

### WASM

* [vite-plugin-wasm-pack](https://github.com/nshen/vite-plugin-wasm-pack) - rust `wasm-pack` 支持

### Federation

* [vite-plugin-federation](https://github.com/originjs/vite-plugin-federation) - 提供模块联邦支持

### PWA

* [vite-plugin-pwa](https://github.com/antfu/vite-plugin-pwa) - 提供 PWA 支持

---

---
url: /czxBlog/article/8vev8ixl/index.md
---
# CSS选择器
## Basic Selectors 基础选择器

### Element selector

根据 element type 匹配 一组元素

```html
...
<style>
  p {
    color: red;
  }
</style>
...
<p>content</p>
...
```

### Class selector

根据 element 声明的 class属性值 匹配一组元素

```html
...
<style>
  .red {
    color: red;
  }
</style>
...
<p class="red">content</p>
...
```

### ID selector

根据 element 声明的 ID属性值，匹配一个元素（一个页面中，ID具有唯一性）

```html
...
<style>
  #red {
    color: red;
  }
</style>
...
<p id="red">content</p>
...
```

### Universal selector

通配符，匹配所有 element

```html
...
<style>
  * {
    color: red;
  }
</style>
...
<p>content</p>
<span>span</span>
...
```

## Attribute Selectors

### \[attribute] selector

匹配声明了该attribute的 一组 element

```html
...
<style>
  [href] {
    color: red;
  }
</style>
...
<a href="">content</a>
...
```

### \[attribute="x"] selector

匹配声明了该attribute，且值为 x 的一组 element

```html
...
<style>
  [title='a'] {
    color: red;
  }
</style>
...
<abbr title="a">abbr</abbr>
...
```

### \[attribute~="x"] selector

匹配声明了该attribute，且值包含了 单词 x 的一组 element

```html
...
<style>
  [title~='style'] {
    color: red;
  } /* 匹配包含了 独立单词  style 的 element， */
</style>
...
<abbr title="sheet style">abbr</abbr>
<abbr title="sheetstyle"></abbr>
<!-- no match -->
...
```

### \[attribute|="x"] selector

匹配声明了该attribute，且值包含了一个 `x-` 开头的连字符拼接的词 的一组 element

```html
...
<style>
  /* lang的值必须 包含 en 通过连接符 - 连接另一个单词的 词 */
  [lang|='en'] {
    color: red;
  }
</style>
...
<abbr lang="en-US">abbr</abbr>
<!-- no match  lang="en" lang="enUS" -->
...
```

### \[attribute^="x"] selector

匹配声明了该attribute，且值是以 x 作为开头的 一组 element

```html
...
<style>
  [href^="https://"]
  {
    color: red;
  }
</style>
...
<a href="https://example.com">content</a>
...
```

### \[attribute$="x"] selector

匹配声明了该attribute，且值是以 x 作为结尾的 一组 element

```html
...
<style>
  [href$='.pdf'] {
    color: red;
  }
</style>
...
<a href="https://example.com/a.pdf">content</a>
...
```

### \[attribute\*="x"] selector

匹配声明了该attribute，且值包含了子串 x 的 一组 element

```html
...
<style>
  [href*='example'] {
    color: red;
  }
</style>
...
<a href="https://example.com">content</a>
...
```

## Combinators 关系选择器

关系选择器适用于 任意选择器 的组合

### selector1 selector2 后代关系选择器

匹配 selector1 的元素中，所有 selector2 的 元素

```html
...
<style>
  section span {
    color: red;
  }
</style>
...
<section>
  <span></span>
  <!-- match -->
  <p><span></span></p>
  <!-- match -->
</section>
...
```

### selector1 > selector2 子代关系选择器

匹配 selector1 的下一级满足 selector2 的 一组元素

```html
...
<style>
  section > span {
    color: red;
  }
</style>
...
<section>
  <span></span>
  <!-- match -->
  <p><span></span></p>
  <!--  no match -->
</section>
...
```

### selector1 + selector2 相邻兄弟选择器

匹配selector1后同级的紧跟的selector2的一个元素

```html
...
<style>
  h2 + p {
    color: red;
  }
</style>
...
<p></p>
<!--  no match -->
<h2></h2>
<p></p>
<!-- match -->
<p></p>
<!--  no match -->
...
```

### selector ~ selector2 一般兄弟选择器

匹配selector1后同级的selector2的一组元素

```html
...
<style>
  h2 ~ p {
    color: red;
  }
</style>
...
<p></p>
<!--  no match -->
<h2></h2>
<p></p>
<!-- match -->
<p></p>
<!-- match -->
<span></span>
<p></p>
<!-- match -->
...
```

## Group Selectors 组合选择器

### selector1, selector2

匹配用`,` 隔开的所有选择器

```html
...
<style>
  p,
  span {
    color: red;
  }
</style>
...
<section>
  <span></span>
  <p><span></span></p>
</section>
...
```

## Pseudo-elements 伪元素选择器

### ::first-letter

匹配 element中的首个字符（字母、中文字、符号均可）

```html
...
<style>
  p::first-letter {
    color: red;
  }
</style>
...
<p>One</p>
<!-- match: O -->
...
```

### ::first-line

匹配 element中的首行文字

```html
...
<style>
  p::first-line {
    color: red;
  }
</style>
...
<p>
  One Two <br />
  <!-- match -->
  Three
</p>
...
```

### ::before

和 `content` 属性一起使用，在匹配的元素内容之前生成的内容

```html
...
<style>
  p::before {
    content: 'before ';
  }
</style>
...
<p>
  One Two
  <!-- render: before One Two -->
</p>
...
```

### ::after

和 `content` 属性一起使用，在匹配的元素内容之后生成的内容

```html
...
<style>
  p::after {
    content: ' after';
  }
</style>
...
<p>
  One Two
  <!-- render: One Two after -->
</p>
...
```

## Pseudo-classes 伪类选择器

### :link

匹配一个没有被访问过的链接

```html
...
<style>
  a:link {
    color: red;
  }
</style>
...
<a href="">link</a>
...
```

### :visited

匹配一个已访问过的链接

```html
...
<style>
  a:visited {
    color: red;
  }
</style>
...
<a href="">link</a>
...
```

### :active

匹配一个正在被激活的链接

```html
...
<style>
  a:active {
    color: red;
  }
</style>
...
<a href="">link</a>
...
```

### :hover

匹配一个被光标悬停的链接

```html
...
<style>
  a:hover {
    color: red;
  }
</style>
...
<a href="">link</a>
...
```

### :focus

匹配一个具有焦点的元素

```html
...
<style>
  input:focus {
    color: red;
  }
</style>
...
<input type="text" />
...
```

### :target

匹配一个已被链接到的元素。
例如通过`<a href="#heading"></a>`链接的head元素

```html
...
<style>
  h2:target {
    color: red;
  }
</style>
...
<h2 id="heading">heading</h2>
...
```

### :first-child

匹配在同一个父元素内的的第一个子元素

```html
...
<style>
  p:first-child {
    color: red;
  }
</style>
...
<p>first child</p>
<!-- match -->
<p>second child</p>
...
```

### :last-child

匹配在同一个父元素内的的最后一个子元素

```html
...
<style>
  p:last-child {
    color: red;
  }
</style>
...
<p>first child</p>
<p>last child</p>
<!-- match -->
...
```

### :nth-child(n)

匹配在同一个父元素内的从上往下数的第N子个元素

```html
...
<style>
  p:nth-child(2) {
    color: red;
  }
</style>
...
<p>first child</p>
<p>second child</p>
<!-- match -->
...
```

### :nth-last-child(n)

匹配在同一个父元素内的从下往上数的第N个子元素

```html
...
<style>
  p:nth-last-child(2) {
    color: red;
  }
</style>
...
<p>first child</p>
<!-- match -->
<p>second child</p>
...
```

### :first-of-type

匹配在同一个父元素中的同类型的第一个元素

```html
...
<style>
  p:first-of-type {
    color: red;
  }
</style>
...
<p>first child</p>
<!-- match -->
<p>second child</p>
...
```

### :last-of-type

匹配在同一个父元素中的同类型的最后一个元素

```html
...
<style>
  p:last-of-type {
    color: red;
  }
</style>
...
<p>first child</p>
<!-- match -->
<p>second child</p>
...
```

### :nth-of-type(n)

匹配在同一个父元素中的同类型的从上往下数的第N个元素

```html
...
<style>
  p:nth-of-type(2) {
    color: red;
  }
</style>
...
<p>first child</p>
<p>second child</p>
<!-- match -->
...
```

### :nth-last-of-type(n)

匹配在同一个父元素中的同类型的从下往上数的第N个元素

```html
...
<style>
  p:nth-last-of-type(2) {
    color: red;
  }
</style>
...
<p>first child</p>
<!-- match -->
<p>second child</p>
...
```

### :only-child

如果元素是其父元素的唯一子元素，则匹配该元素

```html
...
<style>
  section p:only-child {
    color: red;
  }
</style>
...
<section>
  <p>only child</p>
</section>
...
```

### :only-type

如果元素是其父元素的唯一的同类型的子元素，则匹配该元素

```html
...
<style>
  section p:only-of-type {
    color: red;
  }
</style>
...
<section>
  <p>only</p>
  <!-- match -->
  <span></span>
</section>
...
```

### :lang(lang)

匹配给定语言的元素

```html
...
<style>
  div:lang(fr) {
    color: red;
  }
</style>
...
<section>
  <div lang="fr">
    <q>This French quote has a <q>nested</q> quote inside.</q>
  </div>
</section>
...
```

### :empty

匹配没有子元素或内容的元素

```html
...
<style>
  div:empty {
    background-color: red;
  }
</style>
...
<section>
  <div></div>
</section>
...
```

### :root

匹配文档的根元素， （即匹配的 `<html>`元素）

### :enabled

匹配未被禁用的表单控件元素

### :disabled

匹配被禁用的表单控件元素

### :checked

匹配选中的单选或复选框类型的输入元素。

### :not(selector)

协商伪类。匹配不匹配选择器的元素。

## 实验中的 Selectors

这些选择器在某些浏览器中尚处于开发中，功能对应的标准文档可能被修改，在未来的版本中可能发生变化，谨慎使用。

### :any-link

匹配有链接锚点的元素，而不管元素是否被访问过。
即会匹配每一个有 `href`属性的`<a>`，`<area>`，`<link>`的元素，匹配到所有的`:link`或`:visited`。

```html
...
<style>
  a:any-link {
    border: 1px solid blue;
    color: orange;
  }
</style>
...
<a href="https://example.com">External link</a><br />
<a href="#">Internal target link</a><br />
<a>Placeholder link (won't get styled)</a>
...
```

@[caniuse](css-any-link)

### :dir(dir)

如果元素的内容的书写方向是 dir , 则匹配该元素

*dir* : ltr | rtl

```html
...
<style>
  :dir(ltr) {
    background-color: yellow;
  }

  :dir(rtl) {
    background-color: powderblue;
  }
</style>
...
<div dir="rtl">
  <span>test1</span>
  <div dir="ltr">
    test2
    <div dir="auto">עִבְרִית</div>
  </div>
</div>
...
```

@[caniuse](css-dir-pseudo)

### :has(selector)

如果一个元素A恰好满足包含了selector 匹配的元素，则匹配元素A

```html
...
<style>
  a:has(> img) {
    background-color: yellow;
  }
</style>
...
<a><img src="example.jpg" /></a>
<!-- match -->
<a></a>
...
```

@[caniuse](css-has)

### :is() / :any()

匹配一组选择器选中的元素。

优先级是由它的选择器列表中优先级最高的选择器决定。

```html
...
<style>
  :is(header, main, footer) p:hover {
    color: red;
    cursor: pointer;
  }
</style>
...
<!-- 等价于 -->
<style>
  header p:hover,
  main p:hover,
  footer p:hover {
    color: red;
    cursor: pointer;
  }
</style>
...
```

@[caniuse](css-matches-pseudo)

### :where()

匹配一组选择器选中的元素。

:where() 的优先级总是为 0。

```html
...
<style>
  :where(header, main, footer) p:hover {
    color: red;
    cursor: pointer;
  }
</style>
...
<!-- 等价于, 但优先级不同 -->
<style>
  header p:hover,
  main p:hover,
  footer p:hover {
    color: red;
    cursor: pointer;
  }
</style>
...
```

---

---
url: /czxBlog/article/96gtr7pj/index.md
---
# 前端优化之状态压缩
一个很常见的场景，在页面埋点的上报数据中，保存着多个状态，直接传输这组状态可能数据体积较大。
此时我们可以考虑使用 **二进制** 的方式进行优化。

## 为什么需要状态压缩？

在现代前端监控中，我们经常需要上报用户行为数据：

```json
{
  "isFirstView": true,
  "isHugeDocument": false,
  "isLoggedIn": true,
  "isMobile": true,
  "isDarkMode": false,
  "isSubscribed": true
  // ...
}
```

这样的JSON结构虽然可读性好，但存在两个致命问题：

* **数据冗余**：键名重复占用大量空间
* **传输成本**：每个状态至少占用5-10字节

当每日PV达到百万级时，这些冗余数据会让：

* 用户消耗更多流量
* 服务器承受更大压力
* 分析延迟增加

## 二进制位运算

想象有一排开关，每个开关控制一个状态：

```txt
   [开]     |    [关]        |   [开]     |   [开]   |   [关]     |   [开]
isFirstView | isHugeDocument | isLoggedIn | isMobile | isDarkMode | isSubscribed
```

计算机用 **二进制** 表示这些开关状态：

```txt
101101
```

如果我们将这个二进制转换为 十进制，那么就是：

```txt
45
```

可以发现，从原本的JSON 数据需要的大量字节空间压缩到了 **两个字节**。

这个神奇转换就是 **位掩码技术** 的核心！

那么我们如何将状态转换为二进制？以及如何从二进制中还原状态？

我们知道，在位运算中有三种常见的操作：

* **左移（`<<`）**

  [MDN - 运算符 - 左移](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Left_shift){.read-more}

  **左移操作符 (<<)** 将第一个操作数向左移动指定位数，左边超出的位数将会被清除，右边将会补零。

  ```ts
  const A = 1 << 0 // 000001 = 1
  const B = 1 << 1 // 000010 = 2
  const C = 1 << 2 // 000100 = 4
  ```

* **按位或 (`|`)**

  [MDN - 运算符 - 按位或](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_OR){.read-more}

  **按位或（|）** 运算符在其中一个或两个操作数对应的二进制位为 1 时，该位的结果值为 1。

  ```ts
  const AorB = A | B // 000011 = 3
  const BorC = A | B // 000110 = 6
  const AorBorC = A | B | C // 000111 = 7
  ```

* **按位与 (`&`)**

  [MDN - 运算符 - 按位与](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_AND){.read-more}

  **按位与（&）** 运算符在两个操作数对应的二进位都为 1 时，该位的结果值才为 1。

  ```ts
  const hasB = AorB & B // 000010 = 2
  const hasC = AorB & C // 000000 = 0
  ```

由此，我们可以：

* 通过 **左移** 运算，为不同的状态分配不同的二进制位。
* 通过 **按位或** 运算，将不同状态的二进制位进行合并。
* 通过 **按位与** 运算，判断合并后的二进制位是否有对应的状态。

## 实现方法

### 定义每个状态的二进制位

```ts
interface State {
  isFirstView: boolean
  isHugeDocument: boolean
  isLoggedIn: boolean
  isMobile: boolean
  isDarkMode: boolean
  isSubscribed: boolean
}

const STATE_MAP: Record<keyof State, number> = {
  isFirstView: 1 << 0,
  isHugeDocument: 1 << 1,
  isLoggedIn: 1 << 2,
  isMobile: 1 << 3,
  isDarkMode: 1 << 4,
  isSubscribed: 1 << 5,
}
```

### 状态压缩器

```ts
/**
 * 合并状态
 * @returns combinedState 合并后的状态
 */
function combineStates(state: Partial<State>): number {
  return (Object.keys(state) as (keyof typeof STATE_MAP)[]).reduce((combinedStates, key) => {
    return state[key] ? combinedStates | STATE_MAP[key] : combinedStates
  }, 0)
}
```

### 状态还原器

```ts
/**
 * 判断状态是否存在
 */
function hasState(combinedState: number, state: number): boolean {
  return (combinedState & state) === state
}

/**
 * 还原状态
 */
function restoreStates(combinedState: number): State {
  return (Object.keys(STATE_MAP) as (keyof typeof STATE_MAP)[]).reduce((result, key) => {
    result[key] = hasState(combinedState, STATE_MAP[key])
    return result
  }, {} as State)
}
```

### 使用示例

客户端压缩状态：

```ts
// 用户当前状态
const state: State = {
  isFirstView: false,
  isHugeDocument: false,
  isLoggedIn: true,
  isMobile: true,
  isDarkMode: true,
  isSubscribed: false
}
// 合并状态
const combinedState = combineStates(state) // 011100 = 28
```

后台服务还原状态:

```ts
restoreStates(combinedState /* 011100 = 28 */)
// 输出： {
//  isFirstView: false,
//  isHugeDocument: false,
//  isLoggedIn: true,
//  isMobile: true,
//  isDarkMode: true,
//  isSubscribed: false
// }
```

## 性能对比

假设有20个状态需要上报：

| 指标           | JSON格式 | 二进制压缩 | 优化效果 |
| -------------- | -------- | ---------- | -------- |
| 数据大小       | ~200字节 | 4字节      | 98%      |
| 百万次传输成本 | 200MB    | 4MB        | 98%      |

::: tip 在 Chrome 性能测试中，位运算操作比JSON解析快100倍以上
:::

## 注意事项

* **32位限制**：JavaScript位运算使用32位整数，最多支持31个状态（第32位是符号位）

  ```ts
  // 错误示例：超出32位
  const invalidStatus = 1 << 32
  ```

* **扩展性**：新增状态只需新增 `STATE_MAP` 键值对

  ```ts
  const STATE_MAP = {
    // ...
    isVip: 1 << 6,
  }
  ```

* **数据传输格式**：推荐使用紧凑结构

  ```ts
  // 优化后的上报数据结构
  const reportData = {
    t: Date.now(), // 时间戳
    u: 'user123', // 用户ID
    s: compressedStatus // 压缩状态
  }
  ```

## 总结

**位运算** 就像程序员的瑞士军刀——在特定场景下能发挥惊人效果。

下次当你面对膨胀的埋点数据时，不妨试试这个二进制方法。毕竟，在编程世界里，有时候 **少即是多，小即是美** ！

---

---
url: /czxBlog/article/bp1nxjs6/index.md
---
# meta 标签说明
&#x20;标签提供关于 HTML 文档的元数据。它不会显示在页面上，但是对于机器是可读的。可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。

## 定义

提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。

## 用法

标签位于文档的头部，不包含任何内容。 标签的属性定义了与文档相关联的名称/值对。

## 属性

|    属性    | 是否可选 | 描述                                         |
| :--------: | :------: | :------------------------------------------- |
|  content   |   必选   | 定义与 http-equiv 或 name 属性相关的元信息。 |
| http-equiv |   可选   | 把 content 属性关联到 HTTP 头部。            |
|    name    |   可选   | 把 content 属性关联到一个名称。              |
|  charset   |   可选   | 定义编码格式                                 |

## 常用meta标签说明

### charset

charset是声明文档使用的字符编码，主要用于解决编码问题导致的乱码。 charset一定要写在第一行。

两种charset的写法

```html
<meta charset="utf-8" /> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
```

## viewport

viewport主要是影响移动端页面布局

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
```

**content 参数：**

1. **width**： viewport 宽度(数值/device-width)
2. **height**： viewport 高度(数值/device-height)
3. **initial-scale**： 初始缩放比例
4. **maximum-scale**： 最大缩放比例
5. **minimum-scale**： 最小缩放比例
6. **user-scalable**： 是否允许用户缩放(yes/no)

### SEO优化相关

```html
<!-- 页面标题<title>标签(head 头部必须) -->
<title>your title</title>
<!-- 页面关键词 keywords -->
<meta name="keywords" content="your keywords" />
<!-- 页面描述内容 description -->
<meta name="description" content="your description" />
<!-- 定义网页作者 author -->
<meta name="author" content="author,email address" />
<!-- 定义网页搜索引擎索引方式，robotterms 是一组使用英文逗号「,」分割的值，
通常有如下几种取值：none，noindex，nofollow，all，index和follow。 -->
<meta name="robots" content="index,follow" />
```

**robots具体参数如下：**

1. none : 搜索引擎将忽略此网页，等价于noindex，nofollow。
2. noindex : 搜索引擎不索引此网页。
3. nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。
4. all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。
5. index : 搜索引擎索引此网页。
6. follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。

### 移动端常用的meta

```html
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<!-- 删除苹果默认的工具栏和菜单栏 -->
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<!-- 设置苹果工具栏颜色 -->
<meta name="format-detection" content="telphone=no, email=no" />
<!-- 忽略页面中的数字识别为电话，忽略email识别 -->

<!-- 启用360浏览器的极速模式(webkit) -->
<meta name="renderer" content="webkit" />
<!-- 避免IE使用兼容模式 -->
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->
<meta name="HandheldFriendly" content="true" />
<!-- 微软的老式浏览器 -->
<meta name="MobileOptimized" content="320" />
<!-- uc强制竖屏 -->
<meta name="screen-orientation" content="portrait" />
<!-- QQ强制竖屏 -->
<meta name="x5-orientation" content="portrait" />
<!-- UC强制全屏 -->
<meta name="full-screen" content="yes" />
<!-- QQ强制全屏 -->
<meta name="x5-fullscreen" content="true" />
<!-- UC应用模式 -->
<meta name="browsermode" content="application" />
<!-- QQ应用模式 -->
<meta name="x5-page-mode" content="app" />
<!-- windows phone 点击无高光 -->
<meta name="msapplication-tap-highlight" content="no" />
```

### 百度禁止转码

百度会自动对网页进行转码，这个标签是禁止百度的自动转码

```html
<meta http-equiv="Cache-Control" content="no-siteapp" />
```

### Microsoft Internet Explorer

```html
<!-- 优先使用最新的ie版本 -->
<meta http-equiv="x-ua-compatible" content="ie=edge" />
<!-- 是否开启cleartype显示效果 -->
<meta http-equiv="cleartype" content="on" />
<meta name="skype_toolbar" content="skype_toolbar_parser_compatible" />

<!-- Pinned Site -->
<!-- IE 10 / Windows 8 -->
<meta name="msapplication-TileImage" content="pinned-tile-144.png" />
<meta name="msapplication-TileColor" content="#009900" />
<!-- IE 11 / Windows 9.1 -->
<meta name="msapplication-config" content="ieconfig.xml" />
```

### Google Chrome

```html
<!-- 优先使用最新的chrome版本 -->
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<!-- 禁止自动翻译 -->
<meta name="google" value="notranslate" />
```

### 360浏览器

```html
<!-- 选择使用的浏览器解析内核 -->
<meta name="renderer" content="webkit|ie-comp|ie-stand" />
```

### UC手机浏览器

```html
<!-- 将屏幕锁定在特定的方向 -->
<meta name="screen-orientation" content="landscape/portrait" />
<!-- 全屏显示页面 -->
<meta name="full-screen" content="yes" />
<!-- 强制图片显示，即使是"text mode" -->
<meta name="imagemode" content="force" />
<!-- 应用模式，默认将全屏，禁止长按菜单，禁止手势，标准排版，强制图片显示。 -->
<meta name="browsermode" content="application" />
<!-- 禁止夜间模式显示 -->
<meta name="nightmode" content="disable" />
<!-- 使用适屏模式显示 -->
<meta name="layoutmode" content="fitscreen" />
<!-- 当页面有太多文字时禁止缩放 -->
<meta name="wap-font-scale" content="no" />
```

### QQ手机浏览器

```html
<!-- 锁定屏幕在特定方向 -->
<meta name="x5-orientation" content="landscape/portrait" />
<!-- 全屏显示 -->
<meta name="x5-fullscreen" content="true" />
<!-- 页面将以应用模式显示 -->
<meta name="x5-page-mode" content="app" />
```

### Apple iOS

```html
<!-- Smart App Banner -->
<meta name="apple-itunes-app" content="app-id=APP_ID,affiliate-data=AFFILIATE_ID,app-argument=SOME_TEXT" />

<!-- 禁止自动探测并格式化手机号码 -->
<meta name="format-detection" content="telephone=no" />

<!-- Add to Home Screen添加到主屏 -->
<!-- 是否启用 WebApp 全屏模式 -->
<meta name="apple-mobile-web-app-capable" content="yes" />
<!-- 设置状态栏的背景颜色,只有在 “apple-mobile-web-app-capable” content=”yes” 时生效 -->
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<!-- 添加到主屏后的标题 -->
<meta name="apple-mobile-web-app-title" content="App Title" />
```

### Google Android

```html
<meta name="theme-color" content="#E64545" />
<!-- 添加到主屏 -->
<meta name="mobile-web-app-capable" content="yes" />
```

---

---
url: /czxBlog/article/browser-event-loop/index.md
---
# Event Loop 浏览器端的事件循环
事件循环，即 Event-Loop。

## 什么是 Event-Loop ？

Event-Loop 是一个执行模型，在 [html5规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops) 中进行了浏览器端的 Event-Loop 的明确定义。

## 宏任务与微任务

javascript 有两种异步任务，分别是`宏任务`和`微任务`

### 宏任务

宏任务，`macro task`，也叫 `tasks`，一些异步任务的回调会依次进入 `macro task queue`，等待后续被调用。

这些异步任务包括：

* setTimeout
* setInterval
* setImmediate (Node独有)
* requestAnimationFrame (浏览器独有)
* I/O
* UI rendering

### 微任务

微任务， `micro task`, 也叫 `jobs`，另一些异步任务的回调会依次进入`micro task queue`，等待后续被调用。

这些异步任务包括：

* process.nextTick(Node独有)
* Promise
* Object.observe
* MutationObserver

## 事件循环 Event Loop

1. 执行全局 `script` 代码，这些代码有一些是同步语句，有一些是异步语句（如： setTimeout）；
2. 全局`script`同步代码执行完毕后，调用栈Stack会清空；
3. 从微任务`micro task queue` 中取出位于队首的任务，放入调用栈Stack中执行，执行完后`micro task queue`长度减一；
4. 继续取出微任务`micro task queue`位于队首的任务，放入调用栈Stack中执行，
   以此类推，直到把`micro task queue`中的所有任务都执行完毕。**注意，如果在执行micro task的过程中，产生了`micro task`那么会加入到队列的末尾，也会在这个周期被调用执行**；
5. `micro task`中的所有无人都执行完毕，此时 `micro task queue` 为空队列，调用栈Stack也为空；
6. 取出宏队列 `macro task queue` 中位于队首的任务，放入Stack中执行；
7. 执行完毕后，调用栈Stack为空；
8. 重复第3-7个步骤；
9. 以此继续循环重复；

::: tip 重点

1. 宏任务`marco task` 一次只从队列中取出一个任务执行，执行后就去执行微任务队列中的任务；
2. 微任务队列中所有的任务都会依次取出来执行，直到`micro task queue`为空，
   且当前微任务执行过程中产生新的`micro task`，也会加入到当前`micro task queue`;
3. `UI Rendering`由浏览器自定判断决定执行节点。但是只要执行`UI Rendering`，它的节点是在执行完所有
   `micro task`之后，下一个`macro task`之前，紧跟着执行`UI Rendering`

:::

尝试从代码层面来分析 event-loop:

::: note 抖个机灵
代码人看代码应该比看流程图要来得好理解了吧（bushi）
:::

```js
// 执行器
// 接收一段javascript代码
class Execution {
  constructor(code) {
    this.code = code
    this.macroTaskQueue = []
    this.microTaskQueue = []
  }

  // 启动执行
  exec() {
    // 首次运行，将 传入的 code 推入到 Track中执行
    // 并获取其中的 宏任务和 微任务
    const { macroTaskQueue, microTaskQueue } = this.run(this.code)
    // 将宏任务和微任务 推入到 各自的 队列中
    this.macroTaskQueue.push(...macroTaskQueue)
    this.microTaskQueue.push(...microTaskQueue)
    // 开始执行微任务
    this.runMicroTaskQueue()
  }

  // 执行微任务队列
  runMicroTaskQueue() {
    // 遍历 微任务队列中的所有任务
    // 当当前的 微任务队列清空时，遍历才结束
    while (this.microTaskQueue.length) {
      // 取出 队首的微任务
      const task = this.microTaskQueue.shift()
      // 将 当前微任务 推入到 执行栈中执行
      // 并将返回的 宏任务和微任务 继续 推入到 各自的队列中
      const { macroTaskQueue, microTaskQueue } = this.run(task)
      this.macroTaskQueue.push(...macroTaskQueue)
      this.microTaskQueue.push(...microTaskQueue)
    }
    // 当前微任务执行完毕，继续执行宏任务
    this.runMacroTaskQueue()
  }

  // 执行宏任务队列
  runMacroTaskQueue() {
    // 从 宏任务队列队首 取出一个 宏任务
    const task = this.macroTaskQueue.shift()
    // 将当前 宏任务 推入到 执行栈中执行
    // 并将返回的 宏任务和微任务 继续 推入到 各自的队列中
    const { macroTaskQueue, microTaskQueue } = this.run(task)
    this.macroTaskQueue.push(...macroTaskQueue)
    this.microTaskQueue.push(...microTaskQueue)
    // 再一次执行 微任务队列中的任务
    this.runMicroTaskQueue()
  }

  // 执行栈调用
  run(task) {
    // track 函数表示 执行栈
    // 执行完毕返回 产生的 微任务队列 和 宏任务队列
    const { macroTaskQueue, microTaskQueue } = track(task)
    return { macroTaskQueue, microTaskQueue }
  }
}
const execute = new Execution(scriptCode)
execute.exec()
```

`event-loop` 概念性的内容大体就这么多，接下来从示例中来实际执行情况。

## 示例

::: warning 注意
以下示例是在 `Chrome` 中执行后获得的结果，在其他浏览器的表现并不一定完全相同。
:::

可以尝试自己心中执行这段代码后的打印顺序，再切换到`Console`中看实际的运行结果，是否符合你的预期结果。

::: code-tabs

@tab javascript

```js
console.log('script')

setTimeout(() => {
  console.log('timeout 1')
  Promise.resolve().then(() => {
    console.log('promise 1')
  })
})

new Promise((resolve) => {
  console.log('promise resolver')

  Promise.resolve().then(() => {
    console.log('promise 3')
  })

  resolve('promise 2')
}).then((data) => {
  console.log(data)
})

setTimeout(() => {
  console.log('timeout 2')
})

console.log('end')
```

@tab Console

```txt
script
promise resolver
end
promise 3
promise 2
timeout 1
promise 1
timeout 2
```

:::

---

---
url: /czxBlog/article/btkqop1a/index.md
---
# CSS At-Rules
## @charset

### 概述

指定样式表中使用的字符编码。 它必须位于样式表中的第一个元素，且前面不得有任何字符。

不能在 `<style>` 元素内的样式属性内使用。

### 示例

```css
@charset "UTF-8";
@charset "utf-8"; /*大小写不敏感*/
/* 设置css的编码格式为Unicode UTF-8 */
@charset 'UTF-8'; /* 无效的, 使用了错误的引号 */
@charset "UTF-8"; /* 无效的, 多于一个空格 */
@charset "UTF-8"; /* 无效的, 在at-rule之前多了一个空格 */
@charset UTF-8; /* Invalid, without ' or ", the charset is not a CSS <string> */
```

## @font-face

### 概述

指定一个用于显示文本的自定义字体。

字体可以从远程服务器，也可以是用户本地安装的字体。

`@font-face` 可以解除对用户电脑字体的依赖。

### 语法

```css
@font-face {
  [ font-family: <family-name>; ] ||
  [ src: <src>; ] ||
  [ unicode-range: <unicode-range>; ] ||
  [ font-variant: <font-variant>; ] ||
  [ font-feature-settings: <font-feature-settings>; ] ||
  [ font-variation-settings: <font-variation-settings>; ] ||
  [ font-stretch: <font-stretch>; ] ||
  [ font-weight: <font-weight>; ] ||
  [ font-style: <font-style>; ] ||
  [ size-adjust: <size-adjust>; ] ||
  [ ascent-override: <ascent-override>; ] ||
  [ descent-override: <descent-override>; ] ||
  [ line-gap-override: <line-gap-override>; ]
}
```

* `font-family`: 指定的 `<family-name>` 将会被用于 `font`或`font-family`的属性
* `src`: 远程字体文件的位置，或者通过`local`函数通过字体名字从本地加载字体。

### 使用示例

加载远程字体文件：

```html
...
<style>
  @font-face {
    font-family: custom-font;
    src: url('http://example.com/custom-font.ttf');
  }
  body {
    font-family: custom-font;
  }
</style>
...
```

加载字体文件，先尝试从用户本地加载，如果加载失败则从远程服务器下载:

```html
...
<style>
  @font-face {
    font-family: MgOpenModernaBold;
    src: local('Helvetica Neue Bold'), url(MgOpenModernaBold.ttf);
  }
  body {
    font-family: MgOpenModernaBold;
  }
</style>
...
```

加载不同文件格式的字体，根据用户环境判断使用兼容的字体文件格式：

```html
...
<style>
  @font-face {
    font-family: custom;
    src:
      url('custom.ttf') format('tff'),
      url('custom.woff') format('woff'),
      url('custom.woff2') format('woff2');
  }
  body {
    font-family: custom;
  }
</style>
...
```

## @import

### 概述

从其他样式表导入样式规则。

`@import` 必须优先于其他类型的规则，即需要在文件顶部声明。`@charset` 除外。

### 语法

```css
@import url;
@import url list-of-media-queries;
```

* `url` 样式规则文件资源位置
* `list-of-media-queries` [媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)，支持用逗号分隔多个查询条件。资源仅在满足媒体查询条件时才会被加载。

## @keyframes

### 概述

通过在动画序列中定义关键帧的样式来控制CSS动画序列中的中间步骤。

### 示例

使用 `from`,`to` 定义起始和结束关键帧的样式 实现动画

```css
@keyframes slidein {
  from {
    transform: translateX(0%);
  }

  to {
    transform: translateX(100%);
  }
}
```

使用 百分比 定义触发关键帧的时间点

```css
@keyframes slidein {
  0% {
    transform: translateX(0%);
  }

  50% {
    transform: translateX(50%);
  }

  100% {
    transform: translateX(100%);
  }
}
```

## @media

媒体查询，详见 [CSS @media 媒体查询](/post/fe5ruia1/)

---

---
url: /czxBlog/article/c3ez957l/index.md
---
# HTTP缓存机制
::: note
老生常谈！老生常谈！老生常谈啊！
:::

## 什么是HTTP缓存

当客户端向服务器发起资源请求时，会先抵达浏览器缓存，如果浏览器有要请求的资源的副本，
那么就可以直接从浏览器缓存中提取而不是从原始服务器中获取这个资源。

http缓存都是从对同一资源的第二次请求开始的。

* 第一次请求时，服务器返回资源，并在`response header`中回传资源的缓存参数；
* 第二次请求时，浏览器会根据这些缓存参数，判断是否使用浏览器缓存的资源副本还是从服务器获取资源。

## HTTP缓存分类

HTTP缓存，根据是否需要重新向服务器发起请求，可分为两大类：

* 强缓存： 强制缓存，在缓存有效时间内，不再向服务器发起资源请求，直接使用浏览器缓存的资源副本
* 协商缓存：在缓存有效时间内，需要向服务器询问资源是否需要更新，如果需要更新，则从服务器获取新的资源，
  如果不需要更新，则继续使用浏览器缓存的资源副本；

::: tip 另一种缓存分类
根据资源是否可以被单个用户或多个用户使用来分类，还可以分为 私有缓存和共享缓存。

这种一般是对于 代理服务器的，即 浏览器发起请求 -> 代理服务器 -> 原始服务器。

* 私有缓存： 在代理服务器中，仅针对单个用户使用的资源缓存，其他用户发起的对同一个资源的首次请求，仍然需要从原始服务器获取资源
  并为该用户建立新的缓存资源。

* 共享缓存：只要有一个用户发起的对同一个资源的首次到达代理服务器的请求，代理服务器对该资源缓存后，其他用户请求代理服务器上的资源，
  在缓存有效时间内，代理服务器不再向原始服务器获取新的资源，返回代理服务为缓存的资源副本。

:::

## 主要的HTTP Headers

* 通用首部字段

  | 字段          | 说明                                        |
  | ------------- | ------------------------------------------- |
  | Cache-Control | 控制缓存行为                                |
  | Pragma        | http1.0时代的产物，值为 no-cache 时禁用缓存 |

* 请求头部字段 Request Headers

  | 字段                | 说明                           |
  | ------------------- | ------------------------------ |
  | If-Match            | 比较 ETag 是否一致             |
  | If-None-Match       | 比较 ETag 是否不一致           |
  | If-Modified-Since   | 比较资源最后更新时间是否一致   |
  | If-Unmodified-Since | 比较资源最后更新时间是否不一致 |

* 响应头部字段 Response Headers

  | 字段 | 说明         |
  | ---- | ------------ |
  | ETag | 资源匹配信息 |

* 实体头部字段

  | 字段          | 说明                                |
  | ------------- | ----------------------------------- |
  | Expires       | http1.0时代的产物，实体主体过期时间 |
  | Last-Modified | 资源的最后一次更新时间              |

::: warning 提醒
`Pragma`、`Expires` 这两个header是 http1.0中的内容，在 http1.1及往后的版本中逐步被弃用。

但为了能够对浏览器向下兼容，大多数网站在设置 缓存机制时，仍然在 response headers 中保留这两个字段的声明。

本文同样也会对这两个字段进行说明，以及为什么http1.1后会使用 `Cache-Control` 代替。
:::

::: warning 提醒
在某些技术文章分享中，常常会直接把这些headers字段各自分类到 强缓存 或 协商缓存中，
个人认为这种简单粗暴的划分方式是有待商榷，就比如`Cache-Control`的不同取值，其行为会根据值表现为强缓存或协商缓存。
:::

### Pragma

`Pragma` 字段仅有一个 `no-cache`的可选值，会告知客户端不要对该资源进行缓存读取，应该每次都向服务器发送资源请求。

在客户端使用时，通常做法是在 HTML中加上一个 meta 标签：

```html
<meta http-equiv="Pragma" content="no-cache" />
```

::: caution 警告

* 这个标签声明仅有 IE才能识别含义，其他主流浏览器不兼容。
* 在IE浏览器中，虽然能够识别含义，但并不一定会在请求Request Header中加上Pragma，但确实会让当前页面每次都发起新请求。
  （仅限页面html文件，页面内使用的其他资源不受影响。）

:::

在服务端配置为 Response Header 时，浏览器读取到该字段，会禁用缓存行为，后续的对同一资源的请求会重新发起请求而不使用缓存。

::: warning 提醒
由于`Pragma` 在浏览器端的兼容问题，在服务器端又有其他字段能更好的控制缓存行为，Pragma 字段基本已经被抛弃，不再使用，

*除了部分网站出于兼容性考虑，还会带上该字段。*
:::

### Expires

在 http1.0中，Pragma 用于禁用缓存，也需要有一个字段用于启用缓存和定义缓存时间。Expires 就是用于这个目的。

Expires 的值是一个 GMT时间， 如：`Thu Jun 07 2018 14:26:45 GMT`，用于告诉浏览器资源的缓存过期时间，如果还没有超过该时间
则不发起新的资源请求。

在客户端，可以使用 meta标签来告知浏览器缓存时间

```html
<meta http-equiv="expires" content="Thu Jun 07 2018 14:26:45 GMT" />
```

如果希望不走缓存，每次页面请求都发起新的请求，可以把 content 设置为 -1 或 0。

::: caution 提醒
跟 Pragma 字段一样， 该 meta 标签只有 IE 能够正确识别。
而且该方式仅是告知 IE 缓存时间的标记，并不能在 Request Header 中找到该字段。
:::

服务端在 Response Headers 中设置 Expires 字段，则在任何浏览器中都能正确设置资源缓存时间；

::: info 说明
如果同时使用 Pragma 和 Expires 字段， 则 Pragma 优先级会更好，页面会发起新的请求
:::

::: warning 提醒
Expires 字段虽然能够定义缓存有效时间，但是这个时间的设置是相对于本地时间的。
如果在服务端定义，则这个时间是相对于服务端时间的，
这个时间返回到客户端， 客户端是拿着客户端的本地时间与返回的服务端时间做对比。
那么就会导致一种情况，当用户更改了客户端的时间，如超过了 Expires定义的缓存时间，那么缓存就立即失效了。

也正是应该存在着这样的问题，Expires并不能保证缓存能够达到预期的表现，所以也被逐步弃用。
:::

### Cache-Control

`Cache-Control` 是从 `http1.1` 开始支持的 header 属性，该属性的值描述了使用缓存的行为以及缓存的有效时间。

`Cache-Control` 可以在 发起请求时，在`Request Headers` 中声明该属性，（如果资源请求是通过代理服务器再到原始服务器，）
通知代理服务器对资源的缓存方式，以及是否向原始服务器请求最新的资源。

`Cache-Control` 做为 `Response Headers` 属性返回时，通知浏览器对该资源的缓存方式和有效时间。

Cache-Control 语法如下：

```
Cache-Control: <cache-directive>
```

* 作为 `Request Headers` 时， `cache-directive` 支持以下可选值

| 字段名称                   | 说明                                                                                                                      |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| no-cache                   | 告知(代理)服务器不直接使用缓存，要求从原始服务器发起请求                                                                  |
| no-store                   | 所有内容都不会被保存到缓存或 Internet临时文件中                                                                           |
| max-age=delta-seconds      | 告知服务器 客户端希望接收一个存在时间（age）不大于 delta-seconds 秒的资源                                                 |
| max-stale\[=delta-seconds] | 告知(代理)服务器 客户端愿意接收一个超过缓存时间的资源，若有定义delta-seconds，则为delta-seconds秒，若没有则为超过任意时间 |
| min-fresh=delta-seconds    | 告知(代理)服务器 客户端希望接收一个在delta-seconds秒内被更新过的资源                                                      |
| no-transform               | 告知(代理)服务器 客户端希望获取一个实体数据没有被转换(如压缩)过的资源                                                     |
| only-if-cached             | 告知(代理)服务器 客户端希望获取缓存的资源（若有）,而不用向原服务器发起请求                                                |

* 作为 `Response Headers`时，`cache-directive` 支持以下可选值

| 字段名称                | 说明                                                                                                                                   |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| public                  | 表明任何情况下都需要缓存该资源                                                                                                         |
| private\[="file-name"]   | 表明返回报文中全部或部分(若指定了*file-name*的字段数据)仅开放给某些用户(服务器指定的*share-use*)做缓存使用，其他用户则不能缓存这些数据 |
| no-cache                | 不直接使用缓存，要求向服务器发起（新鲜度校验）请求                                                                                     |
| no-store                | 所有内容都不会被保存到缓存或 Internet临时文件中                                                                                        |
| max-age=delta-seconds   | 告知客户端该资源在*delta-seconds*秒内是新鲜的，无需向服务器发起请求                                                                    |
| s-max-age=delta-seconds | 同 max-age，但仅应用于 共享缓存                                                                                                        |
| no-transform            | 告知客户端缓存文件时不得对实体数据做任何改变                                                                                           |
| must-revalidate         | 当前资源一定是向原始服务器发去验证请求的，若请求失败会返回504(而非代理服务器上的缓存)                                                  |
| proxy-revalidate        | 和 must-revalidate类似，但仅应用于 共享缓存                                                                                            |

* 可以直接在 HTML页面的`<head>` 中通过 meta标签来给请求头加上 `Cache-Control` 字段：

  ```html
  <meta http-equiv="Cache-Control" content="no-cache" />
  ```

* `Cache-Control` 允许自由组合可选值：

  ```
  Cache-Control: max-age=3600, must-revalidate
  ```

  这段声明表示，该资源必须从原始服务器获取，且其缓存有效时间为一个小时，在后续的一个小时内，用户重新访问该资源都无需发送请求。

### 缓存校验

`Pragma`、`Expires`、`Cache-Control` 字段能够让客户端决定是否向服务器发送请求，缓存未过期的从本地缓存获取资源，缓存过期的从服务器端获取资源。

但是，客户端向服务器发送了请求，是否以为着一定要读取并返回该资源的实体内容？

* 如果一个资源在客户端的缓存时间过期了，但服务器并没有更新过这个资源，那服务端是否一定要重新把资源的实体内容返回？

* 如果这个资源过大，虽然缓存过期，但又没有更新过，返回实体内容是否会浪费带宽和时间？

对于这些问题，其实只要采取某种策略，让服务器知道客户端现在保存的缓存文件跟服务端的资源文件是一致的，
然后通知客户端该资源可以继续使用缓存文件，不需要重新返回资源实体内容。
那么就可以解决上述的问题，同时为HTTP请求带来优化和加速。

http1.1 新增了 `Last-Modified`、`ETag`、 `If-Match`、`If-None-Match`、`If-Modified-Since`、
`If-Unmodified-Since` 这些字段，用于对缓存资源的校验，提高缓存的复用率。

### Last-Modified

服务器将资源发送给客户端时，会将资源的最后更新时间以如下格式加载实体首部，一起返回给客户端。

客户端会为该资源标记上该信息，下次在请求时，会把该信息添加在请求报文中发送给服务端去做检查。
如果客户端上报字段时间值和服务端的对应资源的最后修改时间一致，则说明改资源没有被修改过，直接返回 304状态码。

客户端在上报 Last-Modified 时，可以使用的 Request Headers 字段有两个：

* `If-Modified-Since`: 该字段格式如下

  ```
  If-Modified-Since: <Last-Modified-Value>
  ```

  字段告诉服务端，如果客户端上报的最后修改时间和服务器上的最后修改时间一致，则直接返回304和响应报头即可。

  当前各浏览器默认使用该字段用来向服务端上报保存的 Last-Modified 值。

* `If-Unmodified-Since`: 该字段格式如下

  ```
  If-Unmodified-Since: <Last-Modified-Value>
  ```

  字段告诉服务端，如果客户端上报的最后修改时间和服务端上的最后修改时间不一致，
  则应当返回 412（Precondition Failed）状态码给客户端。

Last-Modified 由于是使用的资源最后修改时间来确定资源是否有被修改，
但是在实际情况中，往往存在着一个资源被修改了但实际内容没有发生改变，
而由于资源最后修改时间已经发生改变，依然会返回整个实体内容给客户端，而其实内容跟客户端缓存内容一致。

### ETag

为了解决 `Last-Modified` 可能存在的不准确的问题，http1.1 还推出了 ETag 实体首部字段。

服务器会通过某种算法，给资源计算得出一个唯一标识符，在把资源响应给客户端的时候，会在实体首部加上该字段一起返回给客户端。

```
ETag: ETag-Value
```

客户端为资源标记上该信息，下次在请求时，会把该信息添加在请求报文中发送给服务端去做检查。
服务端只需要比较客户端传来的ETag和对应的该资源的ETag是否一致，就可以判断资源相对于客户端资源是否被修改过。
如果ETag是一致的，那么就直接返回304状态码，否则就返回新的资源实体内容给客户端。

客户端在上报 ETag 时，可以使用的 Request Headers 字段有两个：

* `If-None-Match` 该字段格式如下

  ```
  If-None-Match: <ETag-Value>
  ```

  字段告诉服务端，如果ETag没有匹配上，需要重新返回新的资源实体内容，否则直接返回 304 状态码。

  当前各浏览器默认使用该字段用来向服务端上报保存的 ETag 值。

* `If-Match` 该字段格式如下

  ```
  If-Match: <ETag-Value>
  ```

  字段告诉服务端，如果ETag没匹配到，或者收到了`"*"`值而当前没有该资源实体，
  则应当返回412（Precondition Failed）状态码给客户端。否则服务器直接忽略该字段。

::: tip 提醒
如果 `Last-Modified` 和 `ETag` 同时被使用，则要求它们的验证必须同时通过才返回 304，
若其中一个没有通过，则服务器会按照常规返回资源的实体以及200状态码。
:::

## 次要的 HTTP Headers

以下的字段虽然跟缓存有关系，但没有那么重要。

### Vary

`Vary` 表示 服务端会以什么基准字段来区分、筛选缓存版本。

首先考虑一个问题，服务端有一个请求地址，如果是IE用户则返回针对IE开发的内容，否则返回另一个主流浏览器版本的内容。

一般来说，服务端获取到请求的 `User-Agent` 字段做处理即可。
但是如果用户请求的是代理服务器而非原始服务器，且代理服务器如果直接把缓存的IE版本资源发给了非IE的客户端，那就出问题了。

而 Vary 则是用于处理这类问题的头部字段，只需要在响应报文加上：

```
Vary: User-Agent
```

字段告知代理服务器需要以 User-Agent 这个请求头部字段来区别缓存版本，确定传递给客户端的版本。

Vary 字段也接受条件组合的形式

```
Vary: User-Agent, Accept-Encoding
```

字段告知代理服务器需要以 User-Agent 和 Accept-Encoding 两个请求头部字段来区别缓存版本。

### Date、Age

Date 字段表示原始服务器发送该资源的响应报文时间（GMT时间）。
该字段的作用可以帮助我们判断该资源命中的是原始服务器还是代理服务器。

* 如果`Date`的时间与当前时间差别较大，或者连续F5刷新发现Date值没有变化，那么说明当前请求命中的是代理服务器的缓存。
* 如果每次刷新页面，浏览器每次都会重新发起这条请求，那么其Date的值会不断变化，说明该资源是直接从原始服务器返回的。

Age 字段表示某个文件在代理服务器中存在的时间（秒），如果文件被修改或替换，Age会重新从0开始累计。

## 浏览器表现

### 强缓存

对于强缓存的资源：

* 当用户第一次访问该资源时，服务器返回 200状态码，以及资源实体内容。

* 如果用户访问完第一次后，在没有关闭浏览器的前提下，进行了第二次或更多次资源访问，那么浏览器不再请求服务器，
  而是从 浏览器的内存缓存区取出资源，并且 状态码 标记为 `200 (memory cache)`

* 如果用户访问完第一次后，关闭浏览器后，重新打开浏览器，进行第二次或更多次资源访问，那么浏览器也不会请求服务器，

* 而是从 浏览器的磁盘缓存区取出资源，并且 状态码 标记为 `200（disk cache）`

### 协商缓存

* 当用户第一次访问该资源时，服务器返回 200状态码，以及资源实体内容。

* 如果用户进行第二次访问时，进行缓存校验。 或在缓存时间内，或 资源未被修改，那么 直接返回 304状态码

* 如果用户进行第二次访问时，服务器资源已被更新，则返回 状态码 200 ，以及新的资源实体内容。

---

---
url: /czxBlog/article/cjeo0sia/index.md
---
# git工作流实践
这是一篇在我个人工作实践中，在我参与的，负责的项目、团队协作中，逐步调整，适合于一些实际场景的 git 工作流实践。

众所周知，在软件开发中， git 是目前使用最广泛的 软件版本管理工具，它足够高效，足够安全，也足够灵活，
对于团队协作和软件管理提供了很大的帮助。

而一个良好的合适的 分支管理方案，可以更好的帮助我们通过 git 进行 软件版本管理。

在过去， git-flow 是一个很流行的 分支管理方案。对于多人协作，中大型项目，提供了一个较为满意的解决方案。

但在我过去的实践中，逐渐感受到 git-flow 对于我来说还是太过于繁杂了，虽然在事实上满足了 我对于项目的软件版本管理，
但认为还是可以做一些简化，调整 分支管理策略，以更好的适配实际的开发工作。

## 场景

试想一下，在我们实际的软件开发过程中，迭代一个软件的版本，正常来说是：

```txt
需求评审 -> 需求确认 -> 开发阶段 ->
测试环境测试 -> 预生产发布验证 -> 生产环境发布验证 -> 发布完成
```

### 从开发到发布

在这个过程中，如果在 测试环境发现了 bug，需要重新回归到 开发阶段进行修复，
同样的，在预生产发布验证环节发现了问题，也需要重新回归到 开发阶段修复后，重新测试和发布预生产。

而如果 生产环境发布验证 出现了问题， 需要紧急回滚到上一个版本，并重新回到开发阶段修复，测试，预生产验证，再生产发布。

### 需求明确 or 变更

虽然我们一直强调，版本迭代进入开发后，这个版本的需求应该是明确的。

然而，这仅仅只是理想情况下，实际过程中经常会遇到 需求变更，甚至是 添加新的功能，删除功能等。
这种变更，还很难控制会发生在开发阶段还是测试阶段。

也许我们会吐槽甚至抱怨这样的容易变更需求的项目管理很糟糕，很不专业。但是，这也是确确实实存在的场景，
即使再成熟的团队，也会不可避免的遇到这种问题。

然而需求变更也不代表着一定是上面这种场景。

### 周期性版本发布，需求池

有些项目可能相对来说比较成熟，或者采用了不同的版本迭代方式。

周期性版本发布指，采用某个固定的周期内，仅会也一定会发布一个版本，如 每两周发布一个版本。
那么在这种模式下，每个版本上线哪些功能，上线多少功能，实际上是以各个功能的开发进度，和进入到当前周期后，
明确下来的版本计划再决定的。

将产品 明确划分为一个个需求，建立一个需求池，并指定了每个需求的按时间的线性迭代预期计划，
在预期的未来的周期性的版本发布中，会上线哪些需求功能。

在这种场景下，我们不可能把需求都集中在某个分支上进行开发，仅有的一个 develop分支也很难满足所有的
开发合并和测试。

### 开发人员对于 git的掌握

很多时候，对于工具能够使用到什么程度，对于项目能够有多少帮助，其实不在于 工具有多优秀，而是在于团队成员
对于工具的平均掌握程度，已经是否有成熟的规范化的操作流程。

早期我认为 成员对于 git 的掌握是大差不差的，只要说明一些操作流程即可，未加以限制和规范

然而，这会也给项目带来了潜在的风险：主要分支可能会被误操作污染，多个功能直接在同一个分支开发等等。

而为了解决这些问题，需要建立一套足够完善，同时低复杂度的操作规范，并对人员和分支加以权限控制。

## 分支管理实践

在以上的场景中，逐渐摸索出了一套合适的分支管理方案：

* `master` 分支： 主分支，正式版本的代码提交记录。

  永远不会在上面做任何改动提交，也仅接受来自 `release` 分支的合并请求，合并后打上版本tag。

* `release` 分支：发布分支，用于发布版本到预生产和生产环境，发布完成后合并到 master分支。

  永远不会咋上面做任何改动提交，也仅接受来自 prerelease 分支的合并请求。

* `prerelease/*` 分支组： 预发布分支，根据版本号创建新的分支。

  仅合并当前版本关联的 `feature/*` 分支，用于合并开发完成的需求，进入到版本测试阶段，发布到测试环境。
  不会或者尽可能少的在上面做任何改动提交。

* `feature/*` 分支组： 功能开发分支(包括hotfix)，从 master 分支拉取创建的分支，

  每个分支仅针对某一个单一的业务或者功能，所有的改动都应该在 feature 分支上进行。
  仅能合并到 prerelease 分支。 master有更新后需要及时拉取合并同步。

流程图：
![git-work-flow](https://assets.processon.com/chart_image/6251bfce1efad407891be6c8.png)

可以看出，整个方案只有四条主要的分支，且不同功能分支到其他分支都是单向的。

这样的好处是足够的简单，足够的好理解，也保证了一定的灵活性。

删除了 develop分支的原因是，单一的develop分支并不能很好的满足 需求变更后导致的 develop分支无效，
选择使用 prerelease 分支组作为替代，可以灵活的根据版本规划创建分支，即使发生需求变更，也可以灵活的直接抛弃
当前已创建的分支，重新新建一条 prerelease分支再次从feature分支合并代码。

从 develop 改名为 prerelease 也是因为，功能分支开发完后并不是马上合并的，而是根据迭代计划再合并的，理解起来就是
预期上线的功能，即 prerelease。

从分支的行为上看， master分支和 release分支 似乎可以在简化仅保留一条。但这里是考虑到 如果有发布回滚操作，如果
都在 master 分支上进行，那么master分支的操作记录看起来就不够的干净，简洁，而把发布、回滚等策略都放到了 release分支
，而 master仅保留干净的版本历史，那么会更加的友好，便于维护。

在这个方案中，最好是配合上 git分支的权限控制，对 master分支、release分支进行保护，确保这两个分支仅接受来自对应
分支的合并请求。

分支合并，选择 `merge` 还是 `rebase`，这个需要对 commit记录有何要求去考量。
如果需要保证所有提交记录都可追踪，建议使用 merge，如果希望 提交记录线性、整洁，建议使用 rebase。

同时，feature分支 合并到 prerelease 分支，最好是通过 pull requests 的操作模式，在进入测试阶段前，接受来自其他
有用审查权限的开发人员的code review。

::: warning 说明
该实践方案仅是我过去在我的工作实践中总结的，并在团队内部经历过超过2年的验证和调整所得出的，适合于当时团队的实践方案。

是否与您的团队或所在的团队契合，还需要重新考量。

分支管理方案 需要从实际的情况触发考虑，包括团队人数，产品规模等等。

没有最好的方案，只有合适自己的方案。
:::

---

---
url: /czxBlog/article/d12xkizf/index.md
---
# JavaScript进阶（四）— 执行上下文
## 执行上下文

执行上下文是， `JavaScript` 代码被 **解析** 和 **执行** 时 **所在环境** 的抽象概念。
`JavaScript` 的任何代码都是在执行上下文中执行的。

### 类型

`JavaScript` 有三种 执行上下文 类型：

* **全局执行上下文**

  默认的执行上下文，或者说基础执行上下文。 任何不在函数内部的代码，都是在 全局执行上下文中。
  全局上下文执行两个事情：

  * 创建一个全局的 `window`对象（在浏览器环境中）。
  * 设置 `this` 的值等于 全局的 `window` 对象。

  一个程序只会有一个全局执行上下文。

* **函数执行上下文**

  每当函数被执行时，都会为该函数创建一个新的执行上下文。
  每个函数都有它自己的执行上下文，且是在函数执行的时候进行创建。
  函数上下文可以有任意多个，每当一个函数执行上下文被创建，它会按照定义的顺序，执行一系列步骤。

* **eval函数执行上下文**

  执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文。

### 创建执行上下文

创建执行上下文主要分为两个阶段： **创建阶段** 和 **执行阶段**。

## 创建阶段

在创建阶段，会做三件事：

* this 值的决定，即 This绑定
* 创建词法环境组件
* 创建变量环境组件

### This绑定

* 全局执行上下文

  在全局执行上下文中， `this` 的值指向全局对象。(在浏览器中， `this` 引用 `Window` 对象)。

* 函数执行上下文

  在函数执行上下文中， `this` 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 `this` 会被设置成那个对象，否则 `this` 的值被设置为全局对象或者 `undefined` （在严格模式下）。

  ```js
  let foo = {
    bar() {
      console.log(this)
    },
  }

  // 'this' 引用 'foo', 因为 'baz' 被对象 'foo' 调用
  foo.bar()

  let bar = foo.baz

  // 'this' 指向全局 window 对象，因为没有指定引用对象
  bar()
  ```

### 词法环境

> [ECMAScript 标准](https://262.ecma-international.org/6.0/)
>
> 词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。
> 一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。

词法环境是一种 **持有标识符—变量映射** 的结构。

::: tip
这里的标识符指的是变量/函数的名字，而变量是对实际对象\[包含函数类型对象]或原始数据的引用。
:::

在词法环境的内部有两个组件：**(1) 环境记录器**和 **(2) 一个外部环境的引用**。

* **环境记录器**是存储变量和函数声明的实际位置。
* **外部环境的引用**意味着它可以访问其父级词法环境（作用域）。

词法环境有两种类型：

* **全局环境**（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 `null`。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 `window` 对象）还有任何用户定义的全局变量，并且 `this` 的值指向全局对象。
* 在**函数环境**中，函数内部用户定义的变量存储在环境记录器中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。

环境记录器也有两种类型：

* **声明式环境记录器**: 存储变量、函数和参数。
* **对象环境记录器**: 用来定义出现在全局上下文中的变量和函数的关系。

可以看出：

* 在**全局环境**中，环境记录器是对象环境记录器。
* 在**函数环境**中，环境记录器是声明式环境记录器。

::: tip 注意
对于**函数环境**，**声明式环境记录器**还包含了一个传递给函数的 `arguments` 对象（此对象存储索引和参数的映射）和传递给函数的参数的 `length`。
:::

使用伪代码描述 词法环境，大致如下：

```
GlobalExecutionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
    }
    outer: <null>
  }
}

FunctionExecutionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
    }
    outer: <Global or outer function environment reference>
  }
}
```

### 变量环境

**变量环境** 同样是一个 **词法环境**，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。

**变量环境** 有着上面定义的词法环境的所有属性。

在 `ES6` 中，**词法环境**和**变量环境**的一个不同就是前者被用来存储函数声明和变量（`let` 和 `const`）绑定，
而后者只用来存储 `var` 变量绑定。

示例代码：

```js
let a = 20
const b = 30
let c

function multiply(e, f) {
  let g = 20
  return e * f * g
}

c = multiply(20, 30)
```

示例代码 执行上下文伪代码：

```
GlobalExectionContext = {

  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      a: < uninitialized >,
      b: < uninitialized >,
      multiply: < func >
    }
    outer: <null>
  },

  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      c: undefined,
    }
    outer: <null>
  }
}

FunctionExectionContext = {
  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>
  },

  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      g: undefined
    },
    outer: <GlobalLexicalEnvironment>
  }
}
```

::: warning
只有遇到调用函数 `multiply` 时，函数执行上下文才会被创建。
:::

**说明：**

可能你已经注意到 `let` 和 `const` 定义的变量并没有关联任何值，但 `var` 定义的变量被设成了 `undefined。`

这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 `undefined`（`var` 情况下），或者未初始化（`let` 和 `const` 情况下）。

这就是为什么你可以在声明之前访问 `var` 定义的变量（虽然是 `undefined`），但是在声明之前访问 `let` 和 `const` 的变量会得到一个引用错误。

这就是我们说的变量声明提升。

## 执行阶段

在此阶段，完成对所有这些变量的分配，最后执行代码。

::: warning
在执行阶段，如果 `JavaScript` 引擎不能在源码中声明的实际位置找到 `let` 变量的值，它会被赋值为 `undefined`。
:::

---

---
url: /czxBlog/article/dixuz4sh/index.md
---
# 前端渲染策略 —— CSR、SSR、SSG、ISG
想象一下建设一座城市（你的Web应用）。

你是选择在工厂（服务器）里预先建造好整栋房子运过去（SSG）？

还是派个施工队（浏览器）到现场根据图纸（JS）慢慢盖（CSR）？

或者是让工厂按订单要求快速生产好毛坯房再运过去让施工队装修（SSR）？

甚至是在预制好的房子里预留模块，按需更新（ISG）？

🤔 今天，我们就来拆解这四种主流渲染策略：**客户端渲染 (CSR)**、**服务器端渲染 (SSR)**、**静态站点生成 (SSG)** 和 **增量静态再生 (ISG)**，帮你找到最适合项目的“城市建设方案”。

## 客户端渲染 (CSR - Client-Side Rendering)

### 工作原理

* 用户请求一个URL。
* 服务器返回一个**近乎空白的HTML文件**（通常只有一个根元素`<div id="root"></div>`和指向大量JavaScript文件的链接）。
* 浏览器下载HTML、CSS和**所有必需的JavaScript**（包括框架如React/Vue/Angular，以及应用代码）。
* JavaScript **在用户的浏览器中执行**，负责：
  * 获取数据（通常通过API调用）。
  * 构建DOM（页面结构）。
  * 将构建好的DOM插入到根元素中。
  * 处理后续的交互和路由切换（所有后续页面跳转也由JS处理，无需整页刷新）。

### 典型代表

传统的单页应用 (SPA) 框架如 **Create React App, Vue CLI 默认输出**。

### 优点

* **交互体验流畅：** 首次加载后，后续导航和交互感觉极其快速，接近原生应用，因为只更新变化的部分。
* **服务器压力小：** 服务器主要提供静态文件和API，计算负担转移到客户端。
* **开发体验好：** 前后端分离清晰，前端开发者拥有完全控制权，利用现代框架开发高效。
* **丰富的交互能力：** 非常适合构建高度交互式、类应用（Application-like）的体验。

### 缺点

* **首屏加载慢 (FCP/TTI 差)：** 用户需要等待所有JS下载、解析、执行、数据获取、渲染完成才能看到有意义的内容。尤其对低端设备和慢网络用户不友好。
* **SEO 不友好：** 搜索引擎爬虫早期（现在部分高级爬虫如Googlebot能执行JS，但仍有延迟和不确定性）可能只能看到空HTML或加载状态，难以正确索引内容。
* **内容可见性延迟：** 用户盯着空白屏或加载动画的时间较长。

### 适用场景

* 后台管理系统、Dashboards（对SEO无要求）。
* 高度交互的Web应用（如在线编辑器、复杂表单、实时协作工具）。
* 登录后才能访问的内容（此时SEO不重要）。
* 网络条件较好（或对首屏性能要求不高）的场景。

## 服务器端渲染 (SSR - Server-Side Rendering)

### 工作原理

* 用户请求一个URL。
* 服务器**实时**接收到请求。
* 服务器运行JavaScript应用（如Node.js + React/Vue）。
* 服务器根据请求的URL，**获取所需数据**（查询数据库、调用API等）。
* 服务器执行应用代码，**将组件渲染成完整的HTML字符串**（包含实际内容）。
* 服务器将这个**完整的、包含数据的HTML文档**发送给浏览器。
* 浏览器接收到HTML后能**立即显示有意义的内容**（FCP快）。
* 同时，浏览器会下载JS包（hydration）。JS下载执行后，会“接管”页面，附加事件监听器，使页面变得可交互（TTI可能稍晚于FCP）。后续交互和导航通常又转为CSR模式。

### 典型代表

* **Next.js** (`getServerSideProps`),
* **Nuxt.js** (`server-side rendering mode`)
* **SvelteKit** (适配器如`@sveltejs/adapter-node`)

### 优点

* **优秀的首屏性能 (FCP)：** 用户能快速看到完整内容，提升感知速度。
* **卓越的SEO：** 搜索引擎爬虫直接获取到包含完整内容的HTML，索引无忧。
* **更好的社交分享：** 分享链接时，社交媒体的爬虫也能获取到包含完整元信息（如Open Graph tags）和内容的HTML，生成正确的预览卡片。
* **对低端设备/慢网络更友好：** 用户能尽早看到内容。

### 缺点

* **服务器压力大：** 每个请求都需要服务器实时渲染，消耗CPU资源。高并发时可能成为瓶颈，需要良好的服务器架构和缓存策略（如CDN缓存、反向代理缓存）。
* **TTI可能延迟：** 虽然内容显示快，但页面可交互（TTI）需要等待JS下载和执行完成（hydration）。如果JS包很大，用户看到内容但无法立即点击，体验会打折扣（需优化hydration性能）。
* **开发复杂度稍高：** 需要考虑服务器环境、数据获取方式（`getServerSideProps`等）、hydration过程，调试可能更复杂。

### 适用场景

* 内容密集型且对SEO要求极高的网站（新闻、博客、电商列表/详情页）。
* 需要良好社交分享预览的页面。
* 用户网络条件差异较大的公共网站。
* 需要用户立即看到核心内容的页面。

## 静态站点生成 (SSG - Static Site Generation)

### 工作原理

* **在构建时（Build Time）**，而不是在用户请求时。
* 应用代码运行在**构建服务器**上。
* 为网站中的**每一个可能的页面路径**（基于文件路由或配置），执行以下操作：
  * **获取该页面所需的所有数据**（从CMS、API、数据库、本地文件等）。
  * **将React/Vue/Svelte组件渲染成纯HTML字符串**。
* 将生成的每个HTML文件，连同其CSS、JS、图片等资源，**输出为静态文件**。
* 将这些静态文件部署到CDN或静态文件托管服务。
* 用户请求一个URL时，CDN直接返回**预先渲染好的、包含完整内容的静态HTML文件**，浏览器快速展示（FCP极快）。JS随后下载执行进行hydration，添加交互性（TTI通常也很快，因为资源在CDN边缘）。

### 典型代表

* **Next.js** (`getStaticProps`/`getStaticPaths`)
* **Gatsby**
* **Nuxt.js** (`target: static`)
* **VitePress**
* **Hugo**
* **Jekyll**
* **Eleventy (11ty)**

### 优点

* **极致性能：** 页面直接从全球CDN边缘节点提供，加载速度极快（FCP, TTI, LCP 都优秀）。
* **超强安全性：** 没有实时服务器或数据库暴露给公共网络，攻击面极小。
* **成本低廉：** 静态文件托管（如Vercel, Netlify, GitHub Pages, AWS S3 + CloudFront）通常非常便宜甚至免费，且能轻松应对高流量。
* **优秀的SEO：** 和SSR一样，爬虫直接获取完整HTML内容。
* **简单可靠：** 部署就是上传文件，没有服务器运行时的复杂性和潜在故障点。

### 缺点

* **构建时数据：** 页面内容在构建时就固定了。如果数据源更新，必须**重新构建并部署整个站点（或受影响页面）** 才能更新页面内容。不适合**数据频繁变化**的页面（如实时股票行情、高频更新的评论区）。
* **大规模站点构建时间长：** 如果页面数量成千上万，每次构建可能需要几分钟甚至几十分钟。

### 适用场景

* 博客、文档网站、营销/宣传页（内容相对稳定）。
* 产品展示页、公司官网。
* 基于CMS但内容发布不频繁的网站（可以在CMS更新后触发构建）。
* 任何内容变化频率低于构建/部署频率的场景。追求极致性能、安全和成本效益的场景。

## 增量静态再生 (ISG - Incremental Static Regeneration)

### 工作原理

::: tip Next.js 提出的概念，核心思想
:::

* 在SSG的基础上，增加了**按需或在后台更新静态内容的能力**，**无需重新部署整个应用**。
* 在构建时 (`getStaticProps`) 可以指定一个 `revalidate` 时间（单位：秒）。
* 用户请求一个页面：
  1. **首先**，CDN/服务器会立即返回**上次构建或再生的静态HTML**（极快）。
  2. **同时**，在后台检查该页面自上次生成后是否已超过 `revalidate` 时间。
  3. **如果超过**，则在后台触发一次该页面的“再生”：
     * 重新运行 `getStaticProps` 获取**最新数据**。
     * 用新数据**重新生成该页面的HTML**。
     * 将新HTML**保存/缓存**起来，替换旧版本。
  4. **下次请求**该页面时，用户将直接获得新生成的HTML。
* 第一个触发再生的用户可能看到的还是旧页面，但他“默默”帮助后续用户更新了缓存。
* 也可以使用 `On-Demand Revalidation` (按需再生)：通过API路由手动触发特定页面（或带标签的一组页面）的立即再生（如CMS更新后调用Webhook）。

### 典型代表

**Next.js** (`getStaticProps` with `revalidate` 或 `unstable_revalidate` API / On-Demand ISR)。

### 优点

* **保留SSG的所有优点：** 极致的性能、安全性、成本效益、SEO。
* **解决SSG的最大痛点：** 内容可以**在部署后更新**！数据不再是完全静态的。可以设置一个合理的更新频率（如每10秒、1分钟、1小时）。
* **增量更新：** 只更新过期的页面，而不是全站重建，大大减少构建压力。
* **优雅降级：** 即使后台再生失败或超时，用户看到的仍是有效的（可能稍旧的）缓存内容。

### 缺点

* **内容更新非即时：** 用户可能在 `revalidate` 时间窗口内看到稍旧的数据（但通常可接受）。需要按需再生API才能实现接近实时（但仍有CDN传播延迟）。
* **概念稍复杂：** 需要理解缓存、再生、过期时间等机制。
* **平台依赖：** 主要深度集成在Vercel平台，其他平台实现可能不同或有局限（如Netlify也支持类似功能）。

### 适用场景

**SSG的理想场景，但数据更新频率高于全站部署频率时**：

* 电商网站（商品列表/详情页 - 价格/库存可设置短时刷新，商品增删触发按需再生）。
* 新闻/博客网站（新文章发布触发按需再生，热门文章设置短刷新）。
* 社交媒体Feed（用户主页Feed设置分钟级刷新）。
* 任何需要良好性能+SEO+动态内容组合的页面。

## 对比

| 特性                   | CSR (Client-Side)     | SSR (Server-Side)        | SSG (Static Site Gen)       | ISG (Incremental Static Regen)     |
| :--------------------- | :-------------------- | :----------------------- | :-------------------------- | :--------------------------------- |
| **渲染发生地**         | 浏览器                | 服务器 (每次请求)        | 构建服务器 (一次)           | 构建服务器 + 运行服务器 (按需)     |
| **首次内容加载 (FCP)** | 慢 (需下载执行JS)     | **快** (收到完整HTML)    | **极快** (CDN静态文件)      | **极快** (CDN静态文件)             |
| **可交互时间 (TTI)**   | 慢 (依赖JS下载执行完) | 中 (需Hydration)         | **快** (Hydration快)        | **快** (Hydration快)               |
| **SEO**                | 差/需额外处理         | **优**                   | **优**                      | **优**                             |
| **服务器压力**         | 低 (主要API)          | **高** (每次渲染)        | **极低** (仅静态文件)       | **低** (按需再生)                  |
| **数据实时性**         | 实时 (API调用)        | 实时 (请求时获取)        | 构建时 (固定)               | **可配置** (`revalidate`时间/按需) |
| **内容更新方式**       | JS动态更新            | 重新请求                 | **重新构建部署**            | **后台再生/按需触发**              |
| **成本**               | 中 (需要API服务器)    | 高 (需要计算型服务器)    | **极低** (静态托管)         | **低** (静态托管+少量计算)         |
| **安全性**             | 中 (暴露API)          | 中 (暴露服务器)          | **高** (纯静态)             | **高** (主要静态)                  |
| **开发复杂度**         | 低                    | 中高                     | 低                          | 中                                 |
| **典型用例**           | 后台SPA, 复杂交互应用 | 电商详情, 新闻, 高SEO页  | 博客, 文档, 营销页          | 电商, 新闻Feed, 需更新的SSG页      |
| **代表框架**           | CRA, Vite, Vue CLI    | Next.js, Nuxt, SvelteKit | Next.js, Gatsby, Nuxt, 11ty | **Next.js (最佳支持)**             |

## 如何选择？决策流程图

```mermaid
graph TD
A[开始] --> B{需要动态数据且变化频繁？}
B --> |是| C{对首屏性能和SEO要求高？}
C --> |是| D[SSR 或 ISG]
C --> |否| E[CSR]
B --> |否| F{内容基本静态？}
F --> |是| G[SSG]
F --> |否| H{数据变化频率中等，可接受短暂延迟？}
H --> |是| I[ISG]
H --> |否| D[SSR 或 ISG]
```

**决策要点：**

1. **数据变化频率：** 数据多久变一次？秒级？分钟级？小时级？天级？这是选择SSG vs SSR/ISG的关键。
2. **SEO需求：** 页面是否需要被搜索引擎良好索引？是则优先考虑SSR、SSG、ISG。
3. **性能要求：** 首屏速度 (FCP) 和可交互速度 (TTI) 有多重要？追求极致选SSG/ISG。
4. **用户交互复杂度：** 页面是否高度交互？是则CSR或SSR/SSG/ISG + 强大的客户端JS。
5. **基础设施与成本：** 是否有预算/能力维护服务器（SSR）？还是倾向于零服务器管理/低成本（SSG/ISG）？
6. **内容规模：** 页面数量巨大？SSG全量构建可能慢，ISR或SSR（配合缓存）可能是更好的选择。

## 结论：没有银弹，只有权衡

CSR、SSR、SSG、ISG 代表了Web渲染策略的演进，每一种都有其独特的优势和适用场景。现代框架（尤其是Next.js）的强大之处在于它们**支持混合渲染模式**：你可以为一个应用中的不同页面选择最合适的策略！

* 将营销首页、博客文章页用 **SSG/ISG** 实现极致性能和SEO。
* 将用户个人中心、设置页用 **CSR** 实现流畅交互（SEO不重要）。
* 将需要实时数据的特定页面（如最新交易）用 **SSR** 或 **ISR (短`revalidate`)**。

**理解这些模式的核心原理、优缺点和适用场景，是作为前端工程师做出明智架构决策的基础。** 选择哪种方案，最终取决于你的具体项目需求在性能、SEO、开发体验、成本和数据实时性之间的优先级排序。

---

---
url: /czxBlog/article/e8qbp0dh/index.md
---
# 正则表达式
*本文正则表达式基于`javascript`，不同的计算机语言对正则表达式的支持情况以及实现，语法不尽相同，不一定适用于其他语言。*

### 简介

`正则表达式`，是一种文本模式（Regular Expression），是对字符串的一种匹配查找规则。
可以方便的在某一文本字符串中，查找、定位、替换符合某种规则的字符串。

比如说，我们想要找出一段文本中的手机号码，文本内容如下：

```txt
name:Mark  tel:13800138000
name:Jhon  tel:13800138888
```

很明显，在这段文本中，手机号码是以 `tel:`开头，这符合一定的规则，这样我们可以通过正则表达式来书写这个规则，
然后去查找匹配：

```js
let text = `name:Mark  tel:13800138000
name:Jhon  tel:13800138888`

let result = text.match(/tel:(1\d{10})/)
// ["tel:13800138000", "13800138000", index: 0, input: "tel:13800138000", groups: undefined]
let tel = result[1]
// 13800138000
```

`/tel:(1\d{10})/` 便是所说的正则表达式。

### `RegExp` 与字面量

在`javascript`中，我们可以使用构造函数`RegExp` 创建正则表达式。

`new RegExp(pattern[, flags])`

```js
let regExp = new RegExp('\\d', 'g')
```

也可以通过 字面量的方式：

```js
let regExp = /\d/g
```

两种创建正则表达式适用的场景有些细微的不同，一般使用`new RegExp()`来创建动态的正则表达式，使用字面量创建静态的正则表达式。

正则表达式字面量是提供了对正则表达式的编译，当正则表达式保持不变时，用字面量的方式创建正则表达式可以获得更好的性能。

**以下讨论以正则表达式字面量来创建正则表达式：**

`正则表达式`一般由`元字符`和普通字符组成。

### 元字符

元字符也叫特殊字符，是正则表达式规定的，对符合特定的单一的规则的字符的描述。

|   字符   | 含义                                                                                                                                                                                                                                                                           |
| :------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|    \    | 在非特殊字符的前面加反斜杠，表示这个字符是特殊的，不能从字面上解释。比如在`\d`描述的不是一个普通的字符`d`,而是正则表达式中的数值`0-9`。如果在特殊字符前面加反斜杠，这表示将这个字符转义为普通字符，比如`?`在正则中有其特殊含义，前面加反斜杠?，这可以将其转为普通的`?`。 |
|    ^     | 匹配文本开始的位置，如果开启了多行标志，也会匹配换行符后紧跟的位置。比如`^a`会匹配`abc`，但不会匹配到`bac`。                                                                                                                                                              |
|    $     | 匹配文本结束的位置，如果开启了多行标志，也会匹配换行符前紧跟的位置。比如`b$`会匹配`acb`,但不会匹配到`abc`。                                                                                                                                                               |
|    \*    | 匹配前一个表达式0次到多次。 比如，`ab*`会匹配到`abbbbbbc`中的`abbbbbb`,以及`acbbbbb`中的`a`。                                                                                                                                                                              |
|    +     | 匹配前一个表达式1次到多次。 比如，`ab+`会匹配到`abbbbbbc`中的`abbbbbb`,但不会匹配`acbbbbb`。                                                                                                                                                                               |
|    ?     | 匹配前一个表达式0次到1次。 比如，`ab*`会匹配到`abbbbbbc`中的`ab`,以及`acbbbbb`中的`a`。                                                                                                                                                                                    |
|    .     | 匹配除换行符之外的任何单个字符。                                                                                                                                                                                                                                               |
|   x|y   | 匹配 x或者y。                                                                                                                                                                                                                                                                  |
| \[xyz]  | 表示一个字符的集合。匹配集合中的任意一个字符。可以使用破折号`-`来指定一个字符范围。比如，`[0-4]`和`[01234]`，都可以匹配`4567`中的`4`。                                                                                                                                     |
| \[^xyz] | 表示一个方向字符集合。匹配任意一个不包括在集合中的字符。可以使用破折号`-`来指定一个字符范围。比如，`[0-4]`和`[01234]`，都可以匹配`2345`中的`5`。                                                                                                                          |
|  {n}   | n为一个整数，表示匹配前一个匹配项n次。比如`a{2}`不会匹配`abc`中的`a`，但会匹配`aaaabc`中的`aa`。                                                                                                                                                                           |
| {m,n}  | m,n都是一个整数，匹配前一个匹配项至少发生了m次，最多发生了n次。当m，n值为0时，这个值被忽略，当n值不写，如`{1,}`表示1次到多次。当m值不写时，如`{,1}`表示0次到1次。                                                                                                          |
|   (x)    | 匹配`x`并且捕获该匹配项。称为捕获括号，括号中的匹配项也称作子表达式。                                                                                                                                                                                                          |
|  (?:x)   | 匹配`x`但不捕获该匹配项。称为非捕获括号。                                                                                                                                                                                                                                      |
|  x(?=y)  | 匹配`x`且当`x`后面跟着`y`。称为正向肯定查找（正向前瞻）。                                                                                                                                                                                                                      |
|  x(?!y)  | 匹配`x`且当`x`后面不跟着`y`。称为正向否定查找（负向前瞻）。                                                                                                                                                                                                                    |
|   \[\b]   | 匹配一个退格(U+0008)。                                                                                                                                                                                                                                                         |
|   \b    | 匹配一个词的边界。匹配的值的边界并不包含在匹配的内容中。                                                                                                                                                                                                                       |
|   \B    | 匹配一个非单词的边界。                                                                                                                                                                                                                                                         |
|   \d    | 匹配一个数字。等价于`[0-9]`。                                                                                                                                                                                                                                                  |
|   \D    | 匹配一个非数字。等价于`[^0-9]`。                                                                                                                                                                                                                                               |
|   \n    | 匹配一个换行符 (U+000A)。                                                                                                                                                                                                                                                      |
|   \r    | 匹配一个回车符 (U+000D)。                                                                                                                                                                                                                                                      |
|   \s    | 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于`[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`                                                                                                                              |
|   \S    | 匹配一个非空白字符。                                                                                                                                                                                                                                                           |
|   \t    | 匹配一个水平制表符 (U+0009)。                                                                                                                                                                                                                                                  |
|   \w    | 匹配一个单字字符（字母、数字或者下划线）。 等价于`[A-Za-z0-9_]`。                                                                                                                                                                                                          |
|   \W    | 匹配一个非单字字符。                                                                                                                                                                                                                                                           |
|  \xhh   | 与代码 hh 匹配字符（两个十六进制数字）                                                                                                                                                                                                                                         |
| \uhhhh  | 与代码 hhhh 匹配字符（四个十六进制数字）。                                                                                                                                                                                                                                     |

上表在多数文章都会提及，但有一些注意的细节，下面我单独拎出来说说。

1. **`[xyz]` 匹配集合中的任意一个字符**&#x20;
   这个字符集的元素，可以是普通字符，也可以是特殊字符，也可以用破折号`-`规定一个字符集范围。
   以匹配数字为例，可以写成`[0123456789]` ，也可以写成`[\d]`,也可以写成`[0-9]`。
   类似于`()`等特殊字符，在`[]`中有其作用，都特殊字符的作用一致，不能直接当做普通字符来使用，所以我们需要使用反斜杠`\`将其转义为普通字符，值得注意的是，上表的特殊字符中，星号`*`、小数点`.`在`[]`中并没有特殊用途，所以不需要做转义处理，当然，即使做了转义，也不会出现问题；而破折号`-`在`[]`中有其特殊作用，所以作为普通字符使用时，需要转义。

2. **`?`：匹配前一个表达式0次到1次。**
   其实这里准确描述来说，匹配前一个表达式，且该表达式 **非任何量词 `*`、 `+`、`?` 或 `{}`** ，匹配前一个表达式0次到1次。
   如果紧跟在 **非任何量词 `*`、 `+`、`?` 或 `{}`** 的后面，将会使量词变为非贪婪的（匹配尽量少的字符）
   *贪婪与非贪婪匹配，我们在下文细说。*

### 等价字符

正则表达式中，有不少特殊字符的写法，是等价的，也可以说是简写形式，下表的左右两边，都是等价的。

| regExp | regExp                                                                            |
| ------ | --------------------------------------------------------------------------------- |
| \*     | {0,}                                                                            |
| +      | {1,}                                                                            |
| ?      | {0,1}                                                                           |
| \d    | \[0-9]                                                                           |
| \D    | \[^0-9]                                                                          |
| \w    | \[a-zA-Z\*]                                                                       |
| \W    | \[^a-zA-Z\*]                                                                      |
| \s    | \[\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff] |

### 贪婪模式与非贪婪

**什么是贪婪模式？**

贪婪是指正则表达式匹配时，是贪心的，会尽可能的匹配多的字符，主要体现在`量词特殊字符`：

```js
// 匹配一个到多个数字
let r = /\d+/
let t1 = '12a'
let t2 = '1234a'
let t3 = 'a12b345'
console.log(t1.match(r)[0]) // 12
console.log(t2.match(r)[0]) // 1234
console.log(t3.match(r)[0]) // 12
```

`非贪婪`，即是让正则表达式匹配尽量少的字符。那么如何改变正则表达式的贪婪模式？

**在量词特殊字符后面紧跟使用`?`**

我们说说的量词包括`*`, `+`, `?`, `{m,n}`。那么紧跟了`?`，会有什么不同的表现呢？

我们从例子来分析：

```js
let r1 = /<div>.*<\/div>/
let r2 = /<div>.*?<\/div>/
let str = '<div>aaa</div>bbb<div></div>ccc'
```

变量`r1`是贪婪匹配，得到的结果会是什么呢？

```js
console.log(str.match(r1)[0])
// <div>aaa</div>bbb<div></div>
```

在这段字符串中，有两个`</div>`的匹配字符串，正则表达式在遇到第一个`</div>`匹配字符项时，同时满足了`/.*/`和`/<\/div>/`的匹配条件，优先作为`/.*/`的匹配值，在遇到第二个时，同样还是优先作为`/.*/`的匹配值，直到匹配的字符串`str`的结束，没有满足条件的匹配字符串，再把第二个`</div>`作为`/<\/div>/`的匹配值。最终得到了`<div>aaa</div>bbb<div></div>`的匹配结果。

变量`r2`这是非贪婪匹配，得到的结果又会有所不同：

```js
console.log(str.match(r1)[0])
// <div>aaa</div>
```

同样，两个`</div>`的匹配字符串，但实际非贪婪匹配模式，在匹配到第一个`</div>`，就不会再继续向下匹配字符串了。

**也就是说，贪婪匹配是，在满足规则下，尽可能多的匹配更多的字符串，直到字符串结束或没有满足规则的字符串了；非贪婪匹配是，在满足规则下，尽可能少的匹配最少的字符串，一旦得到满足规则的字符串，就不再向下匹配。**

1. `x*?`：尽可能少的匹配`x`，匹配的结果可以是0个`x`；
2. `x+?`：尽可能少的匹配`x`，但匹配的结果至少有1个`x`；
3. `x??`：尽可能少的匹配`x`, 匹配的结果可以是0个`x`，但最多可以有一个`x`；
4. `x{m,n}?`：尽可能少的匹配`x`，但匹配的结果至少有m个`x`，最多可以有n个`x`；

可能从字面来说，不好理解 `x??`, `x{m,n}?` ，来看一个例子就可以明白了：

```js
let s1 = '<div>aa</div>'
let s2 = '<div>a</div>'
let s3 = '<div></div>'
let r1 = /<div>a?<\/div>/

console.log(r1.test(s1)) // false
console.log(r1.test(s2)) // true
console.log(r1.test(s3)) // true
```

```js
let s1 = '<div>aaa</div>'
let s2 = '<div>aa</div>'
let s3 = '<div>aaaa</div>'
let r1 = /<div>a{2,3}<\/div>/
let r2 = /<div>a{2,3}?/

console.log(r1.test(s1)) // true
console.log(r1.test(s2)) // true
console.log(r1.test(s3)) // false

console.log(s1.match(r2)[0]) // <div>aa
console.log(s2.match(r2)[0]) // <div>aa
console.log(s3.match(r2)[0]) // <div>aa
```

### 正则表达式标志

| 标志  | 描述                                               |
| :---: | -------------------------------------------------- |
|   g   | 全局搜索                                           |
|   i   | 不区分大小写搜索                                   |
|   m   | 多行搜索                                           |
|   y   | 执行“粘性”搜索,匹配从目标字符串的当前位置开始      |
|   u   | Unicode模式。用来正确处理大于 \uFFFF 的Unicode字符 |

**`m`**

使用`m`标志时，会改变开始（`^`）和结束字符（`$`）的工作模式，变为在多行上匹配，分别匹配每一行的开始和结束，即`\n`或`\r` 分割。

**`y`**

使用`y`标志时，匹配是从`RegExp.lastIndex`指定的位置开始匹配，匹配为真时，会修改 `lastIndex`的值到当前匹配字符串后的位置，下次匹配从这个位置开始匹配，如果匹配为假时，不会修改`lastIndex`的值。

```js
let reg = /o/y
let str = 'foo'

// lastIndex 为 0，从字符 f 开始匹配
reg.test(str) // false
// 由于结果为 false， lastIndex 还是为 0
reg.test(str) // false

let str2 = 'oof'
// lastIndex 为 0 ，从字符 o 开始匹配
reg.test(str2) // true
//  lastIndex 此时修改为 1, 从第二个 o 开始匹配
reg.test(str2) // true
// lastIndex 此时修改为 2
reg.test(str2) // false   此时开始匹配的字符是 f
// lastIndex没有被修改
reg.test(str2) // false
```

### 正则表达式中的捕获—— \1,\2,\3... 以及 $1,$2,$3

在上文中我们介绍了 `(x)` 是匹配 `x` 并捕获，那么有了捕获就必然可以去使用捕获到的结果， `\1,\2,\3...` 以及`$1,$2,$3...` 便是指捕获的结果。

`\1, \2, \3, \4, \5, \6, \7, \8, \9` 在正则表达式中使用，捕获结果为正则表达式的源模式.

在这个正则表达式中`(bc)`被捕获并标记为`\1`, `(ef)`被捕获并标记为`\2`。

```js
let reg = /a(bc)d(ef)/
```

也可以使用来简化正则表达式

```js
let reg = /a(bc)dbc/
let reg2 = /a(bc)d\1/

let str = 'abcdbc'

reg.test(str) // true
reg2.test(str) // true
```

`$1, $2, $3, $4, $5, $6, $7, $8, $9` 是`RegExp`的包含括号子表达式的正则表达式静态的只读属性。

```js
let reg = /a(bc)d/
let str = 'abcd'

reg.test(str)
console.log(RegExp.$1) // bc
```

在 `String.replace()` 中使用：

```js
let reg = /(\w+)\s(\w+)/
let str = 'apple pear'
str.replace(reg, '$2 $1') // pear apple
RegExp.$1 // apple
RegExp.$2 // pear
```

---

---
url: /czxBlog/article/ecdgrife/index.md
---
# 浅谈前端低代码
前端低代码在最近的这两年，不少的公司或技术团队都对此青睐有佳，并各自实现了各自的低代码平台。

## 前言

前端低代码，是指 无需代码或者仅需少量的代码，即可生成可交互的应用。

这个概念的兴起，期望于能够更快的去构建、部署新的应用，并降低门槛，让非技术开发人员也能够构建新的应用。

## 为什么做低代码

传统的应用开发从启动到发布的过程，大致的流程如下：
::: center
![low-code-1](//assets.processon.com/chart_image/6320a2fb637689341d579d34.png)
:::

在这个过程中，我们需要花费大量的时间用于 代码开发 -> 测试 这个过程，在这个过程，还需要根据项目大小，组织多个开发人员、测试人员等参与到项目中，包括制定开发规范、测试规范等。

而对于某些场景的应用，可能整个应用的生命周期相对较短，多个应用之间存在着类似的功能、需求、设计等等，然而在传统的项目开发中，
我们仍然需要按照上述的流程，完整的走一遍，才能正式发布上线，这无疑会花费大量的时间。一般我们会通过抽离重复的功能、需求、UI等为
独立的库、组件等，在新项目中实现复用，从而减少开发时间，然而这并不能对项目的发布速度有质的提升。

而对于一些小型企业，或者个体经营户，期望做一个线上应用，但并没有多余的资金资源去组建一个开发团队，对购买服务器、上线应用等更是一知半解，成为了制约他们发展的一道坎。

对于这些场景、存在的问题，需要需要一种方案，能够实现快速的实现从创建项目到发布部署为可访问的项目，并且能够面向更广泛的用户群体。
这成为了一个非常具有市场潜力的需求。

## 如何做低代码

对于一个前端应用，通常由多个页面组成，在现代前端开发中，我们将页面拆分为一个个组件来进行组合：

![low code 1](//assets.processon.com/chart_image/6320ccbf1efad46b0aa9d631.png)

在 前端低代码 中，我们同样的，可以通过 组件来组装页面，通过可视化的交互方式，将组件拖拽到 页面容器中，
这种交互方式相对来说更加适用于更多的群体。

![low code 2](//assets.processon.com/chart_image/6320d1830e3e743f58315ed7.png)

同时，需要提供能够对组件进行编辑状态的能力，以支持应用的个性化配置。

![low code 3](//assets.processon.com/chart_image/6321b4420e3e743f5833bbc8.png)

在初步确定好 基础的功能、交互方式后，就可以围绕它们，来完善 实现低代码平台的技术方案。

***

初步明确的，我们需要 通过 **组件** 来组装 应用，围绕这一块，需要实现：

* 低代码组件的规范：开发规范、接入规范；
* 用于承载组件、组装组件并渲染的应用容器；
* 组件的状态的更新与保存；

---

---
url: /czxBlog/article/exports-esm-and-cjs/index.md
---
# 单仓库实现同时导出esm、cjs
在开发一些公共模块作为一个独立仓库时，有时候可能会在一个使用 es 的项目中通过 `import` 导入，
有可能在一个 cjs 项目中通过 `require` 导入。

如何实现单个仓库能够同时被 cjs 和 esm 项目导入呢？

## 为什么这么做？

在过去的时间里，JavaScript 并没有一套标准的模块化系统，并且在过去的时间里，逐渐发展出了各种模块化解决方案，
其中最主流的有两种模块化方案：

* `CommonJs`： 即`cjs`,通过 `require('package')` 导入，`module.exports` 导出。
  这套模块化系统应用与在`NodeJs` 和 `NPM packages`。

  ```js
  // in cjs
  const _ = require('lodash')
  console.log(`assignIn: `, _.assignIn({ b: '2' }, { a: '1' }))
  // { a: '1', b: '2' }
  ```

* `Ecmascript modules`: 即`esm`，在2015年，`esm` 最终确定为标准模块化系统，浏览器以及各个社区开始逐渐
  迁移并支持`esm`。

  ```js
  import { assignIn } from 'lodash'
  console.log(`assignIn: `, assignIn({ b: '2' }, { a: '1' }))
  // { a: '1', b: '2' }
  ```

  `ESM`使用 `named exports`，能够更好的支持静态分析，对各种打包工具有利于做`tree-shaking`，
  而且浏览器原生支持，作为一个标准，代表的是JavaScript的未来。

  同时，在`NodeJs` 的 `v12.22.0`、`v14.17.0`版本，开始实验性的支持`ESM`，并在`16.0.0`版本开始正式支持`ESM`。

::: note

* ESM - [ECMAScrip modules](https://nodejs.org/api/esm.html)
* CJS - [CommonJs](https://nodejs.org/api/modules.html#modules-commonjs-modules)

:::

目前有很多包仅支持 `CJS` 或者 `ESM` 格式。 但同时，也有越来越多的包推荐并仅支持导出 `ESM` 格式。

但是相对来说，就目前而言，作为一个库，仅支持`ESM` 格式还是过于激进了。即使在 `NodeJs v16`已开始正式支持`ESM`，
但是整个社区的迁移还是需要大量的时间成本和人力成本的，如果某个版本破坏性的从`CJS`支持迁移到`ESM`，
那么可能导致一系列问题。

所以，如果一个库，能够同时支持`ESM`以及`CJS`，是一种相对来说更为安全的迁移方案。

## 共存问题

我们知道，`Nodejs` 能够很好的同时支持 `ESM` 和 `CJS` 进行工作，但是，有一个最主要的问题是，不能在一个 `CJS` 中
导入`ESM`，这时候会抛出一个错误：

```js
// cjs package
const pkg = require('esm-only-package')
```

```
Error [ERR_REQUIRE_ESM]: require() of ES Module esm-only-package not supported.
```

因为`ESM` 模块本质上是一个异步模块，所以不能用 `require()` 方法同步的导入一个异步的模块。
但是这并不意味着完全不能在 `CJS` 模块中使用`ESM` 模块，我们可以使用 动态 `import()` 的方式，来异步的导入`ESM` 模块。
`import()` 会返回一个 `Promise`：

```js
// CJS
const { default: pkg } = await import('esm-only-package')
```

但是，这并不是一个令人满意的解决方案，它与我们日常使用的模块导入方式来说，显得有点笨拙，不符合一般使用习惯，
我们还是更期望能够符合一般习惯的导入方式：

```js
import cjs from 'cjs-package'
// ESM
import { named } from 'esm-package'
```

## 如何做？

### package.json

在现在的稳定版本的`NodeJs` 中，已经支持同时在一个包中导出两种不同的格式。
在`package.json` 文件中，有一个`exports` 字段，提供给我们有条件的导出不同格式。

```json
{
  "name": "package",
  "exports": {
    ".": {
      "require": "./index.js",
      "import": "./index.mjs"
    }
  }
}
```

这一段声明描述了， 当进行导入包的默认模块时，如果是通过 `require('package')` 进行导入，那么引入的是 `./index.js` 文件，如果是通过`import pkg from 'package'`进行导入，那么引入的是 `./index.mjs` 文件。

`Nodejs` 会根据当前运行环境，选择合适的导入方式将包进行导入。

所以我们可以借助这一特性，来完成我们单仓库支持两个格式的第一步。

然后，下一个要解决的，就是如何构建两个格式的导出文件。

### Building

我们当然不可能为了同时支持`CJS`和 `ESM`，而编写两份代码。

但我们可以借助一些构建打包工具，来生成`ESM`和`CJS`代码。

通常情况下，我们可能会使用 `rollup` 来构建打包我们的模块。
或者也可以使用 `tsup` 来构建。

#### rollup

当我们会选择 `rollup` 来构建一个库时，可能配置如下：

```js
// rollup.config.js
export default {
  input: 'src/index.js',
  output: {
    file: './dist/index.js',
  },
}
```

由于`rollup` 是支持多配置打包的，所以我们可以使用多配置的方式，同时打包输出两种格式的文件：

```js
// rollup.config.js
export default [
  {
    input: 'src/index.js',
    output: {
      file: './dist/index.js',
      format: 'cjs',
    },
  },
  {
    input: 'src/index.js',
    output: {
      file: './dist/index.mjs',
      format: 'es',
    },
  },
]
```

#### tsup

`tsup` 是一个面向 `TypeScript` 的打包工具，基于 `esbuild`， 可以很方便的将我们的库打包成多种模式进行输出：

`tsup` 可以支持零配置，直接使用命令行即可输出两种格式

```sh
tsup src/index.ts --format esm,cjs
```

执行完成后，将会得到两个文件：`cjs` 格式文件`dist/index.js` 和 `esm`格式文件`dist/index.mjs` 。

使用构建工具构建完成后，接下来就是完善 `package.json`，

建议在使用 `type` 字段声明为 `module`, 来声明当前库时一个标准的 esm 库，以及添加 `main`,`module`,`exports`字段,
以便向下兼容：

```json
{
  "name": "my-package",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "exports": {
    ".": {
      "require": "./dist/index.js",
      "import": "./dist/index.mjs"
    }
  },
  "types": "./dist/index.d.ts",
  "files": ["dist"]
}
```

最后，你的 `CJS` 项目中，或者 `ESM` 项目中，均可以根据环境要求，导入这个包。

```js
// cjs
const pkg = require('my-package')
```

```js
// esm
import pkg from 'my-package'
```

## 总结

虽然 `Nodejs` 从 `v14.18.0` 版本开始稳定支持 `esm` ，并且到 `v16` 版本，正式支持 `esm`。
但将库升级到仅支持`esm` 还是一个比较激进的做法，建议从相对安全的 双格式支持 开始迁移，在合适的时机，过渡到仅支持`esm`。

---

---
url: /czxBlog/article/extends-prototype/index.md
---
# 继承与原型链
当谈到继承时，javascript只有一种结构：对象。
每个实例对象（object）都有一个私有属性`__proto__`指向它的构造函数的原型对象 **prototype**。
该原型对象也有自己的原型对象`__proto__`，层层向上，直到有一个的原型对象为null。根据定义，null没有原型，并作为这个原型链的最后一个环节。

几乎所有javascript中的对象，都是位于原型链顶端的`Object`的实例。

## 基于原型链的继承

### 继承属性

`javascript` 对象是动态的属性"包裹"（指自身的属性）。同时，对象还有一个指向一个原型对象的链。
当访问一个对象的属性时，不仅会在该对象上查找，也会在该对象的原型上查找，进而在该对象的原型的原型上查找，
依次层层向上查找，直到找到匹配的属性，或者到达原型链的末尾。

::: info ECMAScript标准
`obj.[[Prototype]]`符号用于指向`obj`的原型。从`ES6`开始`[[Prototype]]`
可以通过`Object.getPrototypeof()`和 `Object.setPrototypeof()` 访问器进行访问。
等同于许多浏览器实现的属性`__proto__`。
:::

从代码示例来分析继承属性：

在这个示例中，定义了一个函数`Foo`， 它拥有自身属性 `a`和`b`。

然后创建一个 `Foo` 的示例 `foo`。

```js
function Foo() {
  this.a = 1
  this.b = 2
}
let foo = new Foo()

Foo.prototype.c = 3
Foo.prototype.d = 4

// 输出自身的所有属性
console.log(foo) // { a: 1, b: 2 }

// 自身拥有属性 a
console.log(foo.a) // 1
// 自身拥有属性 b
console.log(foo.b) // 2
// 自身没有属性 c, 但其原型上有属性 c
console.log(foo.c) // 3
// 自身没有属性 d，但其原型上有属性 d
console.log(foo.d) // 4
```

在这个示例中， 整个原型链如下

```js
// { a: 1, b: 2 } => { c: 3, d: 4 } => Object.prototype => null
```

### 继承方法

在`Javascript` 中，并没有其他基于类的语言所定义的 方法。
任何函数都可以添加到对象上做为对象的属性。
函数属性的继承与其他属性的继承没有差别。

当继承的函数被调用时，`this`指向的是当前继承的对象，而不是继承的函数所在的原型对象。

```js
let o = {
  a: 1,
  f() {
    return this.a + 1
  },
}

// 此时 函数f 中的 this 指向了 o
console.log(o.f()) // 2

let p = Object.create(0)
p.a = 3

// p从o上继承了函数f， 此时函数f中的 this 指向了 p
console.log(p.f()) // 4
```

## 创建对象和生成原型链

### 使用语法结构创建的对象

```js
let o = { a: 1 }
// 原型链： o => Object.prototype => null

let arr = ['a', 'b']
// 原型链： arr => Array.prototype => Object.prototype => null

function f() {}
// 原型链： f => Function.prototype => Object.prototype => null
```

### 使用构造器创建对象

```js
function Person() {
  this.a = 1
}
Person.prototype = {
  f() {
    return this.a
  },
}
let p = new Person()
// 原型链： p => Person.prototype => Object.prototype => null
```

### 使用`Object.create`创建的对象

```js
let a = { a: 1 }
let b = Object.create(a)
// 原型链 b => a => Object.prototype => null

let c = Object.create(null)
// 原型链 c => null
```

## 扩展原型链的方法

### 构造器创建对象，原型赋值给另一个构造函数原型

```js
function Foo() {}
foo.prototype = {
  a: 'foo',
}

function Bar() {}

let proto = new Foo()
proto.b = 'bar'
Bar.prototype = proto

let p = new Bar()
console.log(p.a) // foo
console.log(p.b) // bar
```

### Object.create

```js
function Foo() {}
Foo.prototype = {
  a: 'foo',
}
function Bar() {}

let proto = Object.create(Foo.prototype)
proto.b = 'bar'
Bar.prototype = proto

let p = new Bar()
console.log(p.a) // foo
console.log(p.b) // bar
```

```js
function Foo() {}
Foo.prototype = {
  a: 'foo',
}

function Bar() {}

let proto = Object.create(Foo.prototype, { b: 'bar' })
Bar.prototype = proto

let p = new Bar()
console.log(p.a) // foo
console.log(p.b) // bar
```

---

---
url: /czxBlog/article/fe5ruia1/index.md
---
# CSS 媒体查询
开发响应式网站时，常常需要使用到 media 媒体查询。这里总结下媒体查询的使用方法。

## 概述

媒体查询是通过判断当前媒体是否满足 媒体查询规则，从而使其包含的 CSS规则生效。

从 CSS level 2 开始，就已经支持 `media-queries`，到 CSS level 3 以及之后的版本，媒体查询变得更加的丰富和能够适应更多的场景。

## 使用

媒体查询可以通过以下三种方式进行使用：

### 在 `<link>` 元素引入CSS资源时，声明 `media` 属性

```html
<link rel="stylesheet" type="text/css" href="media/custom.css" media="screen and (min-width: 400px)" />
```

### 在`<style>` 上 声明 `media` 属性

```html
<style media="screen and (min-width: 400px)"></style>
```

### 在`@import` 后 声明 媒体查询条件

```css
@import url('custom.css') screen and (min-width: 400px);
```

### 在样式表中使用 At-Rule `@media` 使用媒体查询规则

```css
@media screen and (min-width: 400px) {
  .example {
    color: red;
  }
}
```

## 语法

```html
<link rel="stylesheet" type="text/css" href="media/custom.css" media="[media-queries-list]" />

<style media="[media-queries-list]"></style>

<style>
    @import url [media-queries-list];

    @media [media-queries-list] {
      <style-sheet-group>
  }
</style>
```

## 媒体查询 \[media-queries-list]

`media-queries-list` 可以由以下三种内容组成：

* `Media types` ：媒体类型, 表示设备
* `Media features` ：媒体特性, 表示设备的状态
* `Logical operators` ： 逻辑操作符, 连接多个 `media-query`

### Media types

`Media types` 描述设备的一般类型。可以使用以下值：

* `all`: 表示适用于所有设备。 默认值。
* `print`: 表示 适用于在屏幕上以打印预览的模式查看页面和文档。
* `screen`: 表示 适用于屏幕 。

> 在 *css2.1* 和 *Media Queries 3* 中还支持 `tty`，`tv`，`projection`，`handheld`，`braille`，`embossed`，`aural`，但这些值都已经在*Media Queries 4* 中被弃用。

### Media features

媒体特性，描述 用户代理、输出设备以及环境的特定特征。

媒体特性表达式是完全是可选的，并且负责测试这些特性是否存在，值为多少。 且每个媒体特性表达式都必须使用括号括起来。

*以下仅列出比较常用到的媒体特性：*

* `width`: 视窗（viewport）的宽度，包括纵向滚动条的宽度。

  值的类型为 number，单位可以是 `px`、`em` 等。

  ```css
  with: 400px;
  ```

* `height`: 视窗（viewport）的高度。

  值的类型为 number，单位可以是 `px`、`em` 等。

  ```css
  height: 600px;
  ```

* `aspect-ratio`： 视窗（viewport）的宽高比。

  值的类型为 number/number。

  ```css
  aspect-ratio: 3/2;
  ```

* `orientation`： 视窗（viewport） 的旋转方向。

  * portrait： 设备竖屏
  * landscape： 设备横屏

  ```css
  orientation: landscape;
  ```

* `resolution`: 输出设备的分辨率

  值的类型为 number，单位为 `dpi`。

  ```css
  resolution: 320dpi;
  ```

* `scan`：输出设备的扫描过程（适用于电视机等）。

#### 媒体特性前缀

大部分的媒体特性均支持前缀，用于约束媒体特性的作用范围。

* `max-[media feature]`： 小于指定的最大值时，返回*true*
* `min-[media feature]`: 大于指定的最小值时，返回*true*

*个人认为使用前缀时其表述稍显拗口，建议使用取值范围的方式声明表达式：*

#### 媒体特性语法

* 以键值对的形式，表述取固定的值

  ```
  ([media-feature-name]: [media-feature-value])
  ```

* 直接书写name， 表示值的结果为 boolean

  ```
  ([media-feature-name])
  ```

* 表述 特性的取值范围

  *声明 range 为描述数学符号 : '<' | '>' | '<=' | '>='*

  ```
  ([media-feature-name] [range] [media-feature-value])
  ([media-feature-name] [range] [media-feature-value] [range] [media-feature-value])
  ```

### Logical operators

逻辑操作符用于组成复合的 media queries。

* `and`: 用于合并多条`media query`, 且 每条 `media query` 均返回 *true* 时，
  媒体查询表达式的结果返回*true*。
* `not`: 取反操作，使用`not [media query]`，当`media query` 返回 *false* 时，
  媒体查询表达式的结果返回*true*。
* `,`: or操作符，组合多个 `media query`，任意一个`media query` 返回 *true*,
  媒体查询表达式的结果返回*true*。
* `only`: 不支持更加高级的媒体类型的浏览器检测到only修饰的时候就会抛弃这个规则

## 使用示例详解

### 示例1

```css
@media screen and (width > 414px) {
}
```

当设备的屏幕视窗宽度大于414px时，应用CSS块中的样式规则。

### 示例2

```css
@media (width > 800px), screen and (orientation: landscape) {
}
```

当前设备 视窗宽度大于 800px， 或者设备方向为横向时，应用css块中的样式规则。

### 示例3

```css
@media screen and (414px < width < 800px) {
}
```

当前设备屏幕视窗宽度 大于 414px 且 小于 800px 时， 应用css块中的样式规则。

---

---
url: /czxBlog/article/fpcpgpod/index.md
---
# JavaScript进阶（二）— 词法作用域
## 作用域

作用域是指 程序源代码中，定义变量的区域。

作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。

## 词法作用域

在 `JavaScript` 中，采用的是 词法作用域， 即静态作用域。

词法作用域规定了，函数的作用域是在 **函数定义的时候就确定** 了。

### 示例

```js
let a = 1
function foo() {
  console.log(a)
}
function bar() {
  let a = 2
  foo()
}
bar()
```

这个示例的执行结果为 `1`。

在这个例子中， 由于 函数`foo` 的作用域在 定义的时候就确定了，即使在 函数`bar` 中也有相同的变量名`a`的定义，
但是由于两个函数在定义时，作用域是相互独立的，函数`foo`在其作用域查找局部变量`a`，没有找到，
继续从它书写位置往上查找上一层的代码，所以输出的结果为 `1`。

---

---
url: /czxBlog/article/fybr4lt3/index.md
---
# Webpack场景下的项目优化方案
::: center
![webpack](https://www.webpackjs.com/icon-square-small.85ba630cf0c5f29ae3e3.svg){width=100}
:::

在一个基于 webpack 作为构建工具的前端项目中，通常会有以下两个方面进行优化。

1. [编译构建时间优化](#编译构建时间优化)
2. [构建产物优化](#构建产物优化)

## 编译构建时间优化

编译构建时间优化，旨在加快每次构建的速度，减少构建时间。
它包括，开发时每次修改文件重新编译时的时间开销；为项目构建最终产物时的总体时间开销。

优化的方向包括：

1. [编译构建时间优化](#编译构建时间优化).
2. [缩小文件匹配范围](#缩小文件匹配范围).
3. [文件后缀匹配](#文件后缀匹配).
4. [缓存](#缓存).
5. [并行构建](#并行构建).

### 缩小文件匹配范围

在配置 webpack loader 时，通常会指定两个属性：`test` 和 `use` ，用以声明哪些文件需要被转换。

```js
module.exports = {
  module: {
    rules: [{ test: /\.txt$/, use: 'raw-loader' }],
  },
}
```

在默认情况下，匹配查找范围是相对于项目根目录的上下文进行搜索，当项目文件数量很多时，这个过程会非常耗时。
在这种情况下，可以使用 `include` 和 `exclude` 两个属性来限制文件匹配范围。

```js
const path = require('node:path')
module.exports = {
  module: {
    rules: [
      {
        test: /\.txt$/,
        use: 'raw-loader',
        include: path.resolve(__dirname, 'src'),
        exclude: /node_modules/,
      },
    ],
  },
}
```

* `exclude` : 排除所有符合条件的文件
* `include` : 只包含所有符合条件的文件

合理的使用 `include` 和 `exclude` 属性可以有效的减少文件匹配范围，从而减少构建时间。

> **参考：** [webpack module.rules](https://www.webpackjs.com/configuration/module/#rule)

### 文件后缀匹配

通常我们在导入模块时，习惯忽略文件后缀名，因为 `webpack` 会帮助进行补全。

但这是有代价的，webpack 内部尝试使用内置配置，补全后缀后查找文件时候存在，再尝试加载，直到匹配到文件，
这会造成额外的 I/O 开销。

一方面，可以通过修改 webpack 的配置 `resolve.extensions`，调整 后缀补全的规则，并通过顺序控制补全的优先级，
将最常用的文件后缀放在最前面，并减少非必要的后缀名。

```js
module.exports = {
  resolve: {
    // .md, .json 等非必要的，则不要写入配置
    extensions: ['.tsx', '.ts', '.js'],
  },
}
```

另一方面，在导入模块时，尽量不要忽略文件后缀名。

> **参考**： [webpack resolve.extensions](https://www.webpackjs.com/configuration/resolve/#resolveextensions)

### 缓存

每次启动构建，如果都需要重新编译所有的文件，那么势必会花费很长的时间，
所以需要对编译结果进行缓存，以便下次直接加载缓存的结果，并只对修改的文件进行重新编译。

在 `webpack5` 中，提供了 `cache` 配置，可直接开启缓存。

```js
module.exports = {
  cache: {
    type: 'filesystem',
  },
}
```

> **参考**： [webpack cache](https://www.webpackjs.com/configuration/cache/#cache)

### 并行构建

webpack 运行在 NodeJS 环境中，是单线程的，所以一次只能干一件事。
而目前主流的电脑都是多核的，可以利用这一特性，让 webpack 并行构建。
通常情况下，使用 [thread-loader](https://github.com/webpack-contrib/thread-loader) 来实现并行构建。

```js
module.exports = {
  module: {
    rules: [
      {
        test: /.jsx?$/,
        use: [
          // 开启多进程打包。
          {
            loader: 'thread-loader',
            options: {
              workers: 3, // 开启 3个 进程
            },
          },
          { loader: 'babel-loader' },
        ],
      },
    ],
  },
}
```

放置在 thread-loader 之后的 loader 会在一个单独的 worker 池(worker pool) 中运行。
每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。所以建议仅在耗时的 loader 上使用。

如果项目不大，文件不多，则没必要使用 thread-loader。其本身也有额外的性能开销。

## 构建产物优化

构建产物优化，旨在 减少构建产物的体积，合理的组织构建产物，从而提高页面的加载速度，首屏加载速度等。

通用的构建优化包括：

1. [压缩 `js`, `css`，`html` 代码](#压缩-js-csshtml-代码).
2. [压缩图片资源](#压缩图片资源).
3. [代码分割](#代码分割).
4. [按需加载](#按需加载).
5. [preload, prefetch](#preload-prefetch).
6. [tree-shaking](#tree-shaking).

### 压缩 js, css，html 代码

#### 压缩 js

使用 `terser-webpack-plugin` 来压缩 js 代码:

```js
const TerserPlugin = require('terser-webpack-plugin')
module.exports = {
  optimization: {
    minimize: true,
    minimizer: [new TerserPlugin()],
  },
}
```

#### 压缩 css

通过 `css-minimizer-webpack-plugin` 来压缩 css 代码，
同时使用 `mini-css-extract-plugin` 将 css 提取到单独的文件中。

```js
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          // 提取成单独的文件
          MiniCssExtractPlugin.loader,
          'css-loader',
        ],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      // 定义输出文件名和目录
      filename: 'asset/css/style.css',
    }),
  ],
  optimization: {
    minimize: true,
    minimizer: [
      // 压缩 css
      new CssMinimizerPlugin({}),
    ],
  },
}
```

#### 压缩 html

使用 `html-webpack-plugin` 来压缩 html 代码。

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')
module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      // 动态生成 html 文件
      template: './index.html',
      minify: {
        // 压缩HTML
        removeComments: true, // 移除HTML中的注释
        collapseWhitespace: true, // 删除空⽩符与换⾏符
        minifyCSS: true, // 压缩内联css
      },
    }),
  ],
}
```

### 压缩图片资源

压缩 图片资源的方法多种多样，需要根据实际的情况进行选择。
其中还包括多倍图的处理，如：`@2x`、`@3x`、`@4x` 等。

比如，可以使用 `image-webpack-loader` 来实现图片压缩。

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpg|gif|jpeg|webp|svg)$/,
        use: [
          'file-loader',
          {
            loader: 'image-webpack-loader',
            options: {
              mozjpeg: { progressive: true },
              optipng: { enabled: false },
              pngquant: { quality: [0.65, 0.9], speed: 4 },
              gifsicle: { interlaced: false },
            },
          },
        ],
        exclude: /node_modules/,
      },
    ],
  },
}
```

### 代码分割

如果是一个 中大型项目，或者是一个 MPA 项目，一般会拥有多个页面，
但都是使用的相同的技术栈，有重复使用的公共资源。
如果每个页面的代码都独自包含这些相同的代码，则会导致资源的浪费，每次加载不同页面都会加载重复的资源，
浪费用户的流量，页面加载缓慢，影响用户体验。

在这种情况下，将第三方的模块、公共资源单独拆分为独立的文件，
利用缓存机制，不同页面加载的时候只需要花费首次加载的时间，减少二次加载等待时间。

```js
module.exports = {
  // ...
  optimization: {
    splitChunks: {
      chunks: 'async', // 值有 `all`，`async` 和 `initial`
      minSize: 20000, // 生成 chunk 的最小体积（以 bytes 为单位）。
      minRemainingSize: 0,
      minChunks: 1, // 拆分前必须共享模块的最小 chunks 数。
      maxAsyncRequests: 30, // 按需加载时的最大并行请求数。
      maxInitialRequests: 30, // 入口点的最大并行请求数。
      enforceSizeThreshold: 50000,
      cacheGroups: {
        defaultVendors: {
          test: /[\/]node_modules[\/]/, // 第三方模块拆出来
          priority: -10,
          reuseExistingChunk: true,
        },
        utilVendors: {
          test: /[\/]utils[\/]/, // 公共模块拆出来
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true,
        },
      },
    },
  },
}
```

> **参考**： [代码分离](https://www.webpackjs.com/guides/code-splitting)

### 按需加载

大多数时候，使页面达到可用，并不需要加载所有的资源。

比如在 SPA/MPA 应用中，通过路由来实现不同的页面，如果所有的页面代码都打包在相同的文件，
那么加载某个页面的代码时，实际上也加载了其它页面的代码，导致页面的加载速度达不到预期。

因为，将 路由页面的资源拆分为不同的文件，使用时才加载这些资源，可以减少当前页面的加载时间。

```js
const List = lazyComponent('list', () => import(/* webpackChunkName: "list" */ '@/pages/list'))
const Detail = lazyComponent('detail', () => import(/* webpackChunkName: "detail" */ '@/pages/detail'))
```

进一步的，越尽快的让页面渲染，就越有利于用户体验。
因此，还可以分析当前页面完成首屏渲染所需要的关键资源，将非关键资源拆分出去，首次只加载
关键资源，完成后再加载非关键资源。

### preload, prefetch

* refetch（预获取）：将来某些导航下可能需要的资源
* preload（预加载）：当前导航下可能需要资源

在webpack中使用 `prefetch` 实现预获取：

```js
// ...
import(/* webpackPrefetch: true */ './path/to/LoginModal.js')
```

这会生成 `<link rel="prefetch" href="login-modal-chunk.js">` 并追加到页面头部，指示浏览器在闲置时间预取 login-modal-chunk.js 文件。

在webpack中使用 `preload` 实现预加载：

```ts
// ...
import(/* webpackPreload: true */ 'ChartingLibrary')
```

在页面中使用 `ChartComponent` 时，在请求 `ChartComponent.js` 的同时，
还会通过 `<link rel="preload">` 请求 `charting-library-chunk`。
假定 `page-chunk` 体积比 `charting-library-chunk` 更小，也更快地被加载完成，
页面此时就会显示 `LoadingIndicator` ，等到 `charting-library-chunk` 请求完成，
`LoadingIndicator` 组件才消失。这将会使得加载时间能够更短一点，因为只进行单次往返，
而不是两次往返，尤其是在高延迟环境下。

> **参考**： [webpack prefetch/preload](https://www.webpackjs.com/guides/code-splitting#prefetchingpreloading-modules)

### tree-shaking

`tree shaking` 在**生产模式下已经默认开启**

需要注意的是：

* 只对ESM生效
* 只能是静态声明和引用的 ES6 模块，不能是动态引入和声明的。
* 只能处理模块级别，不能处理函数级别的冗余。
* 只能处理 JS 相关冗余代码，不能处理 CSS 冗余代码。

对于 CSS资源， 可以使用 `purgecss-webpack-plugin` 插件对 CSS 进行 tree-shaking。

```js
const PurgecssPlugin = require('purgecss-webpack-plugin')
module.exports = {
  plugins: [
    new PurgeCSSPlugin({
      paths: glob.sync('src/**/*', { nodir: true }),
    }),
  ],
}
```

> **参考**： [webpack tree-shaking](https://www.webpackjs.com/guides/tree-shaking/)

---

---
url: /czxBlog/article/gq88mn6a/index.md
---
# webpack原理的简单入门
::: center
![webpack](https://www.webpackjs.com/icon-square-small.85ba630cf0c5f29ae3e3.svg){width=100}
:::

## 前言

我们知道， `webpack` 作为前端工程化中，主流的模块打包工具之一，应用于各种各样的前端工程化项目中。

虽然大多数项目都或多或少会使用到 `webpack`， 但是可能对于大多数的 前端开发人员来说，
可能只是改改 `webpack` 的配置， 或者甚至从未动过 `webpack` 的相关文件,
或多或少对 `webpack` 的配置以及功能感到陌生。

还有类似于 `vue-cli`、`create-react-app` 、 `umi.js` 等各种基于 `webpack` 封装的 脚手架，
提供了各种开箱即用的功能，这使得 `webpack` 离我们好像越来越远。

但是当我们的某个项目面临了不得不去 深入 `webpack` 才能解决的问题，或者 面试时，被问起 `webpack` 相关的问题，
就难以解决或者回答。

所以我们需要对 `webpack` 至少有基本的了解，了解它的原理、如何编写 `loader` 、 `plugin` 等。

## webpack是什么

> 引用 [webpack官网](https://webpack.js.org/concepts/) ：
>
> At its core, webpack is a static module bundler for modern JavaScript applications.
> When webpack processes your application, it internally builds a dependency graph from one or more
> entry points and then combines every module your project needs into one or more bundles,
> which are static assets to serve your content from.
>
> 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。
> 当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，
> 其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。

从作用上讲，webpack 的功能就是将不同模块的文件，打包整合到一起，并且保证它们之间引用的正确，且有序执行。
这使得我们在做项目架构时，能够从模块的角度去做文件拆分，然后交给 webpack 打包整合。

而一个项目中的文件，不仅有 html文件、CSS文件、JavaScript文件、图片资源、Vue特有的`.vue`文件，
typescript的`.ts` 文件等，以及项目的中的代码还需要进行压缩混淆、浏览器兼容、等等必要的处理，
启动一个本地的开发服务器、模块的热更新替换等， 可以通过`webpack` 提供的各种机制，来一一实现。

对于 `webpack` 来说， 它自身只能识别 JavaScript 文件， 而对于其他的资源，可以通过 webpack提供的 `Loader` 特性来实现
识别。 通过 `Loader`，可以把其它类型的资源文件，转换为 webpack能够处理的有效模块。

而对于 代码混淆、本地开发服务器、模块热更新，则可以通过 webpack 提供的 `Plugin` 特性来实现功能上的扩展。

## 模块打包原理

在 webpack 中，有四个基础且核心的概念：

* **入口（entry）**
* **输出（output）**
* **加载器（Loader）**
* **插件（Plugin）**

### 入口（entry）

指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。

### 输出(output)

告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件

### 加载器（Loader）

webpack 自身只能理解 JavaScript 文件 和 json 文件， loader 可以将其他类型的资源文件转换为 webpack能够处理的有效模块。

本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。

### 插件（Plugin）

用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。
插件接口功能极其强大，可以用来处理各种各样的任务。

### 模块（modules）

在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。

对于 webpack ，任何文件都可以是一个模块。

### 模块打包运行原理

在说 webpack 的 **模块打包运行原理** 之前， 先看下 我们是如何使用 webpack的，
一般情况下， 我们通过编写一个 配置文件`webpack.config.js`， 对 webpack 进行本地化的配置，
大致的配置如下：

```js
module.exports = {
  // 声明模块的入口文件
  entry: './src/entry.js',
  output: {
    path: path.resolve(__dirname, 'dist'), // 输出目录
    filename: 'bundle.js', // 文件名称
  },
  module: {
    rules: [
      // 配置 使用 babel-loader 对 .js 资源进行转换
      {
        test: /\.js$/,
        loader: 'babel-loader',
      },
      // ...more loader
    ],
  },
  // 插件配置
  plugins: [
    new EslintWebpackPlugin(),
    new webpack.NoEmitOnErrorsPlugin(),
    // ...more plugin
  ],
  // ...more config
}
```

`webpack` 读取了 配置文件后，运行的流程大致如下：

1. 读取 `webpack` 的配置参数；
2. 启动 `webpack` , 创建 `compiler` 对象，开始解析项目；
3. 从入口文件 `entry` 开始解析，并找到其导入的**依赖模块**，递归遍历分析，形成**依赖关系树**；
4. 对不同的文件类型资源的依赖模块文件，使用对应的 `Loader` 进行转换，最终转为 webpack的有效模块；
5. 在编译过程中， `webpack` 通过 发布订阅模式，向外抛出一些 `hooks` ，`webpack` 的 `Plugin` 通过监听各个 `hooks` ，
   执行插件任务，扩展 `webpack` 的功能，干预输出结果。
6. 根据 输出配置 `output` ，将打包构建好的资源文件 输出。

`compiler` 对象是一个全局单例，负责控制整个 webpack 构建流程。

在构建过程中，还会产生一个当前构建的上下文对象 `compilation`, 它包含了当前构建的所有信息，在每个热更新或重新构建时， `compiler` 都会产生一个新的`compilation` 对象，负责当前构建过程。

每个模块间的依赖关系，则依赖于`AST`语法树。每个模块文件在通过`Loader`解析完成之后，
会通过`acorn`库生成模块代码的`AST`语法树，通过语法树就可以分析这个模块是否还有依赖的模块，
进而继续循环执行下一个模块的编译解析。

最终， webpack 打包构建出来的 bundle 文件，是一个 IIFE 执行函数。

```js
// webpack5下进行的最小化打包输出文件
;(() => {
  // webpack 模块文件内容
  let __webpack_modules__ = {
    'entry.js': (modules) => {
      /* ... */
    },
    'other.js': (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
      /* ... */
    },
  }

  // 模块缓存
  let __webpack_module_cache__ = {}

  // The require function
  function __webpack_require__(moduleId) {
    // Check if module is in cache
    let cachedModule = __webpack_module_cache__[moduleId]
    if (cachedModule !== undefined) {
      return cachedModule.exports
    }
    // Create a new module (and put it into the cache)
    let module = (__webpack_module_cache__[moduleId] = {
      // no module.id needed
      // no module.loaded needed
      exports: {},
    })

    // Execute the module function
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__)

    // Return the exports of the module
    return module.exports
  }

  // startup
  // Load entry module and return exports
  // This entry module can't be inlined because the eval devtool is used.
  let __webpack_exports__ = __webpack_require__('entry.js')
})()
```

在上面的打包demo中，整个立即执行函数里边只有三个变量和一个函数方法，`__webpack_modules__`存放了编译后的各个文件模块的JS内容，`__webpack_module_cache__` 用来做模块缓存，`__webpack_require__` 是Webpack内部实现的一套依赖引入函数。最后一句则是代码运行的起点，从入口文件开始，启动整个项目。

`__webpack_require__`模块引入函数，我们在模块化开发的时候，通常会使用`ES Module`或者`CommonJS`规范导出/引入依赖模块，webpack打包编译的时候，会统一替换成自己的`__webpack_require__`来实现模块的引入和导出，从而实现模块缓存机制，以及抹平不同模块规范之间的一些差异性。

---

---
url: /czxBlog/article/hdx2maf6/index.md
---
# 在 Chrome 中模拟请求和Web内容
在 **Chrome 117** 中，发布了一项极为实用的新功能，这项功能允许 我们在 **本地替换Web内容**
（包括 XHR 和 提取请求数据）

## 概述

在我们的日常开发中，在进行调试时经常需要模拟各种数据场景。
通常情况下，我们可以借助一些开发工具，或者根据项目所使用的脚手架相关的工具进行模拟。

> \[!tip]
> 如果你正在使用 `vite`，推荐使用 [`vite-plugin-mock-dev-server`](https://vite-plugin-mock-dev-server.netlify.app/) 插件为你的项目开启 mock 支持。
> 能够满足绝大多数的需求场景，不仅支持 http 请求，还支持 websocket。

从 `Chrome 117` 开始，为我们提供了 `overrides content` 功能，它带来的功能包括：

* 替换 HTTP 响应头
* 替换 HTTP 响应内容
* 替换 网页资源

同时，它还将替换的内容保存 为 本地的文件夹中形成副本。当重新加载网页时，开发者工具会使用这些 本地的副本，
而不是真实的网络资源。

## 限制

本地替换适用于网络响应标头和大多数文件类型（包括 XHR 和提取请求），但有一些例外情况：

* 开发者工具不会保存对 `Elements` 面板的 DOM 树所做的更改。
* 如果你在 `Styles` 窗格中修改 CSS，且该 CSS 的来源是 HTML 文件，则开发者工具不会保存更改。

不过，你可以在 `Sources` 面板中修改 HTML 文件。

## 设置本地替换项

### 启用

1. 首先打开 `Networks` 面板，首先选择你想要 替换的请求，
   从下拉菜单中选择 `override header`(替换响应头) 或者 `override content` （替换内容）。

   ::: center
   ![open menu](/images/chrome-override/open-menu.png){style="width:275px;max-width:100%;"}
   :::

2. 如果你还未设置过 本地替换项，则开发者工具会在顶部的的操作栏中，提示你 选择一个 本地文件夹，
   用于将 替换的文件保存到 本地的文件夹中作为副本。

   ::: center
   ![select folder](/images/chrome-override/select-folder.png)
   :::

   选择文件夹后，开发者工具 会提示你 进行 文件夹授权，点击 `Allow / 允许` 即可：

   ::: center
   ![allow](/images/chrome-override/allow.png)
   :::

3. 授权完毕后，开发者工具将会跳转到 `Sources` 面板。在这里，你可以看到 新生成的 Mock 文件，
   该文件与你想要替换的 请求内容 相对应， 你可以直接在这里对其进行修改：

   ::: center
   ![mock file](/images/chrome-override/mock-file.png)
   :::

### 停用

在 `Sources > overrides` 面板中， 取消选中 `Enable local override` 即可 停用 本地替换。

::: center
![disable](/images/chrome-override/disable.png){style="width:375px;max-width:100%;"}
:::

## 替换响应内容

使用 替换响应内容 时，我们可以不必等待后端，获得后端支持，即可在本地 实时模拟我们需要的数据进行调试。

在 `Networks` 面板中，右键点击你想要修改的接口，在弹出咋菜单中，选择 `Override content` 选项：

::: center
![override res](/images/chrome-override/override-res-1.png){style="width:375px;max-width:100%;"}
:::

开发者工具将会跳转到 `Sources > Overrides` 面板中，并打开对应的 mock 文件：

::: center
![mock file](/images/chrome-override/mock-file.png)
:::

你可以直接在这里修改 响应内容，然后按 `Command /Ctrl + S` 保存文件, 然后刷新页面

## 替换响应头

### 修改单个请求响应头

在 `Networks` 面板中，选择想要修改的接口，并右键点击，然后在 右键菜单中，选择 `Override header`选项：

::: center
![override header](/images/chrome-override/override-header-1.png){style="width:375px;max-width:100%;"}
:::

此时，面板 `Header` 将会进入 可编辑状态：

::: center
![override header](/images/chrome-override/override-header-2.png)
:::

你可以点击 `Add Header` 添加新的响应头， 也可以直接点击想要修改的值即可修改响应头。

另外，如果你只需要简单的修改某个值，还可以直接鼠标悬停在 想要修改的 `Header` 值上，然后点击 `Edit` 图标 来修改响应头。

::: center
![override header](/images/chrome-override/override-header-3.png)
:::

请看一个示例，添加一个 允许跨域请求的头，删除一个响应头并修改响应头：

::: center
![override header](/images/chrome-override/override-header-4.png)
:::

### 修改所有请求响应头

如果需要在修改所有请求的响应头时，点击 `Response Headers` 面板右侧的 `.headers` 按钮：

::: center
![override header](/images/chrome-override/override-header-5.png){style="width:425px;max-width:100%;"}
:::

开发者工具将会条状到对应的 `Sources > Overrides > .headers` 文件中：

::: center
![override header](/images/chrome-override/override-header-6.png)
:::

在这里，你可以点击 `Add override rule` 按钮，添加新的响应头。

其中 `Apply to` 表示该规则匹配的 请求接口地址， 你可以使用 `*` 通配符 匹配所有的接口， 使用 `?` 指定单个字符。

修改完成后，别忘了 使用 `Commands/Ctrl + S` 保存 `.headers` 文件。

然后，你就可以刷新页面以应用所有的更改。

## 替换Web内容

你可以直接在 `Sources > Page` 查看 当前页面的 所有资源内容，然后找到你想要修改的资源内容，
右键点击，在菜单中选择 `Override content`。

:::center
![override content](/images/chrome-override/override-content.png){style="width:425px;max-width:100%;"}
:::

开发者工具将会跳转到 `Sources > Overrides` 面板，并建立 该资源内容的 Mock 副本，
你可以直接对其进行修改， `Command /Ctrl + S` 保存文件，然后刷新页面。

---

---
url: /czxBlog/article/hx3h2vvj/index.md
---
# JavaScript进阶（一）— 原型到原型链
在 `JavaScript` 的世界中，我们常常会通过 构造函数 来创建一个 **实例对象**：

```js
function Person(name) {
  this.name = name
}
const person = new Person('Mark')
console.log(person.name) // Mark
```

我们使用构造函数`Person`，通过 `new` 创建了一个实例对象 `person`。

在实例对象 `person` 上， 有一个私有属性 `__proto__` 指向了它的构造函数的原型对象`prototype`，

那么，什么是 `prototype`, 什么是 `__proto__` ?

接下来，我们开始进入正题。

## prototype

在 `JavaScript` 中，每个函数都有一个 `prototype` 属性，这个属性指向了该函数的原型对象。

```js
function Person(name) {
  this.name = name
}
Person.prototype.age = 18

const person1 = new Person('Mark')
const person2 = new Person('John')
console.log(person1.name, person1.age) // Mark 18
console.log(person2.name, person2.age) // John 18
```

可以看到，当 `person1` 和 `person2` 均打印 `age` 属性值为 `18`。

这是因为 `Person.prototype` 正是 实例对象 `person1` 和 `person2` 的原型。

既然 `prototype` 指向的是原型， 那么，**原型** 又是什么？

简单的理解，在 `JavaScript` 中，每一个对象在创建时，都有一个与之关联的另一个对象，这个关联的对象就是指原型。

::: warning 注意
`null` 是没有原型的。
:::

对象会从其原型对象，**继承** 属性。这也是为什么 `person1` 和 `person2` 均打印 `age` 属性值为 `18`。

## \_\_proto\_\_

在 `JavaScript` 中，每个对象（`null` 除外）都有一个 私有属性 `__proto__`，
这个属性指向了该对象的构造函数的原型`prototype`。

```js
function Person(name) {
  this.name = name
}
const person = new Person('Mark')
console.log(person.__proto__ === Person.prototype) // true
```

到这里就会发现，既然构造函数有原型 `prototype`，原型也是一个对象，而对象有 `__proto__` 指向它的构造函数的原型对象，
那么 构造函数的原型对象，是否也有其原型对象呢？

## constructor

在说明 原型的原型前，需要了解原型上的一个属性 `constructor`, 它指向了原型对象关联的构造函数：

```js
function Person(name) {
  this.name = name
}
const person = new Person('Mark')
console.log(person.prototype.constructor === Person) // true
```

它有助于帮我们理解 找到原型的原型的构造函数。

## 原型的原型

当我们在控制台打印并输出 `Person.prototype.__proto__` 时，发现打印了一个对象：

```js
function Person(name) {
  this.name = name
}
console.log(Person.prototype.__proto__)
```

`output`:

![Person.prototype.proto](/images/js-prototype-1.png)

既然 `Person` 的原型也有原型， 那么 这个原型的原型对象，它的构造函数又是什么呢？

我们可以使用 `constructor` 来获取 它的构造函数：

```js
function Person(name) {
  this.name = name
}
console.log(Person.prototype.__proto__.constructor)
```

`output`:
![Person.prototype.proto.constructor](/images/js-prototype-2.png)

可以发现 `Person` 的原型对象的原型对象，指向的构造函数是 `Object`。

即 `Person.prototype` 的原型，指向的是 `Object.prototype`。

那么， `Object.prototype` 有没有自己的原型呢？

![Object.prototype.proto](/images/js-prototype-3.png)

可以发现，`Object.prototype` 的原型，指向的是 `null`。

而`null` 是表示 **没有对象**，它没有原型。

## 原型链

`Person.prototype` -> `Object.prototype` -> `null`

(通过 `__proto__` 进行关联)

这种 对象有一个原型对象，它的原型对象又有它的原型对象，一层层如同链式一样，向上关联，称为 `原型链`。

几乎所有 `JavaScript` 中的对象都是位于原型链顶端的 `Object` 的实例。

::: tip
`__proto__` 是一个非标准的属性，但绝大部分浏览器都支持通过这个属性来访问原型。

`__proto__` 在实现上是`Object` 上的一个 `getter/setter`访问器 ，使用 `obj.__proto__` 时，可以理解成返回了 `Object.getPrototypeOf(obj)`。
:::

## 基于原型链的继承

`JavaScript` 对象是动态的属性“包”（指其自己的属性）。`JavaScript` 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

```js
function Person(name) {
  this.name = name
}
Person.prototype.age = 18

const person1 = new Person('Mark')
const person2 = new Person('John')
console.log(person1.name, person1.age) // Mark 18
console.log(person2.name, person2.age) // John 18
```

在这个示例中， 虽然`Person` 的实例对象自身并没有`age` 属性，但由于它的原型对象上有 `age` 属性，
实例对象从它的原型对象 **继承** 了属性 `age` 。 从而其 `age` 属性的值为 `18`。

---

---
url: /czxBlog/article/i0fxxwpn/index.md
---
# Web指标
## 概览

Web 指标是 Google 开创的一项新计划，旨在为网络质量信号提供统一指导，这些信号对于提供出色的网络用户体验至关重要。

多年来，Google 提供了许多性能测量和性能报告工具。一些开发者对这些工具的使用十分在行，而另一些开发者则发现大量的工具和指标令人应接不暇。

网站所有者要想了解他们提供给用户的体验质量，并非需要成为性能专家。 Web 指标计划旨在简化场景，帮助网站专注于最重要的指标，即 **核心 Web 指标** 。

## 核心 Web 指标

核心 Web 指标是适用于所有网页的 Web 指标子集，每位网站所有者都应该测量这些指标，
并且这些指标还将显示在所有 Google 工具中。每项核心 Web 指标代表用户体验的一个不同方面，
能够进行 [实际](https://web.dev/user-centric-performance-metrics/#how-metrics-are-measured) 测量，
并且反映出 [以用户为中心](https://web.dev/user-centric-performance-metrics/#how-metrics-are-measured) 的关键结果的真实体验。

核心 Web 指标的构成指标会随着时间的推移而[发展](https://web.dev/vitals/#evolving-web-vitals) 。当前针对 2020 年的指标构成侧重于用户体验的三个方面——加载性能、交互性和视觉稳定性——并包括以下指标（及各指标相应的阈值）：

* [Largest Contentful Paint (LCP)](https://web.dev/lcp/) ：最大内容绘制，测量加载性能。为了提供良好的用户体验，LCP 应在页面首次开始加载后的2.5 秒内发生。
* [First Input Delay (FID)](https://web.dev/fid/) ：首次输入延迟，测量交互性。为了提供良好的用户体验，页面的 FID 应为100 毫秒或更短。
* [Cumulative Layout Shift (CLS)](https://web.dev/cls/) ：累积布局偏移，测量视觉稳定性。为了提供良好的用户体验，页面的 CLS 应保持在 0.1. 或更少。

为了确保您能够在大部分用户的访问期间达成建议目标值，对于上述每项指标，一个良好的测量阈值为页面加载的第 75 个百分位数，且该阈值同时适用于移动和桌面设备。

如果一个页面满足上述全部三项指标建议目标值的第 75 个百分位数，那么评估核心 Web 指标合规性的工具应评判该页面为通过。

::: info
要想详细了解这些建议值背后的研究和方法论，请参阅：[定义核心 Web 指标的指标阈值](https://web.dev/defining-core-web-vitals-thresholds/)
:::

## 测量和报告核心 Web 指标的工具

Google 认为核心 Web 指标对一切网络体验都至关重要。因此，Google 致力于 [在其所有热门工具中](https://web.dev/vitals-tools/) 显示这些指标。以下部分详细介绍了支持核心 Web 指标的工具。

### 核心 Web 指标的实测工具

[Chrome 用户体验报告](https://developer.chrome.com/docs/crux/) 为每项核心 Web 指标收集匿名的真实用户测量数据。
这些数据既能使网站所有者快速进行性能评估，而无需在页面上进行手动检测分析，
也能同时为 [PageSpeed Insights 网页速度测量工具](https://pagespeed.web.dev/) 和
搜索控制台的 [核心 Web 指标报告](https://support.google.com/webmasters/answer/9205520) 等工具提供支持。

|                                                                           | LCP | FID | CLS |
| ------------------------------------------------------------------------- | --- | --- | --- |
| [Chrome 用户体验报告](https://developer.chrome.com/docs/crux/)            | ✔  | ✔  | ✔  |
| [PageSpeed Insights 网页速度测量工具](https://pagespeed.web.dev/)         | ✔  | ✔  | ✔  |
| [核心 Web 指标报告](https://support.google.com/webmasters/answer/9205520) | ✔  | ✔  | ✔  |

::: info
关于这些工具的使用方法以及适合您用例的工具选择指南，请参阅：[测量 Web 指标入门指南](https://web.dev/vitals-measurement-getting-started/)
:::

Chrome 用户体验报告提供的数据带来了一种快速评估网站性能的方法，但这些数据没有提供详细的、对应每页浏览量的遥测数据，而这些通常是对回归进行准确诊断、监控，以及做出迅速反应的必要数据。因此，我们强烈建议网站搭建自己的真实用户监控。

### 在 JavaScript 中测量核心 Web 指标

每项核心 Web 指标都可以通过使用标准网页 API 在 JavaScript 中进行测量。

测量所有核心 Web 指标，最简单的方法是使用[web-vitals](https://github.com/GoogleChrome/web-vitals)
JavaScript 库，这是一个围绕底层网页 API 的小型的、生产就绪的封装器，
通过准确匹配每项指标在上方列出的所有 Google 工具中的报告方式来进行指标测量。

通过使用 [web-vitals](https://github.com/GoogleChrome/web-vitals) 库，测量每项指标就像调用单个函数一样简单（有关完整[用法](https://github.com/GoogleChrome/web-vitals#usage)和[API](https://github.com/GoogleChrome/web-vitals#api)详情，请参阅文档）：

```js
import { onCLS, onFID, onLCP } from 'web-vitals'

function sendToAnalytics(metric) {
  const body = JSON.stringify(metric)
  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
  ;(navigator.sendBeacon && navigator.sendBeacon('/analytics', body))
  || fetch('/analytics', { body, method: 'POST', keepalive: true })
}

onCLS(sendToAnalytics)
onFID(sendToAnalytics)
onLCP(sendToAnalytics)
```

当您将网站配置为使用 [web-vitals](https://github.com/GoogleChrome/web-vitals) 库来测量您的核心 Web 指标数据并将其发送到分析端后，下一步是对数据进行汇总和报告，从而查看您的页面是否在至少 75% 的页面访问中都满足建议阈值。

一些分析工具供应商已经内置了核心 Web 指标支持，但即使是那些没有内置支持的供应商也应该包含基本的自定义指标功能，让您能够使用他们的工具来测量核心 Web 指标。

[Web 指标报告](https://github.com/GoogleChromeLabs/web-vitals-report) 就是其中一个例子，
它使网站所有者能够使用 Google 分析来测量他们的核心 Web 指标。
了解使用其他分析工具测量核心 Web 指标的相关指南，请参阅 [实测 Web 指标的最佳实践](https://web.dev/vitals-field-measurement-best-practices/)。

您还可以使用 [Web 指标 Chrome 扩展程序](https://github.com/GoogleChrome/web-vitals-extension)
来报告每项核心 Web 指标，且无需编写任何代码。
该扩展程序使用 [web-vitals](https://github.com/GoogleChrome/web-vitals) 库来测量每一项指标，并在用户浏览网页时呈现给用户。

此扩展程序有助于您了解自己的网站、竞争对手的网站和整个网络的性能。

|                                                                                  | LCP | FID | CLS |
| -------------------------------------------------------------------------------- | --- | --- | --- |
| [Web 指标报告](https://github.com/GoogleChromeLabs/web-vitals-report)            | ✔  | ✔  | ✔  |
| [Web 指标 Chrome 扩展程序](https://github.com/GoogleChrome/web-vitals-extension) | ✔  | ✔  | ✔  |

此外，倾向于直接通过底层网页 API 来测量这些指标的开发者可以参考这些指标指南，从而了解执行详情：

* [在 JavaScript 中测量 LCP](https://web.dev/lcp/#measure-lcp-in-javascript)
* [在 JavaScript 中测量 FID](https://web.dev/fid/#measure-fid-in-javascript)
* [在 JavaScript 中测量 CLS](https://web.dev/fid/#measure-fid-in-javascript)

::: info
关于如何使用热门分析服务（或您自己的内部分析工具）来测量这些指标的更多指导，请参阅：[实测 Web 指标的最佳实践](https://web.dev/vitals-field-measurement-best-practices/)
:::

### 核心 Web 指标的实验室测量工具

虽然所有的核心 Web 指标首先都是实测指标，但其中的许多指标也可以在实验室中进行测量。

实验室测量是在开发过程中（功能发布给用户之前）测试功能性能的最佳方式，也是在性能回归发生之前及时捕获的最佳方式。

以下工具可用于在实验室环境中测量核心 Web 指标：

|                                                                  | LCP | FID                                        | CLS |
| ---------------------------------------------------------------- | --- | ------------------------------------------ | --- |
| [Chrome 开发者工具](https://developer.chrome.com/docs/devtools/) | ✔  | ✘（使用 [TBT](https://web.dev/tbt/) 代替） | ✔  |
| [灯塔](https://developer.chrome.com/docs/lighthouse/overview/)   | ✔  | ✘（使用 [TBT](https://web.dev/tbt/) 代替） | ✔  |

::: info
灯塔这类在没有用户的模拟环境中加载页面的工具无法测量 FID（没有用户输入）。但是，Total Blocking Time 总阻塞时间 (TBT) 指标不仅可以进行实验室测量，而且还是 FID 的出色代理。在实验室中改进 TBT 的性能优化应该能够改进实际的 FID（请参阅下方的性能建议）。
:::

虽然实验室测量对于提供出色的体验至关重要，但它不能替代实际测量。

根据用户设备功能、网络状况、设备上可能正在运行的其他进程以及与页面交互方式的差别，网站性能也可能会有很大差异。事实上，每项核心 Web 指标的得分都会受到用户交互的影响。只有通过实际测量才能准确获取全貌。

### 提高分数的建议

当您测量了核心 Web 指标并确定了需要改进的领域后，下一步就是优化。以下指南提供了如何针对每项核心 Web 指标优化页面的具体建议：

* [优化 LCP](https://web.dev/optimize-lcp/)
* [优化 FID](https://web.dev/optimize-fid/)
* [优化 CLS](https://web.dev/optimize-cls/)

## 其他 Web 指标

虽然核心 Web 指标是理解并提供出色用户体验的关键指标，但还有其他的一些重要指标。

其他 Web 指标通常用作核心 Web 指标的代理或补充指标，有助于获取范围更广的体验或帮助诊断特定的问题。

例如，[Time to First Byte 首字节时间 (TTFB)](https://web.dev/ttfb/)
和 [First Contentful Paint 首次内容绘制 (FCP)](https://web.dev/fcp/)指标都是加载体验的重要方面，
并且在诊断 LCP 问题方面（分别为[服务器响应时间](https://web.dev/overloaded-server/)
过长或[阻塞渲染资源](https://developer.chrome.com/docs/lighthouse/performance/render-blocking-resources/)）都十分有用。

同样，[总阻塞时间 (TBT)](https://web.dev/tbt/) 和
[Time to Interactive 可交互时间 (TTI)](https://web.dev/tti/)等指标是实验室指标，
对于捕获和诊断会对 FID 产生影响的潜在交互性问题至关重要。
然而，这些指标不是核心 Web 指标的一部分，因为它们无法进行实际测量，
也不反映以[用户为中心](https://web.dev/user-centric-performance-metrics/#how-metrics-are-measured)的结果。

## 不断发展的 Web 指标

Web 指标和核心 Web 指标代表了当今开发者用来测量网络体验质量的最佳可用信号，但这些信号并不完美，并且会在未来不断进行改进或补充。

**核心 Web 指标**与所有网页都息息相关，并且已经显示在相关的 Google 工具中。这些指标的变化将产生广泛的影响，因此，开发者应当认为核心 Web 指标的定义和阈值是稳定的，并且会以可预测的、每年一次的更新节奏提前发布更新通知。

其他 Web 指标通常适用于特定情景或工具，并且可能比核心 Web 指标更具实验性。因此，这些指标的定义和阈值可能会有更频繁的更改。

针对所有 Web 指标的更改都将清楚地记录在这份公开的[更新日志](http://bit.ly/chrome-speed-metrics-changelog)中。

---

---
url: /czxBlog/article/i1wc1uld/index.md
---
::: center
![lerna](https://user-images.githubusercontent.com/645641/79596653-38f81200-80e1-11ea-98cd-1c6a3bb5de51.png){ style="width: 50%" }
:::

## 概述

`lerna` 是一个多包管理工具，针对使用 git 和 npm/yarn 等管理多软件包的代码仓库的工作流程进行优化。

在开发一个大型项目时，往往会将整个项目拆分为多个代码仓库，进行独立版本化的软件包管理，这对于代码共享非常有用。

比如开源项目 `babel`，整个项目被拆分为了`@babel/core`, `@babel/parser`, `@babel/traverse`等多个软件包。

但是这也会导致如果某些更改跨越了多个代码仓库的话，会变得麻烦且难以跟踪。
`lerna`可以帮助优化对多个代码仓库的依赖、版本管理、工作流等。

## 安装

lerna 可以全局安装，也可以在项目中安装（以下内容使用项目中安装的方式）

```sh
# npm
npm install lerna
# yarn
yarn add lerna
```

## 简单入门

创建一个项目，并使用lerna进行项目环境初始化

```sh
mkdir lerna-demo && cd $_
yarn init -y
yarn add lerna
npx lerna init
```

你将会得到一个包含以下内容的项目文件夹：

```sh
lerna-demo
  packages/
  lerna.json
  package.json
```

其中，`packages/` 目录用于存放所有的软件包。`lerna.json`是lerna的配置文件。

## 配置说明

```json
// lerna.json
{
  "useWorkspaces": true,
  "npmClient": "npm", // npm | yarn
  "packages": ["packages/*"],
  "version": "0.0.0",
  "command": {
    "bootstrap": {
      // more...
    }
    // more
  }
}
```

* `npmClient`：设置当前使用的包管理器， 默认是npm， 可以设置为yarn；
* `version`：软件包版本号，根据 semver版本号规范命名；
* `packages`：软件包所在的目录，可以使用golb做模式匹配；
* `useWorkspaces`：使用工作空间，这个选项可以更好的跟yarn配合使用；
* `command`：对lerna的各个command进行配置。

## 命令行说明

### lerna init

初始化一个lerna项目，默认将会在目录中新建 packages/ 和 lerna.json。

`--independent`: 使用分包独立版本管理模式，各个软件包使用独立的版本号。

### lerna create pkgName \[location]

在项目中新建一个子包， pkgName设置包名。 location制定包所在目录，默认是 packages配置的第一个元素。

### lerna add \<package>\[@version] \[--dev] \[--exact] \[--peer]

类似于 `yarn add` 或`npm install`，在一个lerna repo中往dependency中添加依赖包。

* `--dev`: 表示将包添加到 devDependencies
* `--exact`: 添加一个确定版本的包（如1.0.1），而不是一个版本范围的包如（^1.0.1）
* `--peer`: 添加一个前置依赖包。

### lerna bootstrap

为当前 lerna repo 中的所有包安装 依赖库，并 link所有 同域依赖。

### lerna run \<script>

在当前 lerna repo 中的所有包中执行 script 命令。

```sh
packages/
  package1/
  package2/
```

```sh
lerna run build # 相当于在 package1、package2 中执行 npm run build
```

* \--scope 过滤符合条件的包

  ```sh
  lerna run build --scope test component
  ```

* \--stream 使用报名作为前缀，交叉输出所有包的控制台信息流。

  ```sh
  lerna run build --stream
  ```

* \--parallel 类似于 stream。

  ```sh
  lerna run build --parallel
  ```

### lerna clean

删除所有包的node\_modules

---

---
url: /czxBlog/article/iezlvhvg/index.md
---
# Vue组件间通信
在我们在进行基于[Vue](https://cn.vuejs.org/)的项目开发时，组件间的数据通信，是我们必须考虑的。

> **注：**
>
> 本文所实现的方式，是在不考虑`vuex`下所做的实现，
> 且仅限于 `vue@2` ，在 `vue@3` 中，有其他的更好的实现方案。

我把组件间的关系，大致分为三种：

1. 父子组件

   ```html
   <parent>
     <child></child>
   </parent>
   ```

   拥有类似结构，`parent`组件包含`child`组件，则`child`组件是`parent`的子组件，`parent`组件是`child`组件的父组件。

2. 兄弟组件

   ```html
   <item></item> <item></item>
   ```

   两个`item`组件在结构上同级，我们称之互为兄弟组件。

3. 跨多级组件

   ```html
   <list>
       <item>
           <message><message>
       </item>
   </list>
   <dialog>
       <content></content>
   </dialog>
   ```

   在这个结构中，`<list>`和`<message>`并不是直接的父子组件，中间还跨了一个级，在实际场景中，还会有跨更多层级的组件关系。`<message>` 和 `<content>` 组件两个既不是兄弟组件，又不是父子组件，而是跨了兄弟，父子的多级关系，实际场景中也会有发生交互。

那么这三种关系的组件，我们应该如何进行组件通信？

### 父子组件通信

要讲父子组件的通信，首先，我们需要了解 `vue` 组件的 特性。

1. 单向数据流，数据自上而下。

   > Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为
   > 了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。

2. 事件自下而上。

   组件内部状态的变化，通过事件往上冒泡，通知上一级组件，由上一级组件监听事件，并触发相应回调。

基于以上，父子组件通信推荐的方式是：

父组件通过`props`将状态传到子组件，子组件通过事件将状态冒泡到父组件，由父组件监听触发回调改变状态。

`parent.vue`

```html
<template>
  <div class="parent">
    <child :name="name" @name-change="nameChange"> </child>
  </div>
</template>
<script>
  import Child from './child';
  export default {
      name: 'parent',
      data () {
          return {
              name: 'Jack'
          };
      }
      methods: {
          nameChange(name) {
              this.name = name;
          }
      },
      components: {
          Child
      }
  }
</script>
```

`child.vue`

```html
<template>
  <div class="child">
    <span>{{name}}</span>
    <button @click="onClick">change name</button>
  </div>
</template>
<script>
  export default {
    name: 'child',
    props: {
      name: {
        type: String,
        defualt() {
          return ''
        },
      },
    },
    methods: {
      onClick() {
        this.$emit('name-change', 'John')
      },
    },
  }
</script>
```

在某些例子或个人项目中，经常有发现到在子组件中使用 `this.$parent` 直接改变父组件的状态，诚然这种方式能够简化两个深耦合的组件的数据通信，在一些简单的场景中也会比较方便，但其实并不推荐采用这种方式实现父子组件通信，这样做的后果就是导致了数据流的不明确性，牺牲了单项数据流的简洁性，数据的变化流动变得不易于理解。

### 兄弟组件通信、跨多级组件通信

这两种组件关系，并没有直接的联系。

如兄弟组件，我们会很自然的想到使用他们的父级组件作为中转，将 `子组件1` 的状态通信到父组件，再由父组件通过 `props` 流向 `子组件2` ，反之亦然，但是如果兄弟组件间的交互复杂，但又与父组件没有存在直接的交互关联，父组件在这个过程当中，承担了多余的职责。

又如跨多级组件，上述例子中，`<list>`和`<message>`之间间隔了多层，如果我们继续使用父子组件通信`prop`和事件冒泡，中间的层需要重复的定义`prop`和事件，这显然也导致了它们承担了多余的职责。 `<message>` 和 `<content>` 组件之间，更是在结构上没有关联，`prop`和事件冒泡显得十分乏力，无法直接完成通信。

那么这两种组件关系，该如何完成通信，又不对它们中间层级组件，或者父级组件造成多余的干扰？

由于两种组件关系没有直接的关联，所以我们需要有一个桥梁，能够直接连接它们，使它们变得有关联。即，我们需要一个`中间件`。

官方给我们的解决方案是`vuex`，但我认为它更多是的作为全局状态的管理，使用它作为某两个组件的通信中间件，显得大材小用，所以我这里不做讨论。

我所采取的方案是使用 自定义事件 完成组件通信。

**实例化Vue：**

`vue`已实现了一套事件系统，可以很方便的使用它来完成我们的组件通信。

```javascript
const middleware = new Vue()
export default middleware
```

`message.vue`

```javascript
export default {
  name: 'message',
  data() {
    return {
      info: 'hello',
    }
  },
  methods: {
    sayHello() {
      middleware.$emit('say-hello', this.info)
    },
  },
}
```

`content.vue`

```javascript
export default {
  name: 'content',
  data() {
    return {
      info: ''
    }
  },
  created() {
    middleware.$on('say-hello', (info) => {
      this.info = info
    })
  }
}
```

我们通过 `middleware`， 在`content.vue`注册了`say-hello`事件，当`message.vue`触发该事件时，`content.vue`监听到事件触发回调，从而实现了状态传导。

组件数据传导不再是通过`props`传导，而是通过事件进行通信。

**如果不使用实例化Vue的方式去完成，我们也可以自己实现一套自定义事件。** 这可以做更加个性化的自定义事件，满足项目中的多样的使用场景。

```javascript
class Event {
  constructor(options) {
    // some props
    this.options = options
  }

  on() {
    // do something
  }

  emit() {
    // do something
  }

  off() {
    // do somethig
  }
}
```

### 总结

复杂结构的组件通信，实现它们的通信，关键是实现中间件作为桥梁连接它们，无论是使用自定义事件，还是其他的方案。

---

---
url: /czxBlog/article/javascript-modules/index.md
---
# javascript模块化 发展历程
javascript模块化的发展，距今已有10个年头左右。

## 无模块化

在早期，javascript作为一门脚本语言，仅为协助表单校验等界面辅助增强，那时候的前端也比较简单， javascript不需要模块化。

## 命名空间

后来随着 javascript 需要承担更多的功能，代码量开始上升，为了避免全局命名冲突等问题，提出了使用命名空间的方案，将符合某种规则或者约定的代码，放到同一个命名空间下。 这算是 javascript模块化最早期的雏形。

```js
YAHOO.util.Event.stopPropagation(e)
```

## 基本的模块化

在这个时期，出现了比较清晰的模块定义，通过闭包来做模块运行空间

```js
// 定义模块
YUI.add('hello', (Y) => {
  Y.sayHello = function () {
    Y.DOM.set(el, 'innerHTML', 'hello!')
  }
}, '1.0.0', { requires: ['dom'] })

// ...
// 使用模块
YUI().use('hello', (Y) => {
  Y.sayHello('entry') // <div id="entry">hello!</div>
})
```

## CommonJs

CommonJs 其实是一个项目，其目标是为 JavaScript 在网页浏览器之外创建模块约定， 在当年 javascript 的模块化思想还在官方的讨论中， 缺乏普遍可接受形式的javascript脚本模块单元。

CommonJs规范和当时出现的NodeJs相得益彰，共同走入了开发者的实现。

但 CommonJs 其实是面向网页浏览器之外的（如NodeJs，即面向服务端的模块化规范），并不适用于浏览器端。

### CommonJs 规范简介

在CommonJs 规范中， 每个文件都是一个模块，有自己的作用域，在文件中定义的变量、函数、类等，都是私有的，对其他文件不可见。

在每个模块中，有两个内部变量可以使用， `require` 和 `module`

* `require` 用于加载某个模块。
* `module` 表示当前模块，是一个对象。这个对象中保存了当前模块的信息。`exports` 是 `module` 上的一个属性，保存了当前模块要导出的接口或者变量，使用 `require` 加载的某个模块获取到的值就是那个模块使用 `exports` 导出的值。

::: code-tabs

@tab a.js

```js
let name = 'Mark'
let age = 18

module.exports.name = name
module.exports.getAge = function () {
  return age
}
```

@tab:active b.js

```js
let moduleA = require('./a.js')
console.log(moduleA.a) // Mark
// 使用了未导出的变量，获取不到值
console.log(moduleA.age) // undefined
console.log(moduleA.getAge()) // 18
```

:::

在NodeJs环境中，CommonJs的模块由于在服务器环境下，可以从本地进行加载，即 同步加载。

## AMD、CMD

::: note 注释
在我的印象中， CommonJs规范 和 AMD规范 出现的时间点 相差不远。

*AMD 早于 CommonJs。*

按我个人理解，CMD 在当年算是从 AMD 衍生出来的一个方案。
:::
::: warning 注意
CommonJs 和 CMD 是两种方案！不是一样的！
:::

### AMD规范

AMD规范，即 异步模块定义([Asynchronous Module Definition](https://github.com/amdjs/amdjs-api/wiki/AMD))。

AMD 采用 **异步加载模块** 的方式。

AMD规范仅定义了一个 `define` 函数，它是一个全局变量：

```
define(id?, dependencies?, factory);
```

* `id` 描述的是当前模块的标识符;
* `dependencies` 则是当前模块的依赖数组， 它们会在 factory工厂方法被调用前被加载并执行，
  并且执行的结果必须以依赖数组定义的顺序，依此顺序作为参数传入 factory工厂方法。
* `factory`为模块初始化要执行的函数或者对象。如果函数返回一个值，则该值应该设置为该模块的输出值。

### CMD规范

CMD规范，即 公共模块定义([Common Module Definition](https://github.com/cmdjs/specification/blob/master/draft/module.md))

CMD规范 定义了 一个 `define` 函数，它是一个全局变量：

```
define(id?, dependencies?, factory);
```

* `id` 描述的是当前模块的标识符;
* `dependencies` 是当前模块的依赖数组， 他们会在 factory 工厂方法被调用前完成加载，但并不立即执行。
* `factory`为模块初始化要执行的函数或者对象。

  * 如果是一个函数，则函数接受三个参数：

    ```js
    define((require, exports, module) => {

    })
    ```

    `require` 用于同步加载并执行已经定义好的其他模块；获取模块的输出值，
    `exports`是`module.exports`的别名，用于导出当前模块的输出值；`module`存储了当前模块的信息。

  * 如果是一个对象，则直接作为当前模块的输出值。

::: tip 两者的差异

AMD规范 和 CMD规范 从规范定义上来看，主要的差异为：

* AMD 的模块在加载后是立即执行的，并且会按照依赖顺序依次传入 factory，
  而 CMD的模块在加载后并不立即执行，而是在 factory方法中，通过 `require` 方法调用执行模块获取结果；

:::

### 规范的实现

* AMD流行的实现库是 [require.js](https://github.com/requirejs/requirejs);
* CMD流行的实现库是 [sea.js](https://github.com/seajs/seajs);

::: warning 提示
由于在当下已经越来越少会去选择使用 `require.js` 以及 `sea.js`， 这里就不多对这两个库做介绍说明。
:::

## NodeJs前端工具链

得益于 NodeJs 的能力，开源社区在模块化方面又再次向前继续迈进。 特别是在推出了 `NPM` 包管理工具后，前端的工具、模块化出现了井喷式发展。

### grunt gulp

既然 CommonJs 不适用于 浏览器端的一个主要原因是同步加载和异步加载之间的问题，那么借助于 `grunt` 或 `gulp` 提供的前端工具，在开发时，还是以文件一模块，然后构建时，将模块文件打包在一起，那么由于都是在同一个文件中，则模块之间的加载则可以是同步的。

在这个时期，`grunt`、`gulp` 并没有提供直接的模块化打包能力，但是在其基础上，通过插件实现了文件合并，从而能够在开发时，以 某种模块规范进行项目架构和管理，再进行打包构建。

### webpack NPM

真正让 前端模块化得到质的飞跃的，是 NPM的推出，内置到了 NodeJS 中。

而 webpack 的出现，这块 真正意义上的 模块打包工具，配合 NPM， 让模块化越来越得以更方便的运用于应用开发中。

webpack 作为一个 模块打包器， 在内部根据 CommonJs规范实现了 模块加载器，使得应用于浏览器端的javascript代码，也能够像 Node端的 javascript代码，拥有类似甚至相同的文件组织结构。

实现了一文件一模块，模块之间通过 `require` 函数进行 访问。

而 NPM的推出与流行，在前端引入了 `package` 包的概念，模块以包的形式进行管理， 让越来越多的开发者，能够共享各自开发的模块，开发者可以通过 NPM 安装其他开发者已开发好的模块，然后通过 `webpack` 实现开发时加载这些模块。

webpack 内部实现了 不同的 模块化规范，包括 匿名函数闭包`iife`, `AMD`, `CMD`,`CommonJs`等。

`webpack` 不仅将 javascript 作为模块，而是将一切资源都作为模块进行处理。

### 其他的模块打包工具

* [rollup](https://github.com/rollup/rollup) 轻量且快速的模块打包工具
* [parcel](https://github.com/parcel-bundler/parcel) 零配置的开箱即用的模块打包工具
* [vite](https://github.com/vitejs/vite) 基于rollup的前端工具
* more...

### 其他包管理工具

* [yarn](https://classic.yarnpkg.com/lang/en/)
* [pnpm](https://pnpm.io/)
* more...

::: info 说明
与`npm` 对比，都是社区对于 包管理 的不同理念、不同实践 下所产生的工具。
三者互相发展，并都有各自的特色。
:::

## ES Modules

[ES Modules](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)

随着 javascript的发展，ECMAScript将模块加载添加到了标准之中，浏览器也开始支持 模块加载。

使用 Javascript 模块依赖于 `import` 和 `export` 进行导入和导出。

在 `html` 导入 javascript模块脚本是，需要在 `<script>` 标签中添加 `type="module"` 的属性声明

```html
<script type="module" src="/moduleA.js"></script>
```

::: code-tabs

@tab moduleA.js

```js
import { getAge, name } from './moduleB.js'

console.log(name)
console.log(getAge())
```

@tab moduleB.js

```js
export const name = 'Mark'

const age = 18

export function getAge() {
  return age
}
```

:::

## Deno模块加载

Deno与 Node在模块加载上最大的差别， 就是 放弃了 项目中的`node_modules` 作为第三方包的存放目录，也抛弃了 类似于 NPM 的中心化管理的 模块管理工具。

Deno 推荐使用的是 去中心化的模块加载管理，支持直接从远程的任意站点加载提供的模块。

如从 官方的 [deno.lang](https://deno.land/)，或者从 [unpkg.com](https://unpkg.com/) 加载第三方模块。

::: info 说明
这种去中心化模块管理的模块加载方案，相对来说会比较依赖于网络环境，虽然远程的模块首次加载后也会被缓存，但进行生产部署时，往往生产服务器跟公网是隔离的，在这种情况下，就需要自建一个内部服务器作为代理，托管第三方的模块包。
:::

---

---
url: /czxBlog/article/kflidi22/index.md
---
# Vue 响应式系统
响应式编程从提出至今，大约有几十年的历史了，它时而兴起，时而沉寂。而在前端，它在这几年来，有开始迸发出了新的活力。
特别是在当下流行的如 `vue` 、 `react`、`svelte` 和 `solid` 之类的前端框架中，响应式编程的发展迅速。

然而，它并不是那么容易理解。

* 在不同的响应式编程实现方式中，某些术语或者概念可能会有所不同，对于不同的人来说，也有不同的理解。
* 其次，它看起来像是一个魔法，虽然事实并非如此，人们在理解响应式编程是什么之前，常常会被 **“怎么做到的”** 分散注意力，从而导致理解难度的增加。这使得很难通过一些实际的例子，完全理解响应式编程。

本文不完全解释响应式编程，但是希望能够帮助你理解响应式编程。并帮助理解 `vue` 的响应式系统。

## 响应性

响应式编程，一个重要的特点是 **响应性**。

那么如何理解响应性？一种很口语化的表达是，两个物体之间存在某种关联，当其中一个发生变化时，另一个也会随之发生变化。

一个常见的例子，如我们常用的 Excel 表格：

|     | A   | B   | C   |
| --- | --- | --- | --- |
| 0   | 2   |     |     |
| 1   | 3   |     |     |
| 2   | 5   |     |     |

`A2` 单元格的值 是根据 `A0` 和 `A1` 两个单元格的值，进行求和后的结果，
通常我们会在 `A2` 的单元格上写 `=SUM(A0:A1)` 的公式。
当 `A0` 和 `A1` 两个单元格的值发生变化时，`A2` 单元格的值也会随之发生变化。

这种`A2` 与 `A0``A1`的关系，我们可以称之为 **响应性**。公式 `=SUM(A0:A1)` 则声明并建立了这种关系。

所以，**响应性** 是一种可以使我们声明式地处理变化的编程范式。

## JavaScript 中实现响应性

我们把 这个 Excel 表格 编写为 `javascript` 的逻辑：

```ts
let A0 = 2
let A1 = 3
let A2 = A0 + A1

console.log(A2) // 5

A0 = 5
console.log(A2) // 仍然是 5
```

即使`A0`的值发生了变化，但`A2`的值仍然是 5。可见在 `javascript` 中，默认并不具有 响应性 的。
那么，要如何在 javascript 中建立响应性呢？

通常在 `javascript` 的代码中，我们使用一个函数来包装计算`A2`的逻辑，
并在其他值发生改变时，调用这个函数来更新`A2`的值。

```ts
let A0 = 2
let A1 = 3
let A2

function update() {
  A2 = A0 + A1
}
console.log(A2) // 5

A0 = 5
update()
console.log(A2) // 8
```

但是，每次修改 `A0` 或 `A1` 时，都需要主动调用 `update()` 来更新`A2`的值，这显然没有 `响应性`。
需要找到一种，修改 `A0` 或 `A1` 时，自动调用 `update()` 来更新`A2`的值的方法。

通常，我们很容易就会联想到通过 `订阅者模式`，来实现这种功能。
`A2` 订阅 `A0`和`A1` 两个变量，当它们发生变化时，自动调用 `update()` 来更新`A2`的值。

```ts
// 仅表示伪代码，方便理解
A2.subscribe(A0, A1, update)
```

然而，在 `javascript` 中，要实现对 变量的变更的监听，并不那么容易。
`javascript` 并没有提供一种方式，帮助我们实现对基本数据类型的变更监听。

### 轮询检查

我们还是可以通过 **轮询检查** 来实现对变量的变更的监听。每隔一段时间，扫描`A0`和`A1`两个变量的值，如果发生了变化，就调用 `update()` 来更新`A2`的值。

```ts
let A0 = 2
let A1 = 3
let A2
let OA0 = A0
let OA1 = A1

setInterval(() => {
  if (OA0 !== A0 || OA1 !== A1) {
    A2 = A0 + A1
    console.log('A2:', A2)
  }
}, 10)

A0 = 5
// A2: 8
```

**缺陷**：

```mermaid
graph TD
    A[轮询机制] --> B[高频CPU消耗]
    A --> C[状态同步延迟]
    A --> D[无效检查浪费]
```

### 输入检查

然而定期检查 会带来不必要的开销，在稍微复杂的场景中，会导致严重的性能问题，
因此最好能够在 `A0 = 5` 时，再检查是否发生变更，自动更新`A2`的值。

```ts
let A0 = 2
let A1 = 3
let A2
function updateValue(update) {
  let OA1 = A1
  let OA0 = A0

  update()

  if (OA0 !== A0 || OA1 !== A1) {
    A2 = A0 + A1
    console.log('A2:', A2)
  }
}
updateValue(() => {
  A0 = 5
})
// A2: 8
```

这种方式的好处是，只有在 重新输入 `A0` 或 `A1` 时，才会检查变更。
但这种代码，把 检查的代码、响应变更的代码都放在一起，会导致代码的复杂度增加。
我们期望的是，将它们分开，从而降低代码的复杂度。

```ts
let A0 = 2
let A1 = 3
let A2

const { onUpdate, updateValue } = createReactive(A0, A1) // 创建响应式

// 监听变更
onUpdate(() => {
  A2 = A0 + A1
})

// 更新变量
updateValue(() => {
  A0 = 5
})
```

### 状态机

在上面的代码中，我们很容易产生一个困惑，
`A0` 和 `A1` 作为外部变量，`createReactive` 函数内部如何知道它们是否有变化呢？

答案是，确实不知道。`A0` 和 `A1` 仅是 基本数据类型，即使传入`createReactive`，
函数内部也不知道它们何时发生变化。

因此，我们需要引入 `状态机`的概念，来解决这个问题。将 `A0` 和 `A1` 、`A2` 作为状态变量，而不是基本数据类型，
托管给 状态机。

```ts
const { subscribe, setState } = createReactive({
  A0: 2,
  A1: 3,
  A2: 5,
}) // 创建响应式

// 侦听变更
subscribe((state) => {
  state.A2 = state.A0 + state.A1
})

setState((state) => {
  return { A0: 5 }
})
```

我们可以很轻松的实现 一个简单的 `createReactive`：

```ts
function createReactive(initialState) {
  let state = initialState
  const listeners = new Set()

  // 添加订阅者
  const subscribe = (callback) => {
    listeners.add(callback)
  }

  const checkUpdate = (newState, oldState) => {
    // 实际情况需要对比 state 每个 key 的值，
    return newState !== oldState
  }

  const setState = (callback) => {
    const oldState = state
    const newState = { ...state, ...callback(state) }
    if (checkUpdate(newState, oldState)) {
      listeners.forEach(callback => callback(newState))
      state = newState
    }
  }
  return { state, subscribe, setState }
}
```

当然，实际情况远比这复杂的多，但至少是可以理解的，已经初具雏形。

在 `createReactive` 的帮助下，通过 `setState()` 更新 `A0` 和 `A1` 两个状态的值时，在函数内部
检查状态变更，然后在内部调用 侦听器，实现对 `A2` 状态的响应更新。

### 响应视图更新

到这里，你或许已经想到，这好像与 `React` 类似，然后想到，那么如何使视图更新呢?

其实 视图 也是一个 订阅者，在 `React` 组件中，我们通过 `render()` 方法来定义视图：

```tsx
class Counter extends React.Component {
  state = { count: 0 }
  render() {
    return (
      <div>
        <h1>{this.state.count}</h1>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>+</button>
      </div>
    )
  }
}
```

同样的，通过 `subscribe()` 方法来添加订阅者。

```ts
subscribe((state) => {
  render()
})
```

当调用 `setState()` 更新状态时， `render()` 也会被重新调用，从而更新视图。

## Vue2 的响应式系统

在有了以上的 基础了解后，你已经对 响应式编程 有了一个 基本的认识，和 对如何实现响应式编程 有了一定的了解。

接下来，我们来看看 `vue` 的响应式系统。

在 `vue2` 中，我们 仅 需要写 `this.count += 1` 就能触发视图更新。并没有看到 如 `setState()` 这样的方法帮助我们
检查状态变更和调用侦听者。 这看起来像是一个 “魔法” 。

事实上，`vue2` 通过 `Object.defineProperty`, 把 `count` 属性改成了 `getter/setter` ,
`getter/setter` 对用户而言，是不可见的。 当我们对 `this.count += 1` 时，实际上调用的是 `setter` 方法。

```ts
Object.defineProperty(this, 'count', {
  set(val) {
    this.count = val
  },
  get() {
    return this.count
  }
})
```

这样就有机会在 `setter` 方法中，进行状态变更检查，并调用侦听器。

```ts
Object.defineProperty(this, 'count', {
  set(val) {
    const oldValue = this.count
    this.count = val
    listeners.forEach(callback => callback(val, oldValue))
  },
  get() {
    return this.count
  }
})
```

---

---
url: /czxBlog/article/knagbtgd/index.md
---
# webpack模块热替换（HMR）
**模块热替换（Hot Module Replacement）** 是 webpack 的一个 十分有用且强大的 特性。
当我们对 文件代码进行修改并保存后，webpack 会重新编译打包文件代码，并将新的模块代码发送给客户端，
浏览器通过将旧模块替换为新模块，实现在浏览器不刷新的情况下，对应用进行更新。

## 前言

在还没有 HMR 之前，我们对文件代码进行更新保存后，想要查看更新后的内容，常常需要手动刷新浏览器。

但还好的是，也有一些 **live reload** 的工具库，这些库能够监听文件的变化，通知浏览器刷新页面，
从而帮助我们减少了重复的操作。

但是为什么还需要 HMR 呢？

当浏览器刷新，也意味着当前页面的状态丢失了。
比如，我们打开了一个弹窗，然后我们对弹窗的代码逻辑进行了修改并保存，浏览器刷新后，弹窗被关闭了，
我们需要重新进行交互打开弹窗。
这无疑会增加非常多的重复且无意义工作量、时间。

HMR 的作用，就是不仅帮助我们在无刷新的情况下更新了应用代码，同时还保留了应用的状态，让我们能避免了
大量重复操作，从而提高开发效率。

## 模块热替换

模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。

### 启用

启用 HMR 的方式很简单，[查看官方文档](https://www.webpackjs.com/guides/hot-module-replacement/)

### 特性

HMR有几个特性：

* 保留在完全重新加载页面时丢失的应用程序状态。
* 只更新变更内容，以节省宝贵的开发时间。
* 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。

## HMR基本流程

* **Step 1:**

  webpack watch 模式下，监听文件系统中的某个文件是否发生修改。当监听到文件发生变更时，
  根据配置文件**对模块进行重新编译打包**，并将打包后的代码 通过 JavaScript 对象保存在内存中。

* **Step 2:**

  webpack-dev-middleware 调用 webpack 的API 对代码的变化进行监控，并通知webpack，将代码打包到内存中。

* **Step 3:**

  webpack-dev-server 监听文件变化，不同于第一步的是，这一步不监听代码变化进行重新编译打包。
  当配置文件中配置了 `devServer.watchContentBase` 为 `true` 时，
  Server会监听配置的文件夹中静态文件的变化，如果发生变化，通知浏览器进行 `live reload`,即刷新页面。

* **Step 4:**

  webpack-dev-server 通过 sockjs 在浏览器和服务器端之间建立一个 websocket 长连接，
  将webpack编译打包的各个阶段的状态信息告知浏览器端，也包括第三步中 Server 监听静态文件变化的信息。
  浏览器端根据这些socket消息进行不同的操作。
  其中，服务器传递的最主要的信息，是新模块的 hash 值，后续步骤根据 hash值 进行模块的替换。

* **Step 5:**

  webpack-dev-server 虽然会告知浏览器打包状态，但在 webpack-dev-server/client 端并不会去请求更新的代码，
  也不会执行热模块替换的操作，这些工作会交回给 webpack/hot/dev-server。
  webpack/hot/dev-server 根据 webpack-dev-server/client 传给它的信息，以及 dev-server 的配置信息，
  来决定是刷新浏览器，还是执行 热模块替换。

* **Step 6:**

  在客户端中，HotModuleReplacement.runtime 接受到 上一步传递给它的新模块的 hash 值，
  通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，server 端返回一个 json。
  该 json 包含了所有要更新的模块的 hash 值，获取到需要更新的模块列表后，再发送一个 jsonp 请求，
  获取最新的模块代码。

* **Step 7:**

  HotModulePlugin 会对新旧模块进行对比，决定是否更新模块。
  在决定更新模块后，检查模块之间的依赖关系，更新模块的同时，也更新模块间的依赖引用。
  这个步骤也决定了 HMR 是否成功。

* **Step 8:**

  如果 HMR 失败，则回退到 live reload 操作，通过刷新浏览器来获取最新打包的代码。

---

---
url: /czxBlog/article/lasuemgv/index.md
---
# unknown 类型应用场景
`unknown` 类型 表示 不可预先定义的类型，在很多场景下，它可以代替 `any` 类型的功能
的同时，保留静态检查的能力。

## 类型转换

```ts twoslash
const num: number = 10
;(num as unknown as string).split('')
//                           ^?

// @log: 这里可以和 any 一样通过静态检查
```

这个例子可以看出， `unknown` 类型的作用和 `any` 类型的作用非常相似，你可以把它转换为任何类型。
区别在于，**`any` 在静态编译时可以调用任何方法，但 `unknown` 类型在静态编译时是不可以调用任何方法的** 。

```ts twoslash
// @errors: 18046
const foo: unknown = 'string'
foo.substr(1) // 静态检查不通过报错
const bar: any = 10
bar.substr(1)
```

## 替代 `any`

大多数情况下，我们可以选择使用 `unknown` 替代 `any`，从而避免由于使用 `any` 而带来的 静态类型
检查的失效。

如，避免使用 `any` 作为 函数参数类型，使用 `unknown` 替代。

**使用 any，静态检查失效：**

```ts twoslash
function test(input: any): number {
  if (Array.isArray(input)) {
    return input.length
  }
  return input.length
}
```

**使用 unknown，静态检查正确推断：**

```ts twoslash
// @errors: 18046
function test(input: unknown): number {
  if (Array.isArray(input)) {
    // 类型守卫将input识别为array类型
    return input.length
  }
  // input是unknown类型，静态检查报错
  return input.length
}
```

---

---
url: /czxBlog/article/ldvuv37p/index.md
---
# React组件渲染性能优化
在大型 React 应用中，组件渲染性能直接影响用户体验。

## 渲染机制与优化

当父组件状态变化时，React 默认会重新渲染该组件及其所有子组件，即使子组件的 props 未改变。

这种机制可能导致不必要的渲染开销：

```mermaid
graph TD
    A[父组件状态更新] --> B[父组件重新渲染]
    B --> C[子组件1重新渲染]
    B --> D[子组件2重新渲染]
    B --> E[子组件3重新渲染]
```

因此，优化核心策略是 阻断不必要的渲染链，我们可以通过 **浅比较(shallow comparison)** 来实现这一目标。

## 类组件渲染性能优化

::: warning
`shouldComponentUpdate` 和 `PureComponent` 主要用于 类组件，虽然 ==React 更推荐使用函数式组件=={.warning}，
但了解其渲染优化策略是有必要的。
不仅仅是因为对于维护旧的类组件代码有帮助，而且在优化策略上是相通的。
:::

我们先来看一个简单的 类组件 例子：

```tsx
class Child extends React.Component {
  render() {
    console.log('Child rendered')
    return (
      <div>
        <h1>
          Child Count:
          {this.props.count}
        </h1>
      </div>
    )
  }
}

class App extends React.Component {
  state = {
    count: 0,
    otherValue: 'Hello',
  }

  increment = () => {
    this.setState(prevState => ({ count: prevState.count + 1 }))
  }

  changeOtherValue = () => {
    this.setState(prevState => ({ otherValue: prevState.otherValue === 'Hello' ? 'World' : 'Hello' }))
  }

  render() {
    console.log('Parent rendered')
    return (
      <div>
        <h1>
          otherValue:
          {this.state.otherValue}
        </h1>
        <Child count={this.state.count} />
        <button onClick={this.increment}>Increment Count</button>
        <button onClick={this.changeOtherValue}>Change Other Value</button>
      </div>
    )
  }
}

export default App
```

在这个应用中，`Child` 组件的 Props `count` 是 `App` 的 `State` 的一部分。

当我们点击 `Increment Count` 按钮时，`App` 的 `count` 会增加，
此时，`App` 会重新渲染，`Child` 也会重新渲染。

::: center
![render-1](/images/react/optimize/rendered-1.png){style="max-width:640px"}
:::

当我们点击 `Change Other Value` 按钮时，`otherValue` 发生了改变，`App` 会重新渲染。
虽然 `Child` 组件没有用到 `otherValue`, 但 `Child` 依然重新渲染了。

::: center
![render-2](/images/react/optimize/rendered-2.png){style="max-width:640px"}
:::

这是因为当 Parent 组件的 `state` 或 `props` 发生变化时，React 会默认重新渲染该组件及其所有 Child 组件。

在这种情况下，我们可以通过 `shouldComponentUpdate` 来进行优化，来阻断不必要的渲染。

### shouldComponentUpdate

[**React** -> Component -> shouldComponentUpdate](https://zh-hans.react.dev/reference/react/Component#shouldcomponentupdate){.read-more}

`shouldComponentUpdate` 是 类组件 的生命周期。它用于决定组件是否需要更新。当返回 `true` 时，表示组件可以更新，
返回 `false` 时，表示组件不需要更新。

我们对 `Child` 组件进行优化：

```tsx
class Child extends React.Component {
  shouldComponentUpdate(nextProps) { // [!code ++:4]
    // 仅当count变化时更新
    return this.props.count !== nextProps.count
  }

  render() {
    console.log('Child rendered')
    // ...
  }
}
```

我们重新分别点击 `Increment Count` 和 `Change Other Value` 按钮，可以看到:

::: center
![render](/images/react/optimize/rendered-3.png){style="max-width:640px"}
:::

### PureComponent

[**React** -> PureComponent](https://zh-hans.react.dev/reference/react/PureComponent){.read-more}

除了使用 `shouldComponentUpdate` 进行优化外，React 还提供了一个更加简便的方法：使用 `PureComponent`。

`PureComponent` 类似于 `Component`，但是当 `props` 和 `state` 与之前保持一致时会跳过重新渲染。

我们使用 `PureComponent` 重写 `Child` 组件:

```tsx
class Child extends React.PureComponent {
  render() {
    console.log('Child rendered')
    return (
      <div>
        <h1>
          Child Count:
          {this.props.count}
        </h1>
      </div>
    )
  }
}
```

当 `count` 一致时，`Child` 会跳过重新渲染。

需要注意的是，`PureComponent` 只对 `Props` 和 `State` 进行浅比较，
如果 props 或 state 中包含复杂的数据结构（如对象或数组），浅比较可能无法正确判断数据是否发生变化。
在这种情况下，可以使用深比较或手动实现 `shouldComponentUpdate` 来确保组件正确地更新。

**浅比较的注意事项**：

```mermaid
graph LR
    A[原始数据] --> B[浅比较]
    C[对象/数组] --> D[引用地址比较]
    E[基本类型] --> F[值比较]
    B --> D
    B --> F
```

:::important 重要提示
当 props 包含嵌套对象时，需返回新引用（如 `[...list]` 或 `{...obj}`）才能触发更新。
:::

## 函数组件渲染性能优化

我们来看下面的 函数组件 例子：

::: tip 这是 React 推荐的函数组件写法
它实现了与上面的 类组件实现的 应用完全相同的功能。
:::

```tsx
import { useState } from 'react'

function Child({ count }) {
  console.log('Child rendered')
  return (
    <div>
      <h1>
        Child Count:
        {count}
      </h1>
    </div>
  )
}

function App() {
  const [count, setCount] = useState(0)
  const [otherValue, setOtherValue] = useState('Hello')

  const increment = () => {
    setCount(prevCount => prevCount + 1)
  }

  const changeOtherValue = () => {
    setOtherValue(prevValue => prevValue === 'Hello' ? 'World' : 'Hello')
  }

  console.log('Parent rendered')
  return (
    <div>
      <h1>
        otherValue:
        {otherValue}
      </h1>
      <Child count={count} />
      <button onClick={increment}>Increment Count</button>
      <button onClick={changeOtherValue}>Change Other Value</button>
    </div>
  )
}

export default App
```

当我们点击 `Increment Count` 按钮时，`App` 的 `count` 会增加，
此时，`App` 会重新渲染，`Child` 也会重新渲染。

::: center
![render-1](/images/react/optimize/rendered-1.png){style="max-width:640px"}
:::

当我们点击 `Change Other Value` 按钮时，`otherValue` 发生了改变，`App` 会重新渲染。
虽然 `Child` 组件没有用到 `otherValue`, 但 `Child` 依然重新渲染了。

::: center
![render-2](/images/react/optimize/rendered-2.png){style="max-width:640px"}
:::

### React.memo

[**React** -> memo](https://zh-hans.react.dev/reference/react/memo){.read-more}

`React.memo` 是一个高阶组件，使用 `memo` 将组件包装起来，以获得该组件的一个 记忆化 版本。
通常情况下，只要该组件的 props 没有改变，这个记忆化版本就不会在其父组件重新渲染时重新渲染。

我们使用 `React.memo` 重写 `Child` 组件:

```tsx
const Child = React.memo(({ count }) => { // [!code ++]
  console.log('Child rendered')
  return (
    <div>
      <h1>
        Child Count:
        {count}
      </h1>
    </div>
  )
})
```

我们重新分别点击 `Increment Count` 和 `Change Other Value` 按钮，可以看到:

::: center
![render](/images/react/optimize/rendered-3.png){style="max-width:640px"}
:::

::: tip 可以把 `React.memo` 看做是 `PureComponent` 的等价实现
`Rect.memo` 只对 `props` 进行浅比较
:::

对于 `props` 为比较复杂的数据结构时，我们可以在需要更新时返回一个新的对象或数组，以避免浅比较的问题。

还可以使用 `React.memo` 的第二个参数，自定义 `props` 的比较逻辑。

**React.memo 语法**：

```tsx
const Child = React.memo(
  props => <div>{/* ... */}</div>,
  (prevProps, nextProps) => {
    // 自定义比较逻辑
    // 如果返回true，表示新旧props相等，不渲染 与shouldComponentUpdate相反
    // 如果返回false，表示新旧props不等，重新渲染
  }
)
```

### useCallback

[**React** -> useCallback](https://zh-hans.react.dev/reference/react/useCallback){.read-more}

`useCallback` 是 React 提供的 `hook`，它用于在多次渲染中 ==缓存函数==。

我们重新调整下 `App` 的代码，将 `increment` 作为 `Child` 的 `props`，将按钮置于 `Child` 中：

```tsx
import React, { useState } from 'react'

const Child = React.memo(({ count, increment }: { count: number, increment: () => void }) => {
  console.log('Child rendered')
  return (
    <div>
      <h1>
        Child Count:
        {count}
      </h1>
      <button onClick={increment}>Increment Count</button>
    </div>
  )
})

function App() {
  const [count, setCount] = useState(0)
  const [otherValue, setOtherValue] = useState('Hello')

  const increment = () => {
    setCount(prevCount => prevCount + 1)
  }

  const changeOtherValue = () => {
    setOtherValue(prevValue => prevValue === 'Hello' ? 'World' : 'Hello')
  }

  console.log('Parent rendered')
  return (
    <div>
      <h1>
        otherValue:
        {otherValue}
      </h1>
      <button onClick={changeOtherValue}>Change Other Value</button>
      <Child count={count} increment={increment} />
    </div>
  )
}

export default App
```

分别点击 `Increment Count` 和 `Change Other Value` 按钮，可以看到:

::: center
![useCallback-1](/images/react/optimize/use-callback-1.png){style="max-width:640px"}
:::

当 `otherValue` 变化时，`App` 和 `Child` 都重新渲染了， `Child` 组件并没有使用 `otherValue` 。

实际问题是由于 `App` **每次重新渲染时，都创建了新的 `increment` 函数**，这对于 `Child` 来说，
`props` 发生了变化，所以重新渲染。

这显然是不必要的，可以使用 `useCallback` 来缓存 `increment` 函数:

```tsx
function App() {
  // ...
  const increment = useCallback(() => {
    setCount(prevCount => prevCount + 1)
  }, [])
  // ...
}
```

`useCallback` 接收两个参数，第一个参数是要缓存的函数，第二个参数是一个依赖项数组，如果依赖项发生变化，缓存的函数会重新创建。

在本示例中，由于 `increment` 比较简单，它不需要依赖项，所以只需要传入一个空数组即可。

分别点击 `Increment Count` 和 `Change Other Value` 按钮，可以看到:

::: center
![useCallback-2](/images/react/optimize/use-callback-2.png){style="max-width:640px"}
:::

可以看到，当 `otherValue` 变化时，`Child` 没有重新渲染了，这符合我们的预期。

::: important 实际开发中， `React.memo` 和 `useCallback` 通常会一起使用，以减少不必要的组件渲染，从而提高性能。
:::

::: warning 注意
在某些文章中会提到 `useCallback` 可以避免不必要的 **函数创建** 。这种说法是 ==错误的=={.danger} ！！！

函数组件在每次执行时，都会创建新的执行上下文，在函数作用域内，传入 `useCallback` 的函数，每次都是一个新的函数。

`useCallback` 的核心并不是在阻止函数的创建，而是 ==控制函数引用的更新时机=={.important} 。从而避免与其相关的组件
由于引用发生变化，导致不必要的重新渲染，从而提高性能。
:::

### useMemo

[**React** -> useMemo](https://zh-hans.react.dev/reference/react/useMemo){.read-more}

`useMemo` 用于缓存计算结果，避免在每次渲染时重新计算。

它适合在一些计算代价比较大的操作中使用。

::: info 说明
`useMemo` 有些类似于 `Vue` 的 `computed` 计算属性。

它缓存了当前计算结果，在下次渲染时，只要依赖项没有发生变化，则跳过计算，直接返回缓存的结果。
:::

举个例子，当我们在实现一个购物车功能时，总价需要根据当前购物车中的商品进行计算，
如果每次重新渲染时都需要重新计算总价，可能产生的代价是高昂的，浪费了性能。

我们可以使用 `useMemo` 来缓存计算结果，避免在每次渲染时重新计算:

```tsx
function ShoppingCart({ items }) {
  const total = useMemo(() => {
    console.log('计算总价...')
    return items.reduce((sum, item) =>
      sum + item.price * item.quantity, 0)
  }, [items]) // 仅当items变化时重新计算

  return (
    <div>
      总价:
      {total}
    </div>
  )
}
```

我们回到最开始的 `App` 应用，增加一个 `doubleCount` ，它需要根据 `count` 进行计算:

```tsx
function App() {
  // ...
  // 处于演示目的，使用一个简单的函数，实际可以直接写为 doubleCount = count * 2
  const doubleCount = () => { // [!code ++:4]
    console.log('doubleCount called')
    return count * 2
  }
  // ...
  console.log('App rendered')
  return (
    <div>
      {/* ... */}
      <p>
        Double Count:
        {doubleCount()}
      </p>
    </div>
  )
}
```

::: center
![useMemo-1](/images/react/optimize/use-memo-1.png){style="max-width:640px"}
:::

可以看到，不管是更新 `count` 还是更新 `otherValue` ， `doubleCount` 都会重新计算。
但 `doubleCount` 仅需要在 `count` 发生变化时才会重新计算，而 `otherValue` 变化时没必要重新计算。

此时我们可以使用 `useMemo` 来缓存计算结果，避免在每次渲染时重新计算:

```tsx
function App() {
  // ...
  const doubleCount = useMemo(() => { // [!code ++:4]
    console.log('doubleCount called')
    return count * 2
  }, [count])
  // ...
  console.log('App rendered')
  return (
    <div>
      {/* ... */}
      <p>
        Double Count:
        {doubleCount}
      </p>
    </div>
  )
}
```

::: center
![useMemo-2](/images/react/optimize/use-memo-2.png){style="max-width:640px"}
:::

可以看到， 当 `count` 变化时，`doubleCount` 重新计算，但 `otherValue` 变化时，`doubleCount` 没有重新计算，这符合我们的预期。

### 对比

| 特性       | React.memo                                  | useCallback                        | useMemo                            |
| :--------: | ------------------------------------------- | ---------------------------------- | ---------------------------------- |
| 主要功能   | 缓存组件                                    | 缓存函数                           | 缓存计算结果                       |
| 使用场景   | 当传入的 props 没有变化时，避免组件重新渲染 | 当函数没有变化时，避免函数重新执行 | 当计算结果没有变化时，避免重新计算 |
| 依赖项     | props                                       | 依赖数组                           | 依赖数组                           |
| 缓存目标   | 组件实例                                    | 函数引用                           | 计算结果                           |
| 返回值类型 | 组件                                        | 函数                               | 任意值                             |

## 总结

React 渲染优化核心在于 **精确控制组件更新时机** 。

特别需要注意的是：

* 所有优化都基于浅比较原理
* 函数组件优化需要 hooks 的配合使用
* 复杂数据结构需保证引用更新可预测性

::: important 性能优化第一原则
只有在性能监测工具（如 React DevTools Profiler）确认存在性能问题后才进行优化，避免过早优化带来的代码复杂度。
:::

---

---
url: /czxBlog/article/m0kwurpc/index.md
---
# React 原理解析——优先级调度
::: warning 🚧 施工中...
:::

React 的并发渲染能力依赖于其精细的优先级调度系统，==Lanes 模型== 是这一系统的基石。

## Lanes 模型

它使用 ==31 位二进制掩码== 表示不同优先级的更新任务，每个位称为一个 "Lane"（优先级通道）。

```txt
> 0b 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
                                                                 ^
                                                                最高优先级
> 0b 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
                                                               ^
                                                               第二优先级
> 0b 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1
                                                         ^     ^ ^
                                                         优先级组合
```

* 每个 Lane 对应一个二进制位，共 31 个
* 优先级从右向左递减（SyncLane 在 bit 2）
* 相同类型任务复用 lane 组（如 TransitionLanes 含 14 个 lane）

## Lanes 类型

1. **同步优先级**
   * `SyncHydrationLane`
   * `SyncLane`
2. **连续输入优先级**
   * `InputContinuousHydrationLane`
   * `InputContinuousLane`
3. **默认优先级**
   * `DefaultHydrationLane`
   * `DefaultLane`
4. **过渡优先级**
   * `TransitionHydrationLane`
   * `TransitionLane`, `TransitionLane1` ~ `TransitionLane14`
5. **重试优先级**
   * `RetryLanes`
   * `RetryLane1` ~ `RetryLane4`
6. **空闲优先级**
   * `IdleHydrationLane`
   * `IdleLane`
   * `OffscreenLane`
   * `DeferredLane`

[源码位置：**facebook/react** / **react-reconciler/src/ReactFiberLane.js#L39**](https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberLane.js#L36-L105){.read-more}

```ts :collapsed-lines
export const TotalLanes = 31

export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000

export const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001
export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010
export const SyncLaneIndex: number = 1

export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100
export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000

export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000
export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000

export const SyncUpdateLanes: Lane
  = SyncLane | InputContinuousLane | DefaultLane

export const GestureLane: Lane = /*                     */ 0b0000000000000000000000001000000

const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000010000000
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111100000000
const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000100000000
const TransitionLane2: Lane = /*                        */ 0b0000000000000000000001000000000
const TransitionLane3: Lane = /*                        */ 0b0000000000000000000010000000000
const TransitionLane4: Lane = /*                        */ 0b0000000000000000000100000000000
const TransitionLane5: Lane = /*                        */ 0b0000000000000000001000000000000
const TransitionLane6: Lane = /*                        */ 0b0000000000000000010000000000000
const TransitionLane7: Lane = /*                        */ 0b0000000000000000100000000000000
const TransitionLane8: Lane = /*                        */ 0b0000000000000001000000000000000
const TransitionLane9: Lane = /*                        */ 0b0000000000000010000000000000000
const TransitionLane10: Lane = /*                       */ 0b0000000000000100000000000000000
const TransitionLane11: Lane = /*                       */ 0b0000000000001000000000000000000
const TransitionLane12: Lane = /*                       */ 0b0000000000010000000000000000000
const TransitionLane13: Lane = /*                       */ 0b0000000000100000000000000000000
const TransitionLane14: Lane = /*                       */ 0b0000000001000000000000000000000

const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000
const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000
const RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000
const RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000
const RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000

export const SomeRetryLane: Lane = RetryLane1

export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000

const NonIdleLanes: Lanes = /*                          */ 0b0000111111111111111111111111111

export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000
export const IdleLane: Lane = /*                        */ 0b0010000000000000000000000000000

export const OffscreenLane: Lane = /*                   */ 0b0100000000000000000000000000000
export const DeferredLane: Lane = /*                    */ 0b1000000000000000000000000000000

// Any lane that might schedule an update. This is used to detect infinite
// update loops, so it doesn't include hydration lanes or retries.
export const UpdateLanes: Lanes
  = SyncLane | InputContinuousLane | DefaultLane | TransitionLanes

export const HydrationLanes
  = SyncHydrationLane
    | InputContinuousHydrationLane
    | DefaultHydrationLane
    | TransitionHydrationLane
    | SelectiveHydrationLane
    | IdleHydrationLane
```

## Lanes 操作机制

### 优先级计算

React 使用位运算实现高效优先级管理：

```ts
// 获取最高优先级Lane（最右侧的1）
export function getHighestPriorityLane(lanes: Lanes): Lane {
  return lanes & -lanes // 补码技巧：-lanes = ~lanes + 1
}

// 获取等或更高优先级的Lanes集合
function getLanesOfEqualOrHigherPriority(lanes: Lanes): Lanes {
  const lowestIndex = 31 - clz32(lanes) // 计算前导零
  return (1 << (lowestIndex + 1)) - 1 // 生成掩码
}
```

**位运算优势：**

* $O(1)$ 时间复杂度完成优先级查询
* 单次操作处理多个Lane（批量更新）
* 内存紧凑（单数字存储完整状态）

### 调度状态机

React 使用三状态模型管理任务生命周期：

```mermaid
stateDiagram-v2
    [*] --> Pending： 更新产生
    Pending --> Suspended： 数据未就绪
    Suspended --> Pinged： 数据到达
    Pinged --> Pending： 重试渲染
    Pending --> Committed： 渲染完成
    Suspended --> Expired： 超时处理
```

对应代码实现：

```ts
// 标记挂起任务
export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
  root.suspendedLanes |= suspendedLanes
  root.pingedLanes &= ~suspendedLanes
}

// 标记数据到达
export function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {
  root.pingedLanes |= root.suspendedLanes & pingedLanes
}

// 检测过期任务
export function markStarvedLanesAsExpired(root, currentTime) {
  let lanes = root.pendingLanes
  while (lanes) {
    const index = 31 - clz32(lanes)
    const lane = 1 << index
    if (root.expirationTimes[index] <= currentTime) {
      root.expiredLanes |= lane // 标记过期
    }
    lanes &= ~lane
  }
}
```

## 任务调度算法

### 调度决策流程

```mermaid
graph TD
    Start[开始] --> CheckPending{有pending任务?}
    CheckPending -->|无| ReturnNoLanes[返回NoLanes]

    CheckPending -->|有| CheckNonIdle{非空闲任务?}
    CheckNonIdle -->|是| CheckUnblocked{未阻塞任务?}
    CheckUnblocked -->|是| GetHighest[获取最高优先级]
    CheckUnblocked -->|否| CheckPinged{被ping任务?}
    CheckPinged -->|是| GetHighest
    CheckPinged -->|否| CheckPrewarm{需预热任务?}
    CheckPrewarm -->|是| GetHighest

    CheckNonIdle -->|否| CheckIdleUnblocked{空闲未阻塞?}
    CheckIdleUnblocked -->|是| GetHighest
    CheckIdleUnblocked -->|否| CheckIdlePinged{空闲被ping?}

    GetHighest --> CheckInterrupt{可中断当前渲染?}
    CheckInterrupt -->|否| ReturnWIP[返回进行中任务]
    CheckInterrupt -->|是| ReturnNew[返回新任务]
```

### 关键调度逻辑

```ts
export function getNextLanes(root, wipLanes, rootHasPendingCommit) {
  const pendingLanes = root.pendingLanes

  // 分层处理策略
  const nonIdlePendingLanes = pendingLanes & NonIdleLanes
  if (nonIdlePendingLanes !== NoLanes) {
    // 优先级1：未阻塞任务
    const unblocked = nonIdlePendingLanes & ~root.suspendedLanes
    if (unblocked !== NoLanes)
      return getHighestPriorityLanes(unblocked)

    // 优先级2：被ping任务
    const pinged = nonIdlePendingLanes & root.pingedLanes
    if (pinged !== NoLanes)
      return getHighestPriorityLanes(pinged)

    // 优先级3：需预热任务
    if (!rootHasPendingCommit) {
      const toPrewarm = nonIdlePendingLanes & ~root.warmLanes
      if (toPrewarm !== NoLanes)
        return getHighestPriorityLanes(toPrewarm)
    }
  }

  // 中断保护机制
  if (wipLanes !== NoLanes && wipLanes !== nextLanes) {
    const nextLane = getHighestPriorityLane(nextLanes)
    const wipLane = getHighestPriorityLane(wipLanes)
    if (nextLane >= wipLane)
      return wipLanes // 不中断当前渲染
  }
}
```

**调度策略**：

* **非空闲任务优先**：确保用户交互及时响应
* **状态分层处理**：未阻塞任务 > 被ping任务 > 需预热任务
* **渲染连续性保护**：避免高优先级任务中断进行中的低优先级渲染

### 嵌套更新处理

React 通过纠缠（Entanglement）机制处理关联更新：

```ts
export function markRootEntangled(root, entangledLanes) {
  root.entangledLanes |= entangledLanes
  const entanglements = root.entanglements

  let lanes = root.entangledLanes
  while (lanes) {
    const index = 31 - clz32(lanes)
    const lane = 1 << index
    // 传播纠缠关系
    entanglements[index] |= entangledLanes
    lanes &= ~lane
  }
}
```

**纠缠场景**：

* 同一事件触发的多个更新
* 父组件更新触发的子组件更新
* `useDeferredValue` 关联更新

### 过期时间计算

```ts
function computeExpirationTime(lane, currentTime) {
  switch (lane) {
    case SyncLane: return currentTime + 250 // 250ms超时
    case DefaultLane: return currentTime + 5000 // 5s超时
    case TransitionLane1: return currentTime + 5000 // 5s超时
    case IdleLane: return NoTimestamp // 永不过期
  }
}
```

### 批量更新处理

```ts
export function upgradePendingLanesToSync(root, lanesToUpgrade) {
  root.pendingLanes |= SyncLane
  root.entangledLanes |= SyncLane

  let lanes = lanesToUpgrade
  while (lanes) {
    const index = 31 - clz32(lanes)
    const lane = 1 << index
    // 将多个Lane关联到SyncLane
    root.entanglements[SyncLaneIndex] |= lane
    lanes &= ~lane
  }
}
```

## 与Scheduler的协同

```mermaid
graph TD
    A[用户交互/网络响应] --> B[React 渲染器]
    B --> C{Lanes 模型}
    C --> D[分配Lane和优先级]
    D --> E[React Scheduler]
    E --> F[执行高优先级任务]
    E --> G[暂停低优先级任务]
    F --> H[DOM 更新]
    G --> I[等待空闲时段]
```

---

---
url: /czxBlog/article/m4a92nl5/index.md
---
# JavaScript进阶（五）— 函数参数按值传递
我们知道，在 `ECMAScrip` 中， 函数的参数是 **按值传递** 的。

那么怎么理解 **按值传递** ？

简单来说， **把函数外部的值复制给函数内部的参数**，即 **把值从一个变量复制到另一个变量**。

那么也就是说，在函数内部，修改函数参数的值，不会改变外部变量的值。

我们来看一个例子：2

**示例1：**

```js
let a = 1
function foo(arg) {
  arg = 2
  console.log(arg)
}
foo(a) // 2
console.log(a) // 1
```

可以看出，外部变量`a`作为 函数 `foo` 的执行时参数值， 在函数内部修改传入的参数值进行修改，
函数执行后，并不会对外部变量`a` 发生修改。

这个例子确实说明了函数参数是按值传递的。

但是再来看另一个例子：

**示例2：**

```js
let obj1 = {
  a: 1,
}
function foo(arg) {
  arg.a = 2
  console.log(arg)
}
foo(obj1) // { a: 2 }
console.log(obj1) // { a: 2 }

let obj2 = {
  a: 1,
}
function bar(arg) {
  arg = 2
  console.log(arg)
}
bar(obj2) // 2
console.log(obj2) // { a: 1 }
```

在这个例子中， 函数`foo` 执行完后， 打印的 `obj1` 值发生了变化，说明函数`foo` 内部修改了外部变量`obj1`，
为什么会发生修改？而在 函数`bar` 执行后，`obj2` 值保持不变，这又是为什么？ 函数参数是否真的是 **按值传递**？

那么该如何理解 `函数参数是按值传递的`?

在理解这个之前，我们首先需要知道，`JavaScript` 的数据类型，以及不同数据类型的存储方式。

## 数据类型及其存储方式

我们知道， 在 `JavaScript` 中， 有两种 数据类型，分别是：**(1)基本数据类型**和 **(2)引用数据类型**，

* 基本数据类型：值 直接保存在 **栈（stack）** 中。

  ```js
  let a = 1
  let b = a
  a = 2
  console.log(a, b) // 2 1
  ```

  基本类型在 **栈** 中的赋值变动如下：
  ::: center
  ![function-value-stack](/images/func-value-stack.png){ style=width:500px; }
  :::

* 引用数据类型：值 保存在 **堆（heap）** 中， 并在 **栈（stack）** 中保存 值 在 **堆（heap）** 中的内存地址。

  ```js
  let a = { name: 'Mark' }
  let b = a
  b.name = 'John'
  console.log(a) // { name: 'John' }
  ```

  引用类型在 **栈** 和 **堆** 中的复制变动如下：
  ::: center
  ![function-value-stack](/images/func-value-heap.png){ style=width:680px; }
  :::

## 按值传递

我们从 数据类型来理解 `按值传递`, 那么可以发现， **传递** 的值， 是指在 **栈（stack）** 中保存的值。

即， 无论 **参数值** 是 基本数据类型还是引用数据类型， **传递** 的是 **栈（stack）** 中的值。

* 对于基本数据类型， 函数内部修改参数的值，实际上是修改的是 函数参数重新在 **栈（stack）** 中的内存片段保存的值。

* 对于引用数据类型， 函数参数 传递是的 引用类型在 **栈（stack）** 中的内存地址：
  * 如果直接修改参数的值，函数参数在 **栈（stack）** 中的内存片段保存的内存地址被覆盖。
  * 如果修改 参数对象的属性值，修改的是根据 函数参数在 **栈（stack）** 中的内存片段保存的内存地址对应的在 **堆（heap）** 中的值。

所以回头重新看 **示例1** 和 **示例2**， 均正确表述了 函数的参数是 **按值传递** 的。

---

---
url: /czxBlog/article/npm-semantic-versions/index.md
---
# npm 语义化版本管理
## 前言

当我们着手进行项目开发时，为了方便项目管理，需要为项目定义一个版本。
可是，项目的版本号，应该怎么写呢？ 是 `1.0`，还是 `0.1` 还是 `1.0.0` 还是 `0.0.1` 呢？

如果是使用了 `1.0.0` 作为起始，那么下一次版本，应该是 `1.0.1` 还是 `1.1.0` 呢？

我们经常在一些开源的项目中，看到一些项目的版本号，还携带了后缀， 比如 `vue` 的 `3.0.0-beta.0`，
或者 `react` 的 `18.0.0-rc.0`。这些后缀有代表了什么含义呢？

## Semver 规范

使用一种好的版本号管理方案，可以帮助我们快速的了解版本的变化范围。

这并不是一个创新性的想法，实际上，你可能已经在做近似的事情了。问题在于只是“近似”还不够。
如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。
将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。
一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。

在 开源社区中，由 Gravatars 创办者兼 GitHub 共同创办者
[Tom Preston-Werner](http://tom.preston-werner.com/) 建立了 语义化版本控制的规范, `semantic version` 简称 `semver`，即 这个规范称为 `semver 规范`。

你可以在 <https://semver.org/lang/zh-CN/> 了解 `semver` 规范的详细信息。

### 版本号格式

版本格式：**主版本号.次版本号.修订号** ，我们以 `X.Y.Z` 作为 格式别名。

其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零，X 是主版本号、Y 是次版本号、而 Z 为修订号，
每个元素必须（MUST）以数值来递增。如 `1.9.1 -> 1.10.0 -> 1.11.0`。

### 版本控制规范

1. 标记版本号的软件发行后，**禁止** 改变该版本软件的内容。任何修改都 **必须** 以新版本发行。

2. 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。

3. 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。

4. 修订号 Z（x.y.Z | x > 0）**必须** 在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。

5. 次版本号 Y（x.Y.z | x > 0）**必须** 在有向下兼容的新功能出现时递增。
   在任何公共 API 的功能被标记为弃用时也 **必须递增**。
   也 **可以** 在内部程序有大量新功能或改进被加入时递增，其中 **可以** 包括修订级别的改变。
   每当次版本号递增时，修订号 **必须** 归零。

6. 主版本号 X（X.y.z | X > 0）**必须**在有任何不兼容的修改被加入公共 API 时递增。
   其中 **可以** 包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号 **必须** 归零。

7. 先行版本号 **可以** 被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。
   标识符 **必须** 由 ASCII 字母数字和连接号 `[0-9A-Za-z-]` 组成，且 **禁止**留白。
   数字型的标识符 **禁止** 在前方补零。先行版的优先级低于相关联的标准版本。
   被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。
   范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。

8. 版本编译信息 **可以** 被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。
   标识符 **必须** 由 ASCII 字母数字和连接号 `[0-9A-Za-z-]` 组成，且 **禁止** 留白。
   当判断版本的优先层级时，版本编译信息 **可** 被忽略。
   因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。

   范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。

9. 版本的优先层级指的是不同版本在排序时如何比较。

   1. 判断优先层级时，**必须** 把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较
      （版本编译信息不在这份比较的列表中）。

   2. 由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。

      例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。

   3. 当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。

      例如：1.0.0-alpha < 1.0.0。

   4. 有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级 **必须** 透过由左到右的每个被句点
      分隔的标识符来比较，直到找到一个差异值后决定：

      1. 只有数字的标识符以数值高低比较。

      2. 有字母或连接号时则逐字以 ASCII 的排序来比较。

      3. 数字的标识符比非数字的标识符优先层级低。

      4. 若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。

      例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。

#### 总结递增规则如下

* 主版本号：当你做了不兼容的 API 修改，
* 次版本号：当你做了向下兼容的功能性新增，
* 修订号：当你做了向下兼容的问题修正。

先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

## FAQ

### 在 0.y.z 初始开发阶段，我该如何进行版本控制？

最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。

### 如何判断发布 1.0.0 版本的时机？

当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。
如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。

### 语义化版本对于版本的字符串长度是否有限制呢？

没有，请自行做适当的判断。举例来说，长到 255 个字符的版本已过度夸张。
再者，特定的系统对于字符串长度可能会有他们自己的限制。

### “v1.2.3” 是一个语义化版本号吗？

“v1.2.3” 并不是一个语义化的版本号。但是，在语义化版本号之前增加前缀 “v” 是用来表示版本号的常用做法。
在版本控制系统中，将 “version” 缩写为 “v” 是很常见的。
比如：git tag v1.2.3 -m "Release version 1.2.3" 中，“v1.2.3” 表示标签名称，而 “1.2.3” 是语义化版本号。

## alpha、beta、rc

在规范中， 先行版本中 `-` 后的字符是自定义的，我们经常可以看到一些开源库使用的标识符如 `alpha`、`beta`、`rc`。

一般来说，这些 标识符表示以下含义：

* `alpha`: 表示 内部测试版本。主要是提供给内部的开发和测试使用，不建议用户下载。
* `beta`: 表示 公开测试版本。用户可以提前尝试使用一些功能。
* `rc`: 表示预览版本。表示该版本不再增加新的功能，可能还存在一些 bug，修复完成后就到 正式版本了。

## npm 指定版本范围

我们可以在 `package.json` 中看到版本号之前出现如 `^` 或 `~` 等符号，如：

```json
{
  "vuepress": "^1.9.7",
  "vue": "~2.7.11"
}
```

这些符号表示以后该库 安装版本的 允许范围。

通常常见的字符包括： `^`、 `~` 、 `>`、`<`、`<=`、`>=` 等。

`^` 表示 次版本号的更新，比如 `^1.2.3` 就表示以后安装的版本 `>=1.2.3 <2.0.0`。
但是如果 主版本号为 `0`，比如 `^0.2.3` 相当于 `>=0.2.3 <0.3.0`； `^0.0.3` 相当于 `>=0.0.3 <0.0.4`。

`~` 表示 修订号的更新，比如 `~1.2.3` 就表示以后安装的版本 `>=1.2.3 <1.3.0`。

完整版本范围说明，查看 [npm 文档](https://docs.npmjs.com/cli/v8/configuring-npm/package-json#dependencies)

---

---
url: /czxBlog/article/o5g7ggvf/index.md
---
# BFC 块级格式化上下文
## 概念

BFC, Block Formatting Context。是 W3C CSS2.1规范中的一个概念。 是页面中的一块块级渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和作用。

具有BFC特性的元素，可以看做是一个被隔离了的独立容器，容器内的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。

## 创建BFC的方式

1. 根元素（html）
2. 浮动元素，即 float值不为 none。
3. 绝对定位元素， 元素的 position 为 absolute 或者 fixed
4. 行内块元素， 元素的 display 为 inline-block
5. 表格单元格， 元素的 display 为 table-cell。 （HTML表格单元格默认为该值）
6. 表格标题， 元素的display为table-caption。 （HTML表格标题默认为该值）
7. 匿名表格单元格元素， 元素的display为 table、table-row、table-row-group、table-header-group、table-footer-group 。
   （分别是 HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table。
8. overflow计算值不为visible的块元素
9. display值为 flow-root的元素
10. contain值为 layout、content、paint的元素
11. 弹性元素，display为 flex、inline-flex元素的直接子元素
12. 网格元素， display为gird、inline-gird元素的直接子元素
13. 多列容器，元素的column-count或column-width不为 auto， 包括column-count不为1
14. colum-span为all的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中。

## 作用

1. 同一个BFC的外边距会发生折叠（合并）， 通过将其放在不同的BFC中规避折叠。
2. BFC可以包含浮动元素，即清除浮动。
3. BFC可以阻止元素被浮动元素覆盖。

---

---
url: /czxBlog/article/ofp08jd8/index.md
---
# VSCode 常用插件推荐
`VS Code` 作为我现在工作中最常用的编辑器，也是我十分喜欢的编辑器。它强大的功能和插件系统，对我的工作提供了很多帮助和支持。将我在工作中经常使用的插件，推荐给大家。

### Code

1. [Code Spell Checker](https://github.com/Jason-Rev/vscode-spell-checker)

   单词拼写检查插件，帮助检查代码中单词是否拼写错误，包括驼峰形式的变量名称检查。可以在一定程度避免一些不必要的单词拼写错误导致的一些低级错误。

2. [ESLint](https://github.com/Microsoft/vscode-eslint)

   javascript ES6 代码规范、语法检查工具，帮助规范团队代码规范。

3. [EditorConfig](https://github.com/editorconfig/editorconfig-vscode)

   编辑器配置，代码格式规范相关，必备。

4. [Prettier](https://github.com/prettier/prettier-vscode)

   帮助格式化`javascript`、`typescript`、`CSS`代码。&#x20;
   `Prettier` 会读取 `.editorconfig`，或根据提供相关配置，格式化代码为符合项目代码规范。

5. [Bracket Pair Colorizer](https://github.com/CoenraadS/BracketPair)

   可以对每一个代码块或者每一层嵌套，以不同的颜色高亮，帮助阅读代码。
   ![Bracket Pair Colorizer](https://github.com/CoenraadS/BracketPair/raw/develop/images/example.png)&#x20;
   主要是针对 `()`，`[]`，`{}` 进行不同嵌套的颜色高亮

6. [Code Runner](https://github.com/formulahendry/vscode-code-runner)

   在`VSCode`中运行各种各样的语言。并将结果输出到输出控制台。
   方便代码调试。

7. [Color Highlight](https://github.com/sergiirocks/vscode-ext-color-highlight)

   颜色高亮插件，读取文件中的 十六进制、RGB、RGBA 等颜色，并以对应的颜色高亮显示。

### theme

1. [Atom One Dark Theme](https://github.com/akamud/vscode-theme-onedark)

   一款 Atom 的 暗色系主题皮肤。 习惯了`Atom`编辑器，转而使用`VSCode`的小伙伴们可以使用这款皮肤。
   颜色对比度适中，不会太过强烈。
   ![Atom One Dark Theme](https://raw.githubusercontent.com/akamud/vscode-theme-onedark/master/screenshots/preview.png)

### GIT

1. [Git Blame](https://marketplace.visualstudio.com/items?itemName=waderyan.gitblame)

   可以帮助查看到文件的每一行的详细修改信息，包括 HASH串、作者、日期等。

2. [Git history](https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory)

   以可视化的界面查看 git log 信息。支持：
   查看所有分支或者某一个分支的log信息；
   查看某一个文件的log信息；
   查看某一个作者的log信息等。

3. [Git Project Manager](https://github.com/felipecaputo/git-project-manager)

   该插件可以帮助你快速在VSCode新窗口打开本地git项目。
   命令：`ctrl+shift+p` / `cmd+shift+p`&#x20;
   或者按下 `F1`，输入 `GPM`

4. [Git Tags](https://github.com/leftstick/vscode-git-tags)

   Git Tag 管理插件

5. [Git Lens](https://gitlens.amod.io/)

   这款插件十分适合在多人协作项目中使用，可以定位到当前文件每一行的最后提交作者、时间等git log，也可以查看到当前文件的所有日志等。
   如果有装这一款插件，`Git Blame`插件就没有必要装了。

6. [git ignore](https://github.com/CodeZombieCH/vscode-gitignore)

### Markdown

1. [Markdown Preview Enhanced](https://shd101wyy.github.io/markdown-preview-enhanced)

   一款功能强大的 markdown 插件。让你在vscode 中拥有更好的 markdown 写作体验。

### Icon

1. [vscode-icons](https://github.com/vscode-icons/vscode-icons)
   文件菜单 icons。 根据文件夹命名、文件后缀等，对文件夹、文件菜单栏添加 对应的`icon`。
   ![vscode-icons](https://raw.githubusercontent.com/vscode-icons/vscode-icons/master/images/screenshot.gif)

2. [VSCode Great Icons](https://marketplace.visualstudio.com/items?itemName=emmanuelbeziat.vscode-great-icons)
   另一款 文件菜单栏 icons，支持 100+的文件类型。
   ![VSCode Great Icons](https://raw.githubusercontent.com/EmmanuelBeziat/vscode-great-icons/icons-test/icons.jpg)

### IDE support

1. [View In Browser](https://github.com/hellopao/view-in-browser)

   快速打开html页面在浏览器中访问。

2. [ftp-simple](https://github.com/humy2833/FTP-Simple)

   FTP 上传/下载插件。

3. [Rest Client](https://github.com/Huachao/vscode-restclient)

   允许你在 `VSCode` 中发送HTTP请求，并查看response的内容。

### Framework support

1. [Vetur](https://github.com/vuejs/vetur)

   Vue 支持。

2. [minapp](https://github.com/wx-minapp/minapp-vscode)

   微信小程序 支持。

---

---
url: /czxBlog/article/or9sfaj3/index.md
---
# 怎么写前端开发的 AI prompt ？
## 前言

早上 10 点，当你准备正式开始今天的开发任务时，发现隔壁的前端同学悠闲的看着屏幕，AI 正在输出着代码，
他看了几眼觉得不错便接受了这份代码，于是你也开始让你的 AI 工具帮你写代码。

::: tip 以下示例来自于 [Trae](https://www.trae.ai/) 生成的结果
:::

你不假思索的告诉 AI ：

```txt
帮我用 Vue 写一个登录页面
```

于是，AI 框框一顿输出：

::: code-tabs

@tab AI Chat

```txt :collapsed-lines

我将创建一个登录页面，首先查看项目结构和依赖。
...

让我查看路由配置文件，以便添加登录页面路由。
...

创建登录页面组件，包含用户名和密码输入框以及登录按钮。
...

添加登录页面路由配置。
...

启动开发服务器以预览登录页面。
...

为用户打开登录页面预览。
...

预览

我已经完成了登录页面的创建，主要完成了以下工作：

1. 创建了登录页面组件 <mcfile name="Login.vue" path="/my-vue-app/src/views/Login.vue"></mcfile>，包含：
   - 用户名和密码输入框
   - 登录按钮
   - 美观的页面样式
   - 基础的登录逻辑

2. 在路由配置 <mcfile name="router.ts" path="/my-vue-app/src/router.ts"></mcfile> 中添加了登录页面路由

3. 启动了开发服务器，你可以通过访问 http://localhost:5174/login 来预览登录页面

登录页面已经具备基本的UI和交互功能，你可以进一步根据需求添加：
- 实际的登录接口调用
- 表单验证
- 记住密码功能
- 更多的样式定制

```

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
import { ref } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()
const username = ref('')
const password = ref('')

function handleLogin() {
  // 这里添加登录逻辑
  if (username.value && password.value) {
    // 模拟登录成功
    router.push('/')
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-box">
      <h2>登录</h2>
      <div class="form-item">
        <input
          v-model="username"
          type="text"
          placeholder="请输入用户名"
        >
      </div>
      <div class="form-item">
        <input
          v-model="password"
          type="password"
          placeholder="请输入密码"
        >
      </div>
      <button
        class="login-button"
        @click="handleLogin"
      >
        登录
      </button>
    </div>
  </div>
</template>

<style scoped>
/** ... */
</style>
```

:::

emmmm，是有个页面了，但是不对，你发现 用户名和密码没有进行校验，于是你告诉 AI：

```txt
对用户名和密码进行校验
```

于是，AI 又框框一顿输出:

::: code-tabs

@tab AI Chat

```txt :collapsed-lines
查看登录页面组件代码，以添加表单验证功能。
...

添加用户名和密码的验证逻辑，包括长度限制和错误提示。
...

我已经为登录表单添加了验证功能，主要包括以下内容：

1. 用户名验证：
   - 不能为空
   - 长度至少3个字符
   - 失去焦点时触发验证

2. 密码验证：
   - 不能为空
   - 长度至少6个字符
   - 失去焦点时触发验证

3. 错误提示：
   - 添加了错误信息显示样式
   - 错误信息显示在输入框下方
   - 使用红色文字突出显示

4. 登录验证：
   - 点击登录按钮时会验证所有字段
   - 只有当所有验证通过后才会执行登录操作

现在你可以在登录页面测试这些验证功能：
1. 尝试输入短于3个字符的用户名
2. 尝试输入短于6个字符的密码
3. 不输入任何内容直接点击登录按钮
```

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
import { ref } from 'vue'

const usernameError = ref('') // [!code ++]
const passwordError = ref('') // [!code ++]

function validateUsername() { // [!code ++:12]
  if (!username.value) {
    usernameError.value = '请输入用户名'
    return false
  }
  if (username.value.length < 3) {
    usernameError.value = '用户名至少3个字符'
    return false
  }
  usernameError.value = ''
  return true
}

function validatePassword() { // [!code ++:12]
  if (!password.value) {
    passwordError.value = '请输入密码'
    return false
  }
  if (password.value.length < 6) {
    passwordError.value = '密码至少6个字符'
    return false
  }
  passwordError.value = ''
  return true
}

function handleLogin() {
  const isUsernameValid = validateUsername() // [!code ++:4]
  const isPasswordValid = validatePassword()

  if (isUsernameValid && isPasswordValid) {
    // 模拟登录成功
    router.push('/')
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-box">
      <h2>登录</h2>
      <div class="form-item">
        <input
          v-model="username"
          type="text"
          placeholder="请输入用户名"
          @blur="validateUsername"
        >
        <div v-if="usernameError" class="error-message">
          {{ usernameError }}
        </div>
      </div>
      <div class="form-item">
        <input
          v-model="password"
          type="password"
          placeholder="请输入密码"
          @blur="validatePassword"
        >
        <div v-if="passwordError" class="error-message">
          {{ passwordError }}
        </div>
      </div>
      <button
        class="login-button"
        @click="handleLogin"
      >
        登录
      </button>
    </div>
  </div>
</template>

<style scoped>
.error-message { /* [!code ++:5] */
  color: #f56c6c;
  font-size: 0.875rem;
  margin-top: 0.5rem;
}
</style>
```

:::

你心想，还是不对，需要对密码进行格式校验，限制必须包含数字，字母，特殊字符，于是你又告诉 AI：

```txt
对密码进行格式校验，限制必须包含数字，字母，特殊字符
```

于是，AI 又框框一顿输出:

::: code-tabs

@tab AI Chat

```txt :collapsed-lines
添加密码格式校验规则，要求包含数字、字母和特殊字符。
...

我已经添加了密码格式的校验规则，具体包括：

1. 密码格式要求：
   - 必须包含数字（0-9）
   - 必须包含字母（a-z或A-Z）
   - 必须包含特殊字符（!@#$%^&*(),.?":{}|<>中的任意字符）
   - 保留原有的长度至少6个字符的要求

2. 校验逻辑：
   - 使用正则表达式分别检测数字、字母和特殊字符
   - 如果缺少任意一种字符类型，显示错误提示
   - 所有条件满足后才能通过验证

3. 错误提示：
   - 当密码格式不符合要求时，会显示"密码必须包含数字、字母和特殊字符"
   - 错误提示会显示在密码输入框下方

现在你可以测试以下场景：
1. 只输入数字（不通过）
2. 只输入字母和数字（不通过）
3. 输入包含数字、字母和特殊字符的密码（通过）
```

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
// ...
function validatePassword() {
  if (!password.value) {
    passwordError.value = '请输入密码'
    return false
  }
  if (password.value.length < 6) {
    passwordError.value = '密码至少6个字符'
    return false
  }
  const hasNumber = /\d/.test(password.value)
  const hasLetter = /[a-zA-Z]/.test(password.value)
  const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password.value)

  if (!hasNumber || !hasLetter || !hasSpecial) {
    passwordError.value = '密码必须包含数字、字母和特殊字符'
    return false
  }

  passwordError.value = ''
  return true
}
// ...
</script>

<template>
  <div class="login-container">
    <!-- ... -->
  </div>
</template>

<style scoped>
/* ... */
</style>
```

:::

你觉得还行，但是样式不对，而且还没有对接后端，于是你又告诉 AI ...

你陷入与 AI 的一轮轮对话中...

你不停的重复审查着 AI 的代码...

随着对话内容越来越多，AI 开始忘了你最开始的需求...

你又重新告诉 AI ...

时间不知不觉就到中午了...

你发现，怎么比自己写还花时间 ！

## 不要让 AI 自由发挥

发现了吗，从第一句 `“帮我用 Vue 写一个登录页面”` 开始，AI 都是在自由发挥。

它并不清楚你具体想要的是什么，但是 AI 不会拒绝你，它按照它的 “经验”，猜你想要的可能是这样的。
但你觉得这不是你要的，于是你又一遍遍的片面的补充你的需求，AI 也只能一遍遍的片面的输出代码。

这就像是，你遇到了一个外行，一来就告诉你，“尽快给我做一个登录页” 。一听到这话，你的第一想法是什么？

开始干活？还是火气很大？

登录页？什么登录页？要干什么？没需求文档吗？没设计稿吗？有 API 接口吗？

你开始和这个外行不停的聊具体的需求内容，他甚至可能都不知道他自己想要的是什么，于是你可能直接拒绝。

但 AI 不会拒绝你，你要什么，它就给你什么，它开始自由发挥，即使是胡编乱造。

所以，我们要 **避免让 AI 自由发挥**。你的需求越明确，AI 就越知道它应该怎么做。

## 写个需求文档

作为一个开发人员，我们希望有一个明确的需求文档，不用和产品经理反反复复的交流，不用和其他人争论需求模糊的地方，
可以专注于写代码，对于 AI 而言同样也是如此。当你跟 AI 对话时，你不应该只把自己当做技术开发，还要代入产品经理
的角色，你希望产品经理给你一份什么样的需求文档，你也应该准备一份相同的需求文档给 AI。

::: info 那么如何写一份 AI 能理解的需求文档？
:::

对于这个问题，当然是先问下 AI 啦：

::: chat title="DeepSeek"
{.}
在前端开发中使用 AI 帮助生成相关的代码时，prompt 应该如何编写？

{deepseek}
在前端开发中使用 AI 生成代码时，**清晰、具体、结构化**的 prompt 是关键。以下是编写高效 prompt 的方法和示例：

***

**Prompt 设计原则**:

1. **明确技术栈**
   指定框架（React/Vue/Angular）、语言（TS/JS）、UI 库（Tailwind/MUI/AntD）。
   > ❌ 模糊：*"生成一个按钮"*
   > ✅ 明确：*"用 React + TypeScript + Tailwind CSS 创建一个带悬停动画的蓝色按钮"*

2. **描述功能细节**
   包含交互逻辑、状态处理、API 集成等关键行为。
   > ✅ 示例：
   > \_"创建一个计数器组件：
   >
   > * 显示当前数字，初始值为 0
   > * 有 '+' 和 '-' 按钮，点击后数字增减
   > * 当数字为 0 时，'-' 按钮禁用（灰色）"\_

3. **定义样式要求**
   指定布局、响应式规则、动效等。
   > ✅ 示例：
   > \_"使用 Flexbox 实现响应式导航栏：
   >
   > * 移动端：汉堡菜单（点击展开）
   > * 桌面端：水平排列
   > * 悬停时链接变蓝色，带 300ms 过渡效果"\_

4. **提供输入/输出示例（可选但推荐）**
   帮助 AI 理解数据结构。
   > ✅ 示例：
   > *"根据以下数据生成商品卡片组件：
   > 输入数据格式：{ id: number, name: string, price: number }
   > 输出：卡片包含商品名、价格，并添加 '加入购物车' 按钮"*

5. **约束条件**
   明确禁止或限制项（如性能要求、兼容性）。
   > ✅ 示例：
   > *"避免使用任何第三方库，仅用原生 JavaScript 实现轮播图，支持触摸滑动"*

***

**二、Prompt 模板**:

```markdown
### 技术栈
[框架/库]，[语言]，[样式方案]

### 功能需求
1. 核心功能描述...
2. 交互逻辑（如点击/输入事件）...
3. 状态管理要求...

### 样式要求
- 布局方式...
- 响应式规则...
- 动画/过渡效果...

### 其他约束
- 输入数据格式示例: { key: type }
- 浏览器兼容性...
- 禁止使用...
```

***

**三、实战示例**:

案例 1：API 数据表格

```markdown
### 技术栈
React + TypeScript + Ant Design

### 功能需求
1. 从 API 端点 `https://api.example.com/users` 获取用户数据
2. 显示表格列：ID、姓名、邮箱、注册日期
3. 添加搜索框（按姓名过滤）
4. 分页控制（每页 10 条）

### 样式要求
- 表格行在悬停时高亮显示浅蓝色
- 搜索框位于表格右上角

### 其他约束
- 使用 Axios 请求数据
- 处理加载状态（显示 Loading 动画）
- 处理错误状态（显示错误信息）
```

案例 2：动画交互组件

```markdown
### 技术栈
Vue 3 + CSS Modules

### 功能需求
1. 折叠面板组件（Accordion）
2. 点击标题展开/收起内容区域
3. 展开时内容下滑动画（300ms 缓动效果）

### 样式要求
- 标题背景色：#f5f5f5，悬停时变为 #e0e0e0
- 内容区域内边距：16px
- 移动端适配（宽度 < 768px 时字体缩小）

### 其他约束
- 使用 Vue 的 Transition 实现动画
- 禁止使用任何外部 UI 库
```

***

**四、优化技巧**:

1. **迭代优化**：
   首先生成基础代码，再通过追加 prompt 改进：
   > *"为上述表格添加排序功能（点击表头按字母排序）"*

2. **错误处理**：
   若 AI 输出不符合预期，明确指出问题：
   > ❌ *"代码有错"*
   > ✅ *"提交按钮未做表单验证，请添加邮箱格式校验（正则表达式）"*

3. **要求伪代码**：
   复杂逻辑可先要求设计思路：
   > *"请先提供伪代码：如何用 Redux 管理购物车状态？"*

4. **拆分任务**：
   大型功能拆解为子组件：
   > 先生成 *"Header 组件"* → 再生成 *"侧边栏组件"* → 最后集成

***

**五、避免的常见错误**:

1. **过于宽泛**
   ❌ *"做一个电商网站"*
   ✅ *"生成商品详情页的图片轮播组件"*

2. **忽略边界条件**
   ❌ *"实现登录表单"*
   ✅ *"登录表单需包含：邮箱验证、密码强度提示、错误处理（API 返回 401 时显示错误信息）"*

3. **技术栈冲突**
   ❌ *"用 jQuery 和 React 一起实现..."*
   ✅ 明确技术组合是否合理

***

**最终建议**：将 AI 视为高级协作者，用写「需求文档」的思维编写 prompt。清晰的 prompt 不仅能提升代码质量，还能减少返工迭代次数。
:::

这很清晰，我们按照这份建议，采用它的模板写一份需求文档：

```md
### 技术栈
Vue3 + @vueuse/core + element-plus

### 功能需求
- 登录页面
- 使用 邮箱/手机号码 + 密码 登录
- 校验 邮箱 / 手机号码 格式
- 校验 密码：
  - 长度大于等于 6 小于等于 16
  - 密码由 大小写字母、数字、特殊符号 组成
  - 必须包含 大写字母
  - 根据密码强度显示不同的提示信息
  - 密码强度：弱，中，强
- 在失去焦点时校验，并在错误时显示错误信息，当用户重新输入时，清空错误信息
- 点击登录按钮时，调用 `/api/login` 接口，成功后跳转到首页

### 样式要求
- 不需要进行移动端适配
- 采用左右布局，右侧为登录表单，左侧为背景大图，在中间垂直居中
- 表单内容区域内边距 16px
- 在合适的地方添加过渡动画
```

来看看 AI 输出了什么：

::: code-tabs

@tab AI Chat

```txt :collapsed-lines
让我们先查看项目结构和相关文件，以确定需要创建和修改的内容。

filePath: /src/main.ts
/src/router.ts
/package.json

需要安装 element-plus 和 @vueuse/core 依赖，让我们先查看它们的最新版本和安装方式。
...

首先安装所需的依赖包：element-plus、@vueuse/core 以及自动导入插件。
...

让我们查看 vite.config.ts 文件，以配置 Element Plus 和自动导入插件。
...

配置 vite.config.ts，添加 Element Plus 的自动导入插件。
...

让我们查看 App.vue 和 router.ts 文件，以添加登录页面路由和修改布局。
...

创建登录页面组件，实现登录表单和布局。
...

更新路由配置，添加登录页面路由并设置为默认路由。
...

更新 App.vue，优化布局和样式。
...

让我们打开预览页面查看登录界面效果。

预览

已完成登录页面的开发，主要实现了以下功能：

1. 页面布局
- 采用左右布局设计，左侧为带动画效果的 Logo 展示区
- 右侧为登录表单区域，整体采用卡片式设计
- 添加了页面切换和表单交互动画

2. 登录表单功能
- 支持邮箱/手机号码 + 密码登录
- 实现了完整的表单验证：
  - 邮箱/手机号码格式验证
  - 密码复杂度验证（长度、大小写字母、数字、特殊符号）
  - 密码强度实时显示（弱、中、强）
- 添加了输入框清空功能和密码显示/隐藏功能

3. 路由配置
- 添加了登录页面路由
- 实现了路由守卫，未登录状态自动跳转到登录页

4. 样式优化
- 统一的颜色主题
- 响应式输入框动画
- 页面过渡动画
- 左侧 Logo 悬浮动画

现在可以通过访问 `/login` 路径查看登录页面，表单验证功能已经完整实现，可以直接使用。后续可以根据实际需求接入真实的登录接口。
...

已修复登录页面的问题：

1. 修复了 `ElMessage` 未导入的错误
- 从 `element-plus` 中导入了 `ElMessage` 组件
- 由于使用了自动导入插件，其他 Element Plus 组件（如 `el-form`、`el-input` 等）会自动导入

登录页面现在可以正常工作，包含以下功能：

1. 表单验证
- 邮箱/手机号码格式验证
- 密码复杂度验证
- 实时密码强度显示

2. 用户体验
- 表单项动画效果
- 错误提示信息
- 登录成功提示

3. 页面布局
- 左右分栏设计
- Logo 动画效果
- 响应式交互

可以通过访问 `/login` 路径使用登录功能。
```

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
import { ElMessage } from 'element-plus'
import { computed, ref } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()

const form = ref({
  account: '',
  password: ''
})

const rules = {
  account: [
    { required: true, message: '请输入邮箱/手机号码', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const emailRegex = /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/
        const phoneRegex = /^1[3-9]\d{9}$/
        if (!emailRegex.test(value) && !phoneRegex.test(value)) {
          callback(new Error('请输入正确的邮箱或手机号码'))
        }
        else {
          callback()
        }
      },
      trigger: 'blur'
    }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 16, message: '密码长度在 6 到 16 个字符之间', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const hasUpperCase = /[A-Z]/.test(value)
        const hasLowerCase = /[a-z]/.test(value)
        const hasNumber = /\d/.test(value)
        const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(value)

        if (!hasUpperCase) {
          callback(new Error('密码必须包含大写字母'))
          return
        }

        let strength = 0
        if (hasUpperCase)
          strength++
        if (hasLowerCase)
          strength++
        if (hasNumber)
          strength++
        if (hasSpecial)
          strength++

        passwordStrength.value = strength
        callback()
      },
      trigger: 'blur'
    }
  ]
}

const formRef = ref()
const passwordStrength = ref(0)

const strengthText = computed(() => {
  switch (passwordStrength.value) {
    case 1:
      return { text: '弱', color: '#F56C6C' }
    case 2:
      return { text: '中', color: '#E6A23C' }
    case 3:
    case 4:
      return { text: '强', color: '#67C23A' }
    default:
      return { text: '', color: '' }
  }
})

const loading = ref(false)

async function handleLogin() {
  if (!formRef.value)
    return

  try {
    await formRef.value.validate()
    loading.value = true

    // 模拟登录请求
    await new Promise(resolve => setTimeout(resolve, 1000))

    // 实际项目中这里应该调用真实的登录接口
    // const res = await fetch('/api/login', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify(form.value)
    // })
    // const data = await res.json()

    ElMessage.success('登录成功')
    router.push('/')
  }
  catch (error) {
    console.error('登录失败:', error)
  }
  finally {
    loading.value = false
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-content">
      <div class="login-banner">
        <img src="@/assets/vue.svg" alt="banner">
      </div>
      <div class="login-form">
        <h2>欢迎登录</h2>
        <el-form
          ref="formRef"
          :model="form"
          :rules="rules"
          label-position="top"
          @keyup.enter="handleLogin"
        >
          <el-form-item label="账号" prop="account">
            <el-input
              v-model="form.account"
              placeholder="请输入邮箱/手机号码"
              clearable
            />
          </el-form-item>

          <el-form-item label="密码" prop="password">
            <el-input
              v-model="form.password"
              type="password"
              placeholder="请输入密码"
              show-password
              clearable
            />
            <div v-if="strengthText.text" class="password-strength">
              密码强度：
              <span :style="{ color: strengthText.color }">
                {{ strengthText.text }}
              </span>
            </div>
          </el-form-item>

          <el-form-item>
            <el-button
              type="primary"
              :loading="loading"
              class="login-button"
              @click="handleLogin"
            >
              登录
            </el-button>
          </el-form-item>
        </el-form>
      </div>
    </div>
  </div>
</template>

<style scoped>
.login-container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f5f7fa;
}

.login-content {
  display: flex;
  width: 900px;
  height: 500px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.login-banner {
  flex: 1;
  background-color: #409eff;
  display: flex;
  align-items: center;
  justify-content: center;
}

.login-banner img {
  width: 200px;
  height: 200px;
  animation: float 3s ease-in-out infinite;
}

.login-form {
  flex: 1;
  padding: 16px;
  display: flex;
  flex-direction: column;
}

.login-form h2 {
  text-align: center;
  margin-bottom: 24px;
  color: #303133;
}

.login-button {
  width: 100%;
  margin-top: 16px;
}

.password-strength {
  font-size: 12px;
  margin-top: 4px;
  color: #606266;
}

@keyframes float {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-20px);
  }
}

/* 过渡动画 */
.el-form-item {
  transition: all 0.3s ease-in-out;
}

.el-input {
  transition: all 0.3s ease-in-out;
}

.el-input:focus-within {
  transform: translateY(-2px);
}
</style>
```

:::

预览：

![how to write a good ai prompt](/images/ai/how-prompt-1.png)

![how to write a good ai prompt](/images/ai/how-prompt-2.png)

看起来不错，基本实现了我们所描述的功能。

正如前面所说，越明确的需求文档，AI 生成的结果就越符合预期。
可以总结下来，编写需求文档，我们应该注意以下几点：

* **明确的技术栈**： 告诉 AI 它能使用的技术栈，划定好范围。
* **功能清单**： 列出你的需求，并描述清楚细节
* **布局和交互**：描述清楚页面布局，每个区域的内容以及排版，最好具体到像素级。
* **边界限制**：告诉 AI 只应该做什么，或者不要去处理哪些内容，或者不要做什么。

## 追加改进

事实上上面生成的代码依然存在不少问题：

* API 接口并没有实现接入
* 需要补充 忘记密码 的跳转链接
* 登录的图形验证码校验
* 密码的强中弱应该的输入过程中实时提示
* ...

为什么 API 接口的接入被注释了？因为 AI 并不知道 接口 应该如何传递参数，也不知道接口返回的数据格式是什么。

我们继续告诉 AI 需求改进的内容：

```txt
- 登录接口为 `/api/login`
  - 请求方法为 POST
  - 入参为 `username` 、 `password`、 `captcha`
  - 响应体格式为 `{ message: string, code: number }`，`code` 为 0 表示成功，为 1 表示失败，`message` 为失败原因
- 需要补充 忘记密码 的跳转链接，路径为 `/forget-password`
- 登录的图形验证码校验
  - 图形验证码的接口为 `/api/captcha`，请求方法为 GET，响应体格式为 `{ code: string, image: string }`，`code` 为图形验证码的 id，`image` 为图形验证码的 base64 编码
- 密码的强中弱应该的输入过程中实时提示
  - 使用三个格子的信号灯作为提示，一个格式时为弱，两个为中，三个为强，并显示为对应的颜色
  - 切换时使用动画
```

AI 会根据这些需求改进，然后再次生成代码：

::: code-tabs

@tab AI Chat

```txt :collapsed-lines
让我们查看登录页面组件，以添加图形验证码、密码强度实时提示和忘记密码链接功能。
...

更新登录页面组件，添加图形验证码、密码强度实时提示和忘记密码链接。
...

修复登录成功消息重复显示的问题。
...

添加验证码相关的表单验证规则，并在组件挂载时获取验证码。
...

让我们查看更新后的登录页面效果。

预览

已完成所有功能的开发和优化，主要更新包括：

1. 登录功能增强
- 添加图形验证码功能
  - 自动获取验证码
  - 点击图片可刷新验证码
  - 验证码校验规则
- 优化密码强度提示
  - 使用三格信号灯样式
  - 实时显示密码强度（弱、中、强）
  - 添加渐变动画效果
- 完善表单验证
  - 邮箱/手机号格式验证
  - 密码复杂度验证
  - 验证码必填验证

2. 新增忘记密码功能
- 创建忘记密码页面
- 邮箱验证码登录
- 倒计时重发验证码
- 表单验证和错误提示
- 优雅的过渡动画

3. 接口对接
- 登录接口（/api/login）
  - 用户名、密码、验证码校验
  - 登录状态保存
  - 成功/失败提示
- 验证码接口（/api/captcha）
  - 自动获取和刷新
  - base64 图片显示

4. 用户体验优化
- 添加路由跳转动画
- 优化表单交互动画
- 统一的错误提示
- 友好的加载状态
- 键盘回车提交支持

现在可以通过访问以下路径使用相关功能：
- 登录页面：`/login`
- 忘记密码：`/forget-password`

```

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
import { ElMessage } from 'element-plus'
import { computed, onMounted, ref } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()

const form = ref({
  username: '',
  password: '',
  captcha: ''
})

// 获取验证码
const captchaCode = ref('')
const captchaImage = ref('')

async function refreshCaptcha() {
  try {
    const res = await fetch('/api/captcha')
    const data = await res.json()
    captchaCode.value = data.code
    captchaImage.value = data.image
  }
  catch (error) {
    console.error('获取验证码失败:', error)
  }
}

// 监听密码变化实时更新强度
function updatePasswordStrength(value: string) {
  const hasUpperCase = /[A-Z]/.test(value)
  const hasLowerCase = /[a-z]/.test(value)
  const hasNumber = /\d/.test(value)
  const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(value)

  let strength = 0
  if (hasUpperCase)
    strength++
  if (hasLowerCase)
    strength++
  if (hasNumber)
    strength++
  if (hasSpecial)
    strength++

  passwordStrength.value = strength
}

// 组件挂载时获取验证码
onMounted(() => {
  refreshCaptcha()
})

const rules = {
  username: [
    { required: true, message: '请输入邮箱/手机号码', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const emailRegex = /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/
        const phoneRegex = /^1[3-9]\d{9}$/
        if (!emailRegex.test(value) && !phoneRegex.test(value)) {
          callback(new Error('请输入正确的邮箱或手机号码'))
        }
        else {
          callback()
        }
      },
      trigger: 'blur'
    }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 16, message: '密码长度在 6 到 16 个字符之间', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const hasUpperCase = /[A-Z]/.test(value)
        const hasLowerCase = /[a-z]/.test(value)
        const hasNumber = /\d/.test(value)
        const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(value)

        if (!hasUpperCase) {
          callback(new Error('密码必须包含大写字母'))
          return
        }

        let strength = 0
        if (hasUpperCase)
          strength++
        if (hasLowerCase)
          strength++
        if (hasNumber)
          strength++
        if (hasSpecial)
          strength++

        passwordStrength.value = strength
        callback()
      },
      trigger: 'blur'
    }
  ],
  captcha: [
    { required: true, message: '请输入验证码', trigger: 'blur' },
    { min: 4, max: 4, message: '验证码长度为4位', trigger: 'blur' }
  ]
}

const formRef = ref()
const passwordStrength = ref(0)

const strengthText = computed(() => {
  switch (passwordStrength.value) {
    case 1:
      return { text: '弱', color: '#F56C6C' }
    case 2:
      return { text: '中', color: '#E6A23C' }
    case 3:
    case 4:
      return { text: '强', color: '#67C23A' }
    default:
      return { text: '', color: '' }
  }
})

const loading = ref(false)

async function handleLogin() {
  if (!formRef.value)
    return

  try {
    await formRef.value.validate()
    loading.value = true

    const res = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...form.value,
        code: captchaCode.value
      })
    })
    const data = await res.json()

    if (data.code === 0) {
      ElMessage.success('登录成功')
      localStorage.setItem('isLoggedIn', 'true')
      router.push('/')
    }
    else {
      ElMessage.error(data.message)
      refreshCaptcha()
    }
    router.push('/')
  }
  catch (error) {
    console.error('登录失败:', error)
  }
  finally {
    loading.value = false
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-content">
      <div class="login-banner">
        <img src="@/assets/vue.svg" alt="banner">
      </div>
      <div class="login-form">
        <h2>欢迎登录</h2>
        <el-form
          ref="formRef"
          :model="form"
          :rules="rules"
          label-position="top"
          @keyup.enter="handleLogin"
        >
          <el-form-item label="账号" prop="username">
            <el-input
              v-model="form.username"
              placeholder="请输入邮箱/手机号码"
              clearable
              @keyup.enter="handleLogin"
            />
          </el-form-item>

          <el-form-item label="密码" prop="password">
            <el-input
              v-model="form.password"
              type="password"
              placeholder="请输入密码"
              show-password
              clearable
              @input="updatePasswordStrength"
              @keyup.enter="handleLogin"
            />
            <div class="password-strength-indicator">
              <div
                v-for="n in 3"
                :key="n"
                class="strength-bar"
                :class="{
                  active: passwordStrength >= n,
                  weak: passwordStrength === 1 && n === 1,
                  medium: passwordStrength === 2 && n <= 2,
                  strong: passwordStrength >= 3 && n <= 3,
                }"
              />
              <span v-if="strengthText.text" :style="{ color: strengthText.color }">
                {{ strengthText.text }}
              </span>
            </div>
          </el-form-item>

          <el-form-item label="验证码" prop="captcha">
            <div class="captcha-container">
              <el-input
                v-model="form.captcha"
                placeholder="请输入验证码"
                @keyup.enter="handleLogin"
              />
              <img
                v-if="captchaImage"
                :src="captchaImage"
                class="captcha-image"
                alt="验证码"
                @click="refreshCaptcha"
              >
            </div>
          </el-form-item>

          <el-form-item>
            <el-button
              type="primary"
              :loading="loading"
              class="login-button"
              @click="handleLogin"
            >
              登录
            </el-button>
            <div class="form-footer">
              <router-link to="/forget-password" class="forget-password">
                忘记密码？
              </router-link>
            </div>
          </el-form-item>
        </el-form>
      </div>
    </div>
  </div>
</template>

<style scoped>
.login-container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f5f7fa;
}

.login-content {
  display: flex;
  width: 900px;
  height: 500px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.login-banner {
  flex: 1;
  background-color: #409eff;
  display: flex;
  align-items: center;
  justify-content: center;
}

.login-banner img {
  width: 200px;
  height: 200px;
  animation: float 3s ease-in-out infinite;
}

.login-form {
  flex: 1;
  padding: 16px;
  display: flex;
  flex-direction: column;
}

.login-form h2 {
  text-align: center;
  margin-bottom: 24px;
  color: #303133;
}

.login-button {
  width: 100%;
  margin-top: 16px;
}

.password-strength-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.strength-bar {
  flex: 1;
  width: 32px;
  height: 4px;
  background-color: #e4e7ed;
  border-radius: 2px;
  transition: all 0.3s ease;
}

.strength-bar.active {
  background-color: #67C23A;
}

.strength-bar.weak {
  background-color: #F56C6C;
}

.strength-bar.medium {
  background-color: #E6A23C;
}

.strength-bar.strong {
  background-color: #67C23A;
}

.captcha-container {
  display: flex;
  gap: 12px;
}

.captcha-image {
  height: 32px;
  border-radius: 4px;
  cursor: pointer;
}

.form-footer {
  margin-top: 16px;
  text-align: right;
}

.forget-password {
  color: var(--el-color-primary);
  text-decoration: none;
  font-size: 14px;
}

.forget-password:hover {
  color: var(--el-color-primary-light-3);
}

@keyframes float {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-20px);
  }
}

/* 过渡动画 */
.el-form-item {
  transition: all 0.3s ease-in-out;
}

.el-input {
  transition: all 0.3s ease-in-out;
}

.el-input:focus-within {
  transform: translateY(-2px);
}
</style>
```

:::

效果：

![how-to-write-good-ai-prompt-3](/images/ai/how-prompt-3.png)

喔，又发现了新的问题，密码强度提示应该在密码大于 6 位数之后再提示。先记录下来，验证其他流程，
再统一追加改进。

还有别忘了 `Login.vue` 随着修改，体积已经相对较大，太多功能耦合在一起，需要告诉 AI 进行拆分。

```txt
- 密码强度提示应该在密码大于 6 位数之后再开始提示
- 对 Login.vue 进行合理的拆分
```

AI：

```txt
...
```

最终，我们得到了以下的产物：

::: code-tabs

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
import { ElMessage } from 'element-plus'
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import CaptchaInput from '@/components/CaptchaInput.vue'
import PasswordStrength from '@/components/PasswordStrength.vue'
import { calculatePasswordStrength, loginRules } from '@/utils/validation'

const router = useRouter()

const form = ref({
  username: '',
  password: '',
  captcha: ''
})

const formRef = ref()
const loading = ref(false)
const passwordStrength = ref(0)
const captchaCode = ref('')

function updatePasswordStrength(value: string) {
  passwordStrength.value = calculatePasswordStrength(value)
}

function handleCaptchaRefresh(code: string) {
  captchaCode.value = code
}

async function handleLogin() {
  if (!formRef.value)
    return

  try {
    await formRef.value.validate()
    loading.value = true

    const res = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...form.value,
        code: captchaCode.value
      })
    })
    const data = await res.json()

    if (data.code === 0) {
      ElMessage.success('登录成功')
      localStorage.setItem('isLoggedIn', 'true')
      router.push('/')
    }
    else {
      ElMessage.error(data.message)
    }
  }
  catch (error) {
    console.error('登录失败:', error)
  }
  finally {
    loading.value = false
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-content">
      <div class="login-banner">
        <img src="@/assets/vue.svg" alt="banner">
      </div>
      <div class="login-form">
        <h2>欢迎登录</h2>
        <el-form
          ref="formRef"
          :model="form"
          :rules="loginRules"
          label-position="top"
          @keyup.enter="handleLogin"
        >
          <el-form-item label="账号" prop="username">
            <el-input
              v-model="form.username"
              placeholder="请输入邮箱/手机号码"
              clearable
              @keyup.enter="handleLogin"
            />
          </el-form-item>

          <el-form-item label="密码" prop="password">
            <el-input
              v-model="form.password"
              type="password"
              placeholder="请输入密码"
              show-password
              clearable
              @input="updatePasswordStrength"
              @keyup.enter="handleLogin"
            />
            <PasswordStrength :strength="passwordStrength" :password="form.password" />
          </el-form-item>

          <el-form-item label="验证码" prop="captcha">
            <CaptchaInput
              v-model="form.captcha"
              @refresh="handleCaptchaRefresh"
              @enter="handleLogin"
            />
          </el-form-item>

          <el-form-item>
            <el-button
              type="primary"
              :loading="loading"
              class="login-button"
              @click="handleLogin"
            >
              登录
            </el-button>
            <div class="form-footer">
              <router-link to="/forget-password" class="forget-password">
                忘记密码？
              </router-link>
            </div>
          </el-form-item>
        </el-form>
      </div>
    </div>
  </div>
</template>

<style scoped>
.login-container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f5f7fa;
}

.login-content {
  display: flex;
  width: 900px;
  height: 500px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.login-banner {
  flex: 1;
  background-color: #409eff;
  display: flex;
  align-items: center;
  justify-content: center;
}

.login-banner img {
  width: 200px;
  height: 200px;
  animation: float 3s ease-in-out infinite;
}

.login-form {
  flex: 1;
  padding: 16px;
  display: flex;
  flex-direction: column;
}

.login-form h2 {
  text-align: center;
  margin-bottom: 24px;
  color: #303133;
}

.login-button {
  width: 100%;
  margin-top: 16px;
}

.form-footer {
  margin-top: 16px;
  text-align: right;
}

.forget-password {
  color: var(--el-color-primary);
  text-decoration: none;
  font-size: 14px;
}

.forget-password:hover {
  color: var(--el-color-primary-light-3);
}

@keyframes float {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-20px);
  }
}

/* 过渡动画 */
.el-form-item {
  transition: all 0.3s ease-in-out;
}

.el-input {
  transition: all 0.3s ease-in-out;
}

.el-input:focus-within {
  transform: translateY(-2px);
}
</style>
```

@tab CaptchaInput.vue

```vue :collapsed-lines
<script setup lang="ts">
import { onMounted, ref } from 'vue'

defineProps<{
  modelValue: string
}>()

const emit = defineEmits<{
  'update:modelValue': [value: string]
  'refresh': [code: string]
  'enter': []
}>()

const captchaCode = ref('')
const captchaImage = ref('')

async function refreshCaptcha() {
  try {
    const res = await fetch('/api/captcha')
    const data = await res.json()
    captchaCode.value = data.code
    captchaImage.value = data.image
    emit('refresh', data.code)
  }
  catch (error) {
    console.error('获取验证码失败:', error)
  }
}

onMounted(() => {
  refreshCaptcha()
})
</script>

<template>
  <div class="captcha-container">
    <el-input
      :model-value="modelValue"
      placeholder="请输入验证码"
      @update:model-value="(newValue: string) => emit('update:modelValue', newValue)"
      @keyup.enter="$emit('enter')"
    />
    <img
      v-if="captchaImage"
      :src="captchaImage"
      class="captcha-image"
      alt="验证码"
      @click="refreshCaptcha"
    >
  </div>
</template>

<style scoped>
.captcha-container {
  display: flex;
  gap: 12px;
}

.captcha-image {
  height: 32px;
  border-radius: 4px;
  cursor: pointer;
}
</style>
```

@tab PasswordStrength.vue

```vue :collapsed-lines
<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  strength: number
  password: string
}>()

const showStrength = computed(() => props.password.length >= 6)

const strengthText = computed(() => {
  switch (props.strength) {
    case 1:
      return { text: '弱', color: '#F56C6C' }
    case 2:
      return { text: '中', color: '#E6A23C' }
    case 3:
    case 4:
      return { text: '强', color: '#67C23A' }
    default:
      return { text: '', color: '' }
  }
})
</script>

<template>
  <div v-if="showStrength" class="password-strength-indicator">
    <div
      v-for="n in 3"
      :key="n"
      class="strength-bar"
      :class="{
        active: strength >= n,
        weak: strength === 1 && n === 1,
        medium: strength === 2 && n <= 2,
        strong: strength >= 3 && n <= 3,
      }"
    />
    <span v-if="strengthText.text" :style="{ color: strengthText.color }">
      {{ strengthText.text }}
    </span>
  </div>
</template>

<style scoped>
.password-strength-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.strength-bar {
  flex: 1;
  width: 32px;
  height: 4px;
  background-color: #e4e7ed;
  border-radius: 2px;
  transition: all 0.3s ease;
}

.strength-bar.active {
  background-color: #67C23A;
}

.strength-bar.weak {
  background-color: #F56C6C;
}

.strength-bar.medium {
  background-color: #E6A23C;
}

.strength-bar.strong {
  background-color: #67C23A;
}
</style>
```

@tab utils/validation.ts

```ts :collapsed-lines
// 密码强度计算
export function calculatePasswordStrength(password: string): number {
  const hasUpperCase = /[A-Z]/.test(password)
  const hasLowerCase = /[a-z]/.test(password)
  const hasNumber = /\d/.test(password)
  const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password)

  let strength = 0
  if (hasUpperCase)
    strength++
  if (hasLowerCase)
    strength++
  if (hasNumber)
    strength++
  if (hasSpecial)
    strength++

  return strength
}

// 表单验证规则
export const loginRules = {
  username: [
    { required: true, message: '请输入邮箱/手机号码', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const emailRegex = /^[\w-]+([\.[\w-]+)*@[\w-]+([\.[\w-]+)+$/
        const phoneRegex = /^1[3-9]\d{9}$/
        if (!emailRegex.test(value) && !phoneRegex.test(value)) {
          callback(new Error('请输入正确的邮箱或手机号码'))
        }
        else {
          callback()
        }
      },
      trigger: 'blur'
    }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 16, message: '密码长度在 6 到 16 个字符之间', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const hasUpperCase = /[A-Z]/.test(value)
        if (!hasUpperCase) {
          callback(new Error('密码必须包含大写字母'))
          return
        }
        callback()
      },
      trigger: 'blur'
    }
  ],
  captcha: [
    { required: true, message: '请输入验证码', trigger: 'blur' },
    { min: 4, max: 4, message: '验证码长度为4位', trigger: 'blur' }
  ]
}
```

:::

在这次的 登录页的开发过程中，我们向 AI 进行了三轮对话：

* 第一次提出了明确的需求文档；
* 对生成的代码进行审查，验证 UI 和交互，进行第一次的追加改进；
* 对改进结果继续审查，进行第二次追加改进。
* 对结果继续审查，基本满足预期的诉求。

我并不是在说只能进行三轮对话。每一轮对话都是有成本的，你需要对每次生成的内容进行审查和验证，这是时间成本，
AI 需求重新查看文件并进行追加修改，这也是时间成本。

因此，每次追加改进应先整理好新的需求文档，避免发现一个就告诉 AI 修改一个。

## 总结

* **明确的技术栈**： 告诉 AI 它能使用的技术栈，划定好范围。
* **功能清单**： 列出你的需求，并描述清楚细节。
* **布局和交互**：描述清楚页面布局，每个区域的内容以及排版，最好具体到像素级。
* **边界限制**：告诉 AI 只应该做什么，或者不要去处理哪些内容，或者不要做什么。
* **追加改进**：每次改进都应该是一个新的完整的需求文档。

不妨实施这个需求文档模板：

```md
### 技术栈
- ...

### 功能清单
- 功能 1
- 功能 2
- ...

### 布局和交互
- ...

### 边界限制
- ...

### 注意事项
- ...
```

---

---
url: /czxBlog/article/ou7gebop/index.md
---
# Typescript 内置类型
TypeScript 提供了许多内置的类型方法和工具类型，用于处理和操作类型。以下是其中一些常用的内置类型方法：

## 分类

### Utility Types（工具类型）

* `Partial<T>` : 将类型 T 的所有属性变为可选。
* `Required<T>` : 将类型 T 的所有属性变为必选。
* `Readonly<T>` : 将类型 T 的所有属性变为只读。
* `Record<K, T>` : 创建一个具有指定键类型 K 和值类型 T 的新对象类型。
* `Pick<T, K>` : 从类型 T 中选择指定属性 K 形成新类型。
* `Omit<T, K>` : 从类型 T 中排除指定属性 K 形成新类型。
* `Exclude<T, U>` : 从类型 T 中排除可以赋值给类型 U 的类型。
* `Extract<T, U>` : 从类型 T 中提取可以赋值给类型 U 的类型。
* `NonNullable<T>` : 从类型 T 中排除 null 和 undefined 类型。
* `ReturnType<T>` : 获取函数类型 T 的返回类型。
* `Parameters<T>` : 获取函数类型 T 的参数类型组成的元组类型。
* `Awaited<T>`: 模拟 `async` 函数中的 `await` 操作，或者 `promise` 上的 `.then()` 方法。
* `ConstructorParameters<T>`: 获取构造函数类型 T 的参数类型组成的元组类型。
* `InstanceType<T>`: 获取构造函数类型 T 的实例类型。
* `ThisParameterType<T>`: 获取函数类型 T 的 `this` 类型。
* `OmitThisParameter<T>`: 从函数类型 T 中移除 `this` 类型。
* `ThisType<T>`: 获取函数类型 T 的 `this` 类型。

### 条件判定类型

* `Conditional Types（条件类型）`: 根据类型关系进行条件判断生成不同的类型。
* `Distribute Conditional Types（分布式条件类型）`: 分发条件类型，允许条件类型在联合类型上进行分发。

### Mapped Types（映射类型）

根据已有类型创建新类型，通过映射类型可以生成新的类型结构。

### Template Literal Types（模板文字类型）

使用字符串模板创建新类型。

### 类型推断关键字

* `typeof`: 关键字允许在条件类型中推断类型变量。
* `keyof`：关键字允许在泛型条件类型中推断类型变量。
* `instanceof`：运算符用于检查对象是否是特定类的实例。
* `in`：用于检查对象是否具有特定属性。
* `type guard`：类型守卫是自定义的函数或条件语句，用于在代码块内缩小变量的类型范围。
* `as`：用于类型断言，允许将一个变量断言为特定的类型。

## Utility Types

### Partial\<T>

构造一个将 `T` 的所有属性设置为可选的类型。

```ts twoslash
interface Todo {
  title: string
  description: string
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
  return { ...todo, ...fieldsToUpdate }
}

const todo1 = {
  title: 'organize desk',
  description: 'clear clutter',
}

const todo2 = updateTodo(todo1, {
  description: 'throw out trash',
})

//
```

### Required\<T>

该类型将类型 `T` 的所有属性变为必选。

```ts twoslash
// @errors: 2741
interface Props {
  a?: number
  b?: string
}
const obj: Props = { a: 5 }
const obj2: Required<Props> = { a: 5 }
```

### Readonly\<T>

将类型 `T` 的所有属性变为只读。

```ts twoslash
// @errors: 2540
interface Todo {
  title: string
}
const todo: Readonly<Todo> = {
  title: 'Delete inactive users',
}
todo.title = 'Hello'
```

### Record\<K, T>

创建一个具有指定键类型 K 和值类型 T 的新对象类型。

```ts twoslash
interface CatInfo {
  age: number
  breed: string
}
type CatName = 'miffy' | 'boris' | 'mordred'

const cats: Record<CatName, CatInfo> = {
  miffy: { age: 10, breed: 'Persian' },
  boris: { age: 5, breed: 'Maine Coon' },
  mordred: { age: 16, breed: 'British Shorthair' },
}

cats.boris
//    ^?
//
```

### Pick\<T, K>

从类型 T 中选择指定属性 K 形成新类型。

```ts twoslash
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = Pick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false,
}

todo
// ^?
//
```

### Omit\<T, K>

与 Pick 相反，该类型从类型 T 中排除指定属性 K 形成新类型。

```ts twoslash
interface Todo {
  title: string
  description: string
  completed: boolean
  createdAt: number
}

type TodoPreview = Omit<Todo, 'description'>

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false,
  createdAt: 1615544252770,
}

todo
// ^?

type TodoInfo = Omit<Todo, 'completed' | 'createdAt'>

const todoInfo: TodoInfo = {
  title: 'Pick up kids',
  description: 'Kindergarten closes at 5pm',
}

todoInfo
// ^?
//
```

### Exclude\<T, U>

从类型 T 中排除可以赋值给类型 U 的类型。

```ts twoslash
type T0 = Exclude<'a' | 'b' | 'c', 'a'>
//   ^?

type T1 = Exclude<'a' | 'b' | 'c', 'a' | 'b'>
//   ^?

type T2 = Exclude<string | number | (() => void), Function>
//   ^?

type Shape =
  | { kind: 'circle', radius: number }
  | { kind: 'square', x: number }
  | { kind: 'triangle', x: number, y: number }

type T3 = Exclude<Shape, { kind: 'circle' }>
//   ^?

//
```

### Extract\<T, U>

从类型 T 中提取可以赋值给类型 U 的类型。

```ts twoslash
type T0 = Extract<'a' | 'b' | 'c', 'a' | 'f'>
//   ^?

type T1 = Extract<string | number | (() => void), Function>
//   ^?

type Shape =
  | { kind: 'circle', radius: number }
  | { kind: 'square', x: number }
  | { kind: 'triangle', x: number, y: number }

type T2 = Extract<Shape, { kind: 'circle' }>
//   ^?

//
```

### NonNullable\<T>

从类型 T 中排除 null 和 undefined 类型。

```ts twoslash
type T0 = NonNullable<string | number | undefined>
//   ^?

type T1 = NonNullable<string[] | null | undefined>
//   ^?

//
```

### ReturnType\<T>

获取函数类型 T 的返回类型。

```ts twoslash
// @errors: 2344
declare function f1(): { a: number, b: string }

type T0 = ReturnType<() => string>
//   ^?

type T1 = ReturnType<(s: string) => void>
//   ^?

type T2 = ReturnType<<T>() => T>
//   ^?

type T3 = ReturnType<<T extends U, U extends number[]>() => T>
//   ^?

type T4 = ReturnType<typeof f1>
//   ^?

type T5 = ReturnType<any>
//   ^?

type T6 = ReturnType<never>
//   ^?

type T7 = ReturnType<string>

type T8 = ReturnType<Function>
```

### Parameters\<T>

获取函数类型 T 的参数类型组成的元组类型。

```ts twoslash
// @errors: 2344
declare function f1(arg: { a: number, b: string }): void

type T0 = Parameters<() => string>
//   ^?

type T1 = Parameters<(s: string) => void>
//   ^?

type T2 = Parameters<<T>(arg: T) => T>
//   ^?

type T3 = Parameters<typeof f1>
//   ^?

type T4 = Parameters<any>
//   ^?

type T5 = Parameters<never>
//   ^?

type T6 = Parameters<string>

type T7 = Parameters<Function>
```

### Awaited\<T>

模拟 `async` 函数中的 `await` 操作，或者 `promise` 上的 `.then()` 方法。

```ts twoslash
type A = Awaited<Promise<string>>
//   ^?

type B = Awaited<Promise<Promise<number>>>
//   ^?

type C = Awaited<boolean | Promise<number>>
//   ^?

//
```

### ConstructorParameters\<T>

获取构造函数类型 T 的参数类型组成的元组类型。

```ts twoslash
// @errors: 2344
type T0 = ConstructorParameters<ErrorConstructor>
//   ^?

type T1 = ConstructorParameters<FunctionConstructor>
//   ^?

type T2 = ConstructorParameters<RegExpConstructor>
//   ^?

class C {
  constructor(a: number, b: string) {}
}
type T3 = ConstructorParameters<typeof C>
//   ^?

type T4 = ConstructorParameters<any>
//   ^?

type T5 = ConstructorParameters<Function>
```

### InstanceType\<T>

获取构造函数类型 T 的实例类型。

```ts twoslash
// @errors: 2344
class C {
  x = 0
  y = 0
}

type T0 = InstanceType<typeof C>
//   ^?

type T1 = InstanceType<any>
//   ^?

type T2 = InstanceType<never>
//   ^?

type T3 = InstanceType<string>

type T4 = InstanceType<Function>
```

### ThisParameterType\<T>

获取函数类型 T 的 `this` 类型。

```ts twoslash
function toHex(this: number) {
  return this.toString(16)
}

function numberToString(n: ThisParameterType<typeof toHex>) {
  return toHex.apply(n)
}
```

### OmitThisParameter\<T>

从函数类型 T 中移除 `this` 类型。

```ts twoslash
function toHex(this: number) {
  return this.toString(16)
}

const fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5)

console.log(fiveToHex())

//
```

### ThisType\<T>

获取函数类型 T 的 `this` 类型。

```ts twoslash
interface ObjectDescriptor<D, M> {
  data?: D
  methods?: M & ThisType<D & M> // Type of 'this' in methods is D & M
}

function makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {
  let data: object = desc.data || {}
  let methods: object = desc.methods || {}
  return { ...data, ...methods } as D & M
}

let obj = makeObject({
  data: { x: 0, y: 0 },
  methods: {
    moveBy(dx: number, dy: number) {
      this.x += dx // Strongly typed this
      this.y += dy // Strongly typed this
    },
  },
})

obj.x = 10
obj.y = 20
obj.moveBy(5, 5)

//
```

## 条件判定类型

条件类型是 `TypeScript` 中强大且灵活的类型构造方式，它允许根据类型关系进行条件判断生成不同的类型。
分布式条件类型是条件类型的一种特殊形式，它允许条件类型在联合类型上进行分发，以便更精确地推断和处理类型。

### Conditional Types（条件类型）

条件类型基于输入的类型关系来确定最终的类型。它使用 `infer` 关键字来推断和定义类型。
条件类型通常结合了 `TypeScript` 中的 `extends` 关键字，这样就可以根据条件来确定最终的类型。

#### 根据输入类型选择不同的类型

条件类型基于输入的类型关系来确定最终的类型。它使用 `infer` 关键字来推断和定义类型。
条件类型通常结合了 `TypeScript` 中的 `extends` 关键字，这样就可以根据条件来确定最终的类型。

示例：

```ts twoslash
type TypeName<T> = T extends string ? 'string' : T extends number ? 'number' : T extends boolean ? 'boolean' : 'other'

type A = TypeName<string>
//   ^?

type B = TypeName<number>
//   ^?

type C = TypeName<boolean>
//   ^?

type D = TypeName<object>
//   ^?

type E = TypeName<string | number>
//   ^?

//
```

在这个例子中，`TypeName<T>` 条件类型根据传入的类型 T 来确定最终返回的类型字符串。如果 T 是 `string`、`number` 或 `boolean` 类型，则返回对应的类型字符串，否则返回 `'other'`。

### 条件类型中使用 `infer` 关键字

`infer` 关键字通常与extends结合使用，用于在条件类型内部声明一个类型变量，并从中提取或推断出一个类型。
它允许我们在泛型条件类型中推断出待推断类型的部分。

具体左右有以下两点：

1. TypeScript 支持 infer 来提取类型的一部分，通过模式匹配的方式。

示例：

```ts twoslash
type ExtractReturnType<T> = T extends (...args: any[]) => infer R ? R : never

function greet(): string {
  return 'Hello!'
}

type GreetReturnType = ExtractReturnType<typeof greet>
//     ^?
//
```

这个例子中的 `ExtractReturnType<T>` 条件类型获取函数类型 `T` 的返回类型。它使用了 `infer` 关键字来推断函数的返回类型，如果 `T` 是一个函数类型，则返回其返回类型，否则返回 `never`。

2. `infer extends` 用来做类型转换，比如 `string` 转 `number`、转 `boolean` 等；

```ts twoslash
enum Code {
  a = 111,
  b = 222,
  c = 'ccc',
}

type StrToNum<Str> = Str extends `${infer Num extends number}` ? Num : Str

type res = StrToNum<`${Code}`>
//    ^?
//
```

3. 条件类型配合泛型使用

```ts twoslash
type Diff<T, U> = T extends U ? never : T

type FilterOut<T, U> = T extends any ? Diff<T, U> : never

type Result = FilterOut<'a' | 'b' | 'c' | 'd', 'a' | 'c'>
//    ^?
//
```

在这个例子中，`FilterOut<T, U>` 条件类型根据传入的两个联合类型 T 和 U，从 T 中过滤掉属于 U 类型的成员，
返回剩余的类型。通过 `Diff<T, U>` 辅助实现了这个操作。这种方式可以在处理类型时非常有用，比如过滤掉某些特定类型。

### Distributive Conditional Types（分布式条件类型）

分布式条件类型是条件类型的一种特殊形式，它在联合类型上进行推断和分发，并返回联合类型中每个成员的条件类型。

```ts twoslash
type ToArray<T> = T extends any ? T[] : never

type StrArray = ToArray<string>
//    ^?

type NumArray = ToArray<number>
//    ^?

type UnionArray = ToArray<string | number>
//    ^?
//
```

在这个例子中，`ToArray<T>` 条件类型以联合类型 T 为输入，并将其分发到联合类型的每个成员上，返回一个数组类型。
这种分布式行为使得条件类型在处理联合类型时更加灵活和强大。

条件类型和分布式条件类型为 TypeScript 中的类型系统增加了极大的灵活性和表达能力，
允许开发者根据复杂的类型关系来定义和推断类型。

## Mapped Types（映射类型）

`映射类型（Mapped Types）` 是 TypeScript 中一种强大的类型操作，它允许你通过已有类型来创建新类型，
通常通过映射现有类型的属性、方法或者创建新的属性来实现。

常见的映射类型是利用 `keyof` 关键字配合索引类型来生成新的类型。一个经典的例子是 `Partial<T>` 类型。它接受一个类型 T 并将所有属性设置为可选的：

```ts twoslash
type MyPartial<T> = {
  [P in keyof T]?: T[P]
}

interface User {
  name: string
  age: number
}

type PartialUser = MyPartial<User>
//    ^?

//
```

在这个例子中，`Partial<T>` 使用了映射类型，通过遍历 T 类型的所有属性（由 `keyof T` 获取），
创建了一个新类型，该类型包含了原类型 T 的所有属性，并将它们设为可选的。

除了 `Partial`，还有一些其他常见的映射类型：

* `Readonly<T>`：将类型 T 中所有属性设置为只读。
* `Pick<T, K>`：选择类型 T 中的特定属性 K。
* `Record<K, T>`：根据键类型 K 创建一个新类型，其属性为类型 T。
* `Exclude<T, U>` 和 `Extract<T, U>`：从类型 T 中排除或提取符合类型 U 的部分。

映射类型可以使类型操作更加灵活，能够根据现有类型创建出符合特定需求的新类型。
这种功能特别适用于工具类型（Utility Types）的定义，使得类型系统更具表现力和可维护性。

## Template Literal Types（模板文字类型）

Template Literal Types（模板文字类型）是 TypeScript 4.1 引入的一项新特性，它允许在类型系统中对字符串文本进行操作和转换。这项功能利用了模板字符串的灵活性，使得可以在类型声明中使用类似于模板字符串的语法。

在模板文字类型中，可以使用模板字符串的 `${}` 语法来动态地创建字符串字面量类型。
这使得类型系统更具表现力，能够进行更复杂的字符串类型操作。

举个例子，假设有一个类型 WelcomeMessage，用于根据用户类型生成不同的欢迎消息：

```ts twoslash
type User = 'admin' | 'user'

type WelcomeMessage<T extends User> = `Welcome, ${Capitalize<T>}!`

type AdminWelcome = WelcomeMessage<'admin'>
//     ^?

type UserWelcome = WelcomeMessage<'user'>
//    ^?
//
```

在这个例子中，`WelcomeMessage` 是一个模板文字类型，利用了模板字符串中的 `${}` 语法。
它动态地根据传入的用户类型（"admin" 或 "user"）生成相应的欢迎消息。
这里使用了 `Capitalize<T>` 来确保用户名的首字母大写。

模板文字类型在类型定义中能够进行字符串的拼接、转换等操作，使得在类型层面上能够更灵活地处理和操作字符串类型。

## 类型推断关键字

在 TypeScript 中，有几个关键字和操作符用于类型判定。
这些关键字和操作符帮助你在代码中进行类型检查、类型判断和类型转换。

### typeof

`typeof` 是一个类型查询操作符，用于获取变量或表达式的类型。它可以返回该值的类型字符串表示。
比如 `typeof variable` 返回变量的类型，如 'number'、'string'、'object' 等。

```ts twoslash
const numberVar = 10

type NumberType = typeof numberVar
//     ^?
//
```

### instanceof

`instanceof` 运算符用于检查对象是否是特定类的实例。它返回一个布尔值表示检查结果。

```ts
class Animal {}
class Dog extends Animal {}

const dog = new Dog()
if (dog instanceof Dog) {
  console.log('It is a dog!')
}
```

### in

`in` 关键字用于检查对象是否具有特定属性。它在条件语句中常用于判断对象是否包含某个属性。

```ts
interface Person {
  name: string
  age: number
}

const person: Person = { name: 'Alice', age: 30 }
if ('age' in person) {
  console.log('Person has age property.')
}
```

### type guards

类型守卫是自定义的函数或条件语句，用于在代码块内缩小变量的类型范围。
它们可以是 `typeof`、`instanceof` 或者其他自定义条件的组合。

```ts twoslash
function isNumber(value: any): value is number {
  return typeof value === 'number'
}

function process(value: any) {
  if (isNumber(value)) {
    //           ^?

    // value 在此处被缩小为 number 类型
    console.log(value.toFixed(2))
    //            ^?
  }
  else {
    console.log('Value is not a number')
  }
}
```

### as

`as` 关键字用于类型断言，允许将一个变量断言为特定的类型。

```ts
const someValue: any = 'hello'
const length = (someValue as string).length
```

这些关键字和操作符能够在 TypeScript 中进行类型判断、类型检查和类型转换，有助于确保代码的类型安全性和正确性。

---

---
url: /czxBlog/article/q40nq4hv/index.md
---
# 详解 Promise
## 概述

`Promise` 是一个构造函数，用于创建一个新的 Promise 对象。该构造函数主要用于包装还没有添加 promise 支持的函数。

```txt
Promise(resolver : (resolve, reject) => void)
```

`Promise` 接受一个函数`resolver`作为参数，包装需要执行的处理程序，当处理结果为成功时，将成功的返回值作为参数调用`resolve` 方法，
如果失败，则将失败原因作为参数调用`reject`方法。

### 示例

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    // do something
    if (Math.random() * 10 > 5) {
      resolve({ status: 'success', data: '' })
    }
    else {
      reject(new Error('error'))
    }
  }, 500)
})
```

### Promise状态

Promise 创建后，必然处于以下几种状态

* `pending` : 待定状态，既没有被兑现，也没有被拒绝
* `fulfilled` : 操作成功。
* `rejected` : 操作失败。

当状态从 `pending` 更新为`fulfilled`或`rejected` 后，就再也不能变更为其他状态。

### Promise 实例方法

#### `.then(onFulfilled, onRejected)`

*then()* 接收两个函数参数（也可以仅接收一个函数参数 onFulfilled）。

* onFulfilled 函数参数，表示当 promise的状态从 `pending` 更新为`fulfilled` 时触发，并将成功的结果 value 作为`onFulfilled`函数的参数。
* onRejected 函数参数，表示当promise的状态从 `pending` 更新为`rejected` 时触发，并将失败的原因 reason 作为 `onRejected`函数的参数。

  *then()* 方法返回的结果会被包装为一个新的promise实例。

#### `.catch(onRejected)`

*catch()* 可以相当于 *.then(null, onRejected)*，即仅处理当promise的状态从 `pending` 更新为`rejected` 时触发。

#### `.finally(onFinally)`

表示promise的状态无论是从`pengding`更新为`fulfilled`或`rejected`，当所有的 then() 和 catch() 执行完成后，最后会执行 finally() 的回调。

由于无法知道promise的最终状态，`onFinally` 回调函数不接收任何参数，它仅用于无论最终结果如何都要执行的情况。

```js
promise
  .then((res) => {
    console.log(res) // { status: 'success', data: '' }
  })
  .catch((reason) => {
    console.log(reason) // error: error
  })
  .finally(() => {
    // do something
  })
```

### 链式调用

使用Promise的一个优势是，可以链式调用的方式，执行多个`then()`/`catch()`方法。
且回调函数允许我们返回任何值，返回的值将会被包装为一个 promise实例，将值传给下一个`then()`/`catch()`方法。

```js
promise
  .then((res) => {
    res.data = { a: 2 }
    return res
  })
  .then((res) => {
    console.log(res) // { status: 'success', data: { a: 2 } }
    throw new Error('cath error')
  })
  .catch((reason) => {
    console.log(reason) // error: cath error
  })
```

## Promise代码实现

```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const microtask = globalThis.queueMicrotask || (cb => setTimeout(cb, 0))

function LikePromise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError(`Promise resolver ${resolver} is not a function`)
  }
  this.state = PENDING
  this.value = undefined
  this.reason = undefined
  this.fulfillQueue = []
  this.rejectQueue = []

  const that = this

  function reject(reason) {
    if (that.state === PENDING) {
      that.state = REJECTED
      that.reason = reason
      that.rejectQueue.forEach(cb => cb(reason))
    }
  }

  function resolve(value) {
    if (that.state === PENDING) {
      that.state = FULFILLED
      that.value = value
      that.fulfillQueue.forEach(cb => cb(value))
    }
  }

  try {
    resolver(resolve, reject)
  }
  catch (e) {
    reject(e)
  }
}

function resolvePromise(promise, x, resolve, reject) {
  if (promise === x) {
    reject(new TypeError('chaining cycle'))
  }
  else if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    let used = false
    try {
      const then = x.then
      if (typeof then === 'function') {
        then.call(
          x,
          (y) => {
            if (used)
              return
            used = true
            resolvePromise(promise, y, resolve, reject)
          },
          (r) => {
            if (used)
              return
            used = true
            reject(r)
          },
        )
      }
      else {
        if (used)
          return
        used = true
        resolve(x)
      }
    }
    catch (e) {
      if (used)
        return
      used = true
      reject(e)
    }
  }
  else {
    resolve(x)
  }
}

LikePromise.prototype.then = function (onFulfilled, onRejected) {
  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
  onRejected
    = typeof onRejected === 'function'
      ? onRejected
      : (reason) => {
          throw reason
        }
  const that = this
  const promise = new LikePromise((resolve, reject) => {
    if (that.state === FULFILLED) {
      microtask(() => {
        try {
          const x = onFulfilled(that.value)
          resolvePromise(promise, x, resolve, reject)
        }
        catch (e) {
          reject(e)
        }
      })
    }
    else if (that.state === REJECTED) {
      microtask(() => {
        try {
          const x = onRejected(that.reason)
          resolvePromise(promise, x, resolve, reject)
        }
        catch (e) {
          reject(e)
        }
      })
    }
    else {
      that.fulfillQueue.push(() => {
        microtask(() => {
          try {
            const x = onFulfilled(that.value)
            resolvePromise(promise, x, resolve, reject)
          }
          catch (e) {
            reject(e)
          }
        })
      })
      that.rejectQueue.push(() => {
        microtask(() => {
          try {
            const x = onRejected(that.reason)
            resolvePromise(promise, x, resolve, reject)
          }
          catch (e) {
            reject(e)
          }
        })
      })
    }
  })
  return promise
}

LikePromise.prototype.catch = function (onRejected) {
  return this.then(null, onRejected)
}

LikePromise.prototype.finally = function (onFinally) {
  return this.then(
    value => LikePromise.resolve(onFinally()).then(() => value),
    reason =>
      LikePromise.resolve(onFinally()).then(() => {
        throw reason
      }),
  )
}

LikePromise.resolve = function (value) {
  return new LikePromise(resolve => resolve(value))
}

LikePromise.reject = function (reason) {
  return new LikePromise((_, reject) => reject(reason))
}
```

## `Promise` 静态方法

### Promise.resolve(value)

返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，
返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),
返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。
通常而言，如果您不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,
这样就能将该value以Promise对象形式使用。

### Promise.reject(reason)

返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法

### Promise.all(promises)

`all()` 允许传入一组promise实例，并返回一个新的promise实例。

promises并发执行，并且当这组promises的最终状态均更新为`fulfilled`时，才触发返回的promise实例的`onFulfilled`，
并将这组promises的执行结果，已promises的定义顺序，以数组的形式传给`onFulfilled`。
如果其中某个promise的最终状态更新为`rejected`，则立即触发返回的promise实例的`onRejected`。

#### 示例

```js
const promises = [
  Promise.resolve({ a: 1 }),
  new Promise((resolve) => {
    setTimeout(() => {
      resolve({ b: 1 })
    }, 0)
  }),
]
Promise.all(promises).then((res) => {
  console.log(res) // [ { a: 1}, { b: 1 } ]
})
```

#### 手写Promise.all 实现代码

```js
function promiseAll(promises) {
  promises = promises || []
  let length = promises.length
  if (length === 0)
    return Promise.resolve([])
  let count = 0
  const list = []
  return new Promise((resolve, reject) => {
    const resolveFn = (res, index) => {
      list[index] = res
      count++
      if (count >= length) {
        resolve(list)
      }
    }
    promises.forEach((item, i) => {
      if (item instanceof Promise) {
        item.then(res => resolveFn(res, i), reject)
      }
      else {
        resolveFn(item, i)
      }
    })
  })
}
```

### Promise.allSettled

`allSettled(promises)` 允许传入一组promise实例，并返回一个新的promise对象。

当这组promises的状态从`pending` 都更新到最终状态、无论最终状态是 `fulfilled` 或`rejected`时，触发返回的promise的`onfulfilled`。

`onfulfilled` 回调函数，根据promises定义的顺序，将执行结果以 `{ status: string, [value|reason]: any }[]` 的形式作为参数传入。

#### 示例

```js
const promises = [Promise.resolve({ a: 1 }), Promise.reject(new Error('reason'))]
Promise.allSettled(promises).then((res) => {
  console.log(res) // [ { status: 'fulfilled’, value: { a: 1 } }, { status: 'rejected', reason: 'reason' }  ]
})
```

#### 手写Promise.allSettled 实现代码

```js
function promiseAllSettled(promises) {
  promises = promises || []
  let length = promises.length
  if (length === 0)
    return Promise.resolve([])
  let count = 0
  const list = []
  return new Promise((resolve) => {
    const resolveFn = (res, index, status) => {
      list[index] = { status }
      if (status === 'fulfilled') {
        list[index].value = res
      }
      else {
        list[index].reason = res
      }
      count++
      if (count >= length) {
        resolve(list)
      }
    }
    promises.forEach((item, i) => {
      if (item instanceof Promise) {
        item.then(
          res => resolveFn(res, i, 'fulfilled'),
          reason => resolveFn(reason, i, 'rejected'),
        )
      }
      else {
        resolveFn(item, i, 'fulfilled')
      }
    })
  })
}
```

### Promise.race

`Promise.race(promises)` 接收一组promise实例作为参数，并返回一个新的promise对象。

当这组promises中的任意一个promise的状态从`pending`更新为`fulfilled`或`rejected`时，返回的promise对象将会把该promise的成功返回值或者失败原因
作为参数调用返回的promise的`onFulfilled`或`onRejected`

#### 示例

```js
const promises = [
  new Promise((resolve) => {
    setTimeout(() => {
      resolve('timeout')
    }, 500)
  }),
  Promise.resolve('resolve'),
]

Promise.race(promises).then((res) => {
  console.log(res) // resolve
})
```

#### 手写Promise.race 实现代码

```js
function promiseRace(array) {
  array = array || []
  return new Promise((resolve, reject) => {
    array.forEach((item) => {
      if (item instanceof Promise) {
        item.then(resolve, reject)
      }
      else {
        resolve(item)
      }
    })
  })
}
```

## 参考资料

> [Promise A+ 规范](https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/)
>
> [MDN Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)
>
> [MDN 使用Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)

---

---
url: /czxBlog/article/qrfeqp1q/index.md
---
# 小徽章制作
用于制作 小徽章的在线网站 或项目

* <https://shields.io/>
* <https://badgen.net/>
* <https://forthebadge.com/>
* <https://badge.fury.io/>
* <https://github.com/boennemann/badges>

## example

```md
![npm version](https://badge.fury.io/js/@vuepress-plume%2Fvuepress-theme-plume.svg)

![npm version](https://badge.fury.io/js/@vuepress-plume%2Fvuepress-theme-plume.svg)

![github version](https://badge.fury.io/gh/pengzhanbo%2Fvuepress-theme-plume.svg)

![release](https://badgen.net/github/release/pengzhanbo/vuepress-theme-plume/)

![npm](https://img.shields.io/npm/dw/@vuepress-plume/vuepress-theme-plume?style=plastic)
```

![npm version](https://badge.fury.io/js/@vuepress-plume%2Fvuepress-theme-plume.svg)

![github version](https://badge.fury.io/gh/pengzhanbo%2Fvuepress-theme-plume.svg)

![release](https://badgen.net/github/release/pengzhanbo/vuepress-theme-plume/)

![npm](https://img.shields.io/npm/dw/@vuepress-plume/vuepress-theme-plume?style=plastic)

---

---
url: /czxBlog/article/s8udp6vp/index.md
---
# <!DOCTYPE> 文档类型声明
Web世界中，随着历史的发展，技术的迭代，发展出了许多不同的文档，只有了解文档的类型，浏览器才能正确的解析渲染文档。

HTML也有多个不同的版本，只有完全明白页面使用的是哪个确切的HTML版本，浏览器才能完全正确的显示出HTML页面。

## 定义

`<!DOCTYPE>` 标签是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义（DTD）来解析文档。

## 作用

声明文档的解析类型 （document.compatMode），避免浏览器的怪异模式。

**document.compatMode:**

* `BackCompat`: 怪异模式，浏览器使用自己的怪异模式解析渲染页面。
* `CSS1Compat`: 标准模式，浏览器使用W3C的标准解析渲染页面。

## 使用

在文档的首行进行声明。必须位于 html标签之前。

`<!DOCTYPE>` 声明不是HTML标签，它是指示浏览器关于页面使用哪个HTML版本的指令。

> 如果页面没有 DOCTYPE 声明，那么默认是 怪异模式，为了确保浏览器按预期渲染页面，必须进行DOCTYPE声明。

### 常用的DOCTYPE声明

一般情况下，默认使用以下声明即可。

```html
<!doctype html>
<html></html>
```

## 一般DOCTYPE声明列表

### html5

```html
<!doctype html>
```

### HTML 4.01 Strict

该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

### HTML 4.01 Transitional

该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
```

### HTML 4.01 Frameset

该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
```

### XHTML 1.0 Strict

该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

### XHTML 1.0 Transitional

该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" " http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

### XHTML 1.0 Frameset

该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
```

### XHTML 1.1

该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
```

---

---
url: /czxBlog/article/snkdmwsz/index.md
---
# 内容安全策略(CSP)
内容安全策略（`Content-Security-Policy`），简称 `CSP`。是一种 计算机安全标准。

主要目标是 减少和报告XSS攻击、数据注入攻击等。这些攻击手段的主要目的是盗取网站数据、网站内容污染、散发恶意软件等。

几乎所有现在浏览器都支持 `CSP`， 对于不支持的浏览器，则会忽略 `CSP`。

## XSS攻击

XSS攻击是一种常见的、危害极大的网络攻击手段。它利用浏览器对从服务器获取的内容的信任，
通过站点的 `script` 脚本、内联脚本、外部导入资源等方式进行注入攻击。
恶意脚本在受害者浏览器中执行，以达成其目的。

## CSP

`CSP` 通过 **有效域名**，即 **浏览器认可的可执行脚本的有效来源** ，使 服务器管理者有能力消除或减少 XSS 攻击所以来的载体。
支持 `CSP` 的浏览器，仅会执行从白名单域名加载的脚本文件，忽略其他所有脚本，包括内联脚本和 HTML 事件处理属性。

## 制定策略

`CSP` 通过 声明 HTTP 头部字段 `Content-Security-Policy` 来启用和配置策略：

```
Content-Security-Policy: policy;
Content-Security-Policy: policy; policy;
```

参数 `[policy]` 是一个包含了描述 各种CSP策略指令的字符串。

## 策略指令

### default-src

为其他CSP指令提供备选项，如果其他指令不存在，用户代理会查找并应用该值，如果其他指令有配置值，那么则不会应用 default-src的值。

default-src 策略允许指定一个或多个值：

```
Content-Security-Policy: default-src <source>;
Content-Security-Policy: default-src <source> <source>;
```

### script-src

脚本内容安全策略指令，包括限制 外部资源、内联脚本、eval函数。

```
Content-Security-Policy: script-src <source>
```

### style-src

CSS文件内容安全策略指令，包括限制 内联样式表、通过`<link>` 引入的css文件、样式中通过 `@import` 导入的css文件、
元素的 `style` 属性、 `style.cssText` 属性、以及 `el.setAttribute('style', '')`

```
Content-Security-Policy: style-src <source>
```

### img-src

图片资源内容安全策略指令， 限制通过 `<img>` 加载的图片资源

```
Content-Security-Policy: img-src <source>
```

### media-src

媒体资源内容安全策略指令，限制通过 `<audio>`、`<video>`、`<track>` 加载的媒体资源

```
Content-Security-Policy: media-src <source>
```

### frame-src

iframe内容安全策略指令，限制`<iframe>` 加载的页面资源

### 其他指令

* `manifest-src` 限制 manifest 资源（通过`<link>`引入的 manifest文件）
* `worker-src` 限制 `worker`资源，包括 `Worker`、`SharedWorker` 、`ServiceWorker`
* `child-src` 限制 `web worker`、`<frame>` 、`<iframe>`
* `connect-src` 限制允许通过脚本接口加载的链接地址，包括：`<a>`、`Fetch`、`XMLHttpRequest`、`WebSocket`、`EventSource`
* `font-src` 限制 `@font-face` 加载字体的有效源规则。
* `object-src` 限制 `<object>`、`<embed>`、`<applet>`

### 指令`<source>`有效值

* `<host-source>`

  以域名或者 IP 地址表示的主机名，外加可选的 URL 协议名（URL scheme）以及端口号。
  支持前置通配符（星号 '\*'），可以将通配符应用于站点地址、端口中，如应用于端口，则表示允许使用该域名下的所有端口。

  * **example.com:443** 匹配 example.com 上 443 端口访问
  * **<https://example.com>** 匹配使用了 http: 的 example.com 的访问
  * **\*.example.com** 匹配 example.com 下的所有子域名的访问

* `<scheme-source>`

  协议名如'http:' 或者 'https:'。必须带有冒号，不要有单引号。

* `'self'`

  指向与要保护的文件所在的源，包括相同的 URL scheme 与端口号。必须有单引号。

* `'unsafe-inline'`

  允许使用内联资源，例如内联 `<script>` 元素（javascript: URL）、内联事件处理器以及内联 `<style>` 元素。必须有单引号。

* `'unsafe-eval'`

  允许使用 eval() 以及相似的函数来从字符串创建代码。必须有单引号。

* `'none'`

  不允许任何内容。 必须有单引号。

* `'nonce-<base64 值>'`

  特定使用一次性加密内联脚本的白名单。服务器必须在每一次传输政策时生成唯一的一次性值。否则将存在绕过资源政策的可能。

* `<hash-source>`

  使用 sha256、sha384 或 sha512 编码过的内联脚本或样式。其由用短划线分隔的两部分组成：用于创建哈希的加密算法，以及脚本或样式 base64 编码的哈希值。当生成哈希值的时候，不要包含 `<script>` 或 `<style>` 标签，同时注意字母大小写与空格——包括首尾空格——都是会影响生成的结果的。

  ```
  Content-Security-Policy: default-src sha256-abcdef;
  ```

* `'strict-dynamic'`

  strict-dynamic 指定对于含有标记脚本 (通过附加一个随机数或散列) 的信任，应该传播到由该脚本加载的所有脚本。与此同时，任何白名单以及源表达式例如 'self' 或者 'unsafe-inline' 都会被忽略。

## 启用CSP

启用CSP，可以在 HTTP服务器中，新增 Header 字段：
如，在nginx中：

```nginx
http {
  # ...more
  server {
    # ...more
    location / {
      index index.html;
      Content-Security-Policy default-src 'self';
      # ...more
    }
  }
}
```

也可以在 html 文件中 添加 `<meta>` 标签

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self';" />
```

## 示例

### 示例1

默认只允许加载本站资源

```
Content-Security-Policy: default-src 'self';
```

### 示例2

默认只允许加载本站资源，但允许任意来源图片资源

```
Content-Security-Policy: default-src 'self'; img-src *;
```

### 示例3

默认只允许加载本站资源，允许 script资源、css资源、图片资源从指定cdn域名加载

```
Content-Security-Policy: default-src 'self'; script-src 'self' https://cdn.example.com; style-src  'self' https://cdn.example.com; img-src 'self' https://cdn.example.com;
```

### 示例4

阻止所有 iframe 窗口，允许本站加载其他资源

```
Content-Security-Policy: default-src 'self'; frame-src 'none';
```

### 示例5

执行特定 nonce 的内联脚本：

```
Content-Security-Policy: script-src 'nonce-abcdef' 'self';
```

只有在`<script>`标签内带有特定 `nonce` 值的脚本才允许执行：

```html
<script nonce="abcdef" src="example.js"></script>
```

### 示例6

Hash 值相符的脚本才能执行：

```
Content-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG+HiZ1guq6ZZDob/Tng='
```

该hash值必须是 script 标签内容的 sha256 值，代码才能执行：

```html
<script>
  alert('Hello, world.')
</script>
```

## 违例报告

启用 CSP 后，默认情况下，违例报告不会发送。我们可以通过配置 `report-uri` 策略指令，并提供至少一个URI地址去递交报告。

```
Content-Security-Policy: default-src 'self'; report-uri http://report.example.com/csp;
```

### 违例报告示例

违例报告将以 JSON 对象的数据结构进行递交：

```json
{
  "csp-report": {
    "document-uri": "http://example.com/index.html", // 发生违规的文档的 URI
    "referrer": "", // 违规发生处的文档引用（地址）
    "blocked-uri": "http://example.com/css/style.css", // 被 CSP 阻止的资源 URI。
    "violated-directive": "style-src cdn.example.com", // 违反的策略名称。
    // 在 Content-Security-Policy HTTP 头部中指明的原始策略。
    "original-policy": "default-src 'none'; style-src cdn.example.com; report-uri /_/csp-reports"
  }
}
```

当服务器接收到 违例报告，可以通过分析报告内容，来进行自定义的处理。

---

---
url: /czxBlog/article/tz7ncicn/index.md
---
# 1px解决方案
在日常移动端前端应用开发中，经常遇到一个问题就是 1px的线在移动端 Retina屏下的渲染并未达到预期。以下总几种不同场景下的 1px解决方案。

## 背景及原因

首先，需要明确的一个概念是， CSS的 `pixels` 并不完全等价于 设备的 `pixels`。
当我们假定设备的 `pixels` 为标准的`pixels` 宽度。这些pixels决定了设备的分辨率。
在默认情况下， PC设备上用户未进行缩放操作（即zoom缩放为100%时）, CSS的`pixels`与设备的`pixels`重叠，
当用户进行了缩放操作时，假设用户缩放了200%，那么 124px的CSS`pixels`实际占用了248设备`pixels`。

但我们开发时，通常设备的`pixels`对我们毫无用处，前端只需要关注CSS的`pixels`，浏览器会根据用户缩放自动处理CSS的pixels是被伸展还是收缩。

但在移动端设备中，由于设备的宽度较小，导致了可显示的内容要少得多。浏览器或者缩放变小，导致内容无法阅读，或者通过拖动来浏览未被显示的内容。这导致了原本适合于PC设备的CSS布局，放到了移动端，变得十分丑陋。

为了解决这个问题，移动端设备的厂商的通常做法是，让viewport更宽（这里的viewport指的是设备的视窗，它决定了HTML标签的宽度表现，继而影响其他的元素）。

移动端的 viewport 被分为了 虚拟的 viewport 和 布局的 viewport：

* `visual viewport`： 虚拟viewport
* `layout viewport`： 布局viewport

![viewport](/images/viewport.jpg)

两者的概念， 可以想象 `layout viewport` 为一张不可改变大小和角度的图片，但它被一层蒙板挡住了， `visual viewport` 是一个蒙板上我们可以观察到 这张图片的窗口。我们可以通过这个窗口观察到 图片的部分内容。并且可以对这个窗口进行拖动或缩放，进而观察到图片的完整内容。

在这里，`visual viewport` 相当于 移动端设备的屏幕，用户的 缩放和拖动操作，反馈到 `layout viewport` ,则是相对的变成 `layout viewport` 被 拖动和缩放。

而通常我们关注的 CSS`pixels`，通常是按照 `layout viewport`来定义的，所以会比`visual viewport` 宽很多。而 `<html>`元素的宽度继承于`layout viewport`。这可以保证你的网站的UI可以在移动端设备和桌面设备表现一致。

但是 `layout viewport`的宽度有多宽，不同的设备，不同的浏览器各有不同。如 iPhone 的Safari 使用的是 980px。

但是在移动端的交互中，我们并不期望 网站的内容是被缩放的，需要让用户进行缩放和拖动。 所以通常我们会在 html文件的head中，进行一个 meta声明。

```html
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
```

即强制设置了`layout viewport` 等于 设备宽度， 设置了缩放为100%，并且用户无法进行缩放操作。这样做的好处是我们可以以一种期望的方式进行设计UI和交互。

但在前面，我们介绍了， CSS的`pixels`并不等价于设备的`pixels`。
通常在移动端设备，我们可以通过 `window.devicePixelRatio` 查看当前设备的CSS`pixels`和设备`pixels`的比例，
如 `window.devicePixelRatio` 值为 2时， 表示 1个CSS`pixels`的宽度占用2个设备`pixels`，即实际占用了 2x2 的设备`pixels`。

这也是导致了 `1px`的线，在移动设备上的渲染，看起来会比实际上的 `1px`更粗的原因。

知道了问题的背景，和产生的原因，那么只需要让 `1px`的 CSS`pixels`的表现，接近于或者贴合 `1px`的设备`pixels`, 那么就可以解决这个问题了。

## 解决方案

如何让 `1px`的 CSS`pixels`的表现，接近于或者贴合 `1px`的设备`pixels`。这个问题需要具体场景具体分析。

### border-width: 0.5px

一种最简单的，且适合各种场景的方案，就是使用 `0.5px` 的值代替 `1px` 的值。 但这个方案有一个兼容问题，现代浏览器并不全都支持该值的。

可以先检查是否支持 `0.5px`，然后在 根元素上添加一个 类，进行使用。

```js
if (window.devicePixelRatio && devicePixelRatio >= 2) {
  let testElem = document.createElement('div')
  testElem.style.border = '.5px solid transparent'
  document.body.appendChild(testElem)
  if (testElem.offsetHeight === 1) {
    document.querySelector('html').classList.add('hairlines')
  }
  document.body.removeChild(testElem)
}
```

```css
div {
  border: 1px solid #bbb;
}

.hairlines div {
  border-width: 0.5px;
}
```

这种方案的好处是简单，能够适配所有场景，但是从兼容性上看，iOS7及之前的版本、Android设备等，均不支持`0.5px`的渲染。

### 伪类 + transform缩放

该方法是是利用 元素的伪类进行线的渲染。

比如 利用 `::before` 或者 `::after`, 画一条上边框的线

```css
.hairlines {
  position: relative;
}
.hairlines::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  display: block;
  width: 100%;
  height: 1px;
  background-color: #000;
  transform: scaleY(0.5);
  transform-origin: 0 0;
}
```

比如，利用 `::before` 或者 `::after`, 画一个线框：

```css
.hairlines {
  position: relative;
}
.hairlines::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  box-sizing: border-box;
  display: block;
  width: 200%;
  height: 200%;
  border: 1px solid #000;
  transform: scale(0.5);
  transform-origin: 0 0;
}
```

该方案的好处同样能都适配多数场景，并且支持圆角的情况。
但缺点在于由于对元素本身设置了`position`，以及使用了伪类，但另一个交互需要使用到被占用的属性时，需要分情况处理问题。

### border-image 图片

使用 border-image-slice 对边框图片进行偏移。

该方案的方法，比如处理 x轴方向的线时， 需要准备 一张2px高的图片，根据显示是上边框，还是下边框，如上边框，则该图片的 上一半1px为对应的颜色的先，下一半为透明。

*line.png* ![1px-lines.png](/images/1px-lines.png)

```css
div {
  border-top: 1px transparent;
  border-image: url(line.png) 2 0 0 0 repeat;
}
```

同理，处理其他方向的边框类似方法。

该方法的缺点是 如果改变颜色，或者有不同颜色的线，需要准备多张图片。

优先是适合多数的场景，且不对元素本身做出影响文档流的改动。

### SVG

由于CSS也支持 SVG 作为 image 资源使用，且SVG是矢量图片，能够相比于使用jpg、png格式的图片获得更好的保真。
可以配合 CSS 的 `background-image` 或者 `border-image` 满足不同场景的需要。

建议此方案配合 CSS 预渲染，如`stylus/sass/less` 进行使用， 也可使用`postcss` 相关插件使用。

如在 stylus中：

```stylus
// 画一个元素的线框
borderXY(color = #eee, radius = 8px) {
    $r = unit(radius/ 2, '');
    border-radius radius /*px*/
    background-image url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' width='100%' height='100%' viewBox='0 0 200% 200%' preserveAspectRatio='xMidYMid meet'><rect fill='rgba(0,0,0,0)' width='100%' height='100%' stroke-width='1' stroke='%s' rx='%s' ry='%s'/></svg>", color, $r, $r))
    background-repeat no-repeat
    background-position 0 0
    background-size 100% 100%
}

// 画一个元素的 上下边框
borderX(color = #eee) {
    border 0
    border-top: 1px solid color; /*no*/
    border-bottom: 1px solid color; /*no*/
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='200' width='100'><line x1='0' y1='25' x2='100' y2='25' stroke='%s' style='stroke-width:50'/><line x1='0' y1='75' x2='100' y2='75' style='stroke:transparent;stroke-width:50'/><line x1='0' y1='125' x2='100' y2='125' style='stroke:transparent;stroke-width:50'/><line x1='0' y1='175' x2='100' y2='175' stroke='%s' style='stroke-width:50'/></svg>", color, color)) 100 0 100 0 stretch;
}

// 画一个元素的 左右边框
borderY(color = #eee) {
    border 0
    border-left: 1px solid color; /*no*/
    border-right: 1px solid color; /*no*/
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='100' width='200'><line x1='25' y1='0' x2='25' y2='100' stroke='%s' style='stroke-width:50'/><line x1='75' y1='0' x2='75' y2='100' style='stroke:transparent;stroke-width:50'/><line x1='125' y1='0' x2='125' y2='100' style='stroke:transparent;stroke-width:50'/><line x1='175' y1='0' x2='175' y2='100' stroke='%s' style='stroke-width:50'/></svg>", color, color)) 0 100 0 100 stretch;
}

// 画一个元素的上边框
borderTop(color = #eee) {
    border 0
    border-top: 1px solid color; /*no*/
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='100' width='100'><line x1='0' y1='25' x2='100' y2='25' stroke='%s' style='stroke-width:50'/><line x1='0' y1='75' x2='100' y2='75' style='stroke:transparent;stroke-width:50'/></svg>", color)) 100 0 0 0 stretch;
}

// 画一个元素的下边框
borderBottom(color = #eee) {
    border 0
    border-bottom: 1px solid color; /*no*/ // 设置border 0后，如果color设置为transparent，则该边框会变成透明
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='100' width='100'><line x1='0' y1='25' x2='100' y2='25' style='stroke:transparent;stroke-width:50'/><line x1='0' y1='75' x2='100' y2='75' stroke='%s' style='stroke-width:50'/></svg>", color)) 0 0 100 0 stretch;
}

// 画一个元素的左边框
borderLeft(color = #eee) {
    border 0
    border-left: 1px solid color; /*no*/
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='100' width='100'><line x1='25' y1='0' x2='25' y2='100' stroke='%s' style='stroke-width:50'/><line x1='75' y1='0' x2='75' y2='100' style='stroke:transparent;stroke-width:50'/></svg>", color)) 0 0 0 100 stretch;
}
// 画一个元素的右边框
borderRight(color = #eee) {
    border 0
    border-right: 1px solid color; /*no*/
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='100' width='100'><line x1='25' y1='0' x2='25' y2='100' style='stroke:transparent;stroke-width:50'/><line x1='75' y1='0' x2='75' y2='100' stroke='%s' style='stroke-width:50'/></svg>", color)) 0 100 0 0 stretch;
}

div {
    borderXY()
}
```

如果是使用 `postcss` ，可以使用安装插件 [postcss-write-svg](https://github.com/csstools/postcss-write-svg)，配合使用

```css
@svg square {
  @rect {
    fill: var(--color, black);
    width: var(--size);
    height: var(--size);
  }
}

.example {
  background: svg(square param(--color green) param(--size 100%)) center / cover;
}
```

使用SVG的优点是，支持调整线的颜色，支持设置圆角，可以根据场景不同，选择 `background-image` 或者 `border-image` 满足绝大多数的场景。

### background-image + jpg/png 图片

该做法是使用一张该元素的多倍的背景图，进行线的渲染。

该做法一般不推荐。

### 背景渐变

该方案不推荐

### box-shadow

该方案不推荐

---

---
url: /czxBlog/article/uocv0xza/index.md
---
# React 架构演进探析 —— 从栈式协调到Fiber架构
## 前言

在探讨 React 内部机制时，经常提及一个关键转折点：**React 16 引入了Fiber架构**。这引发了一系列核心问题：何为 Fiber 架构？它所取代的原有架构是什么？React 团队引入 Fiber 架构的根本动因何在？

本文旨在系统解析Fiber架构的核心概念与设计思想，揭示其如何解决历史架构的瓶颈。深入的技术细节（如具体调度算法、优先级机制）将在后续专题文章中探讨。

**前置知识：** 深入理解 **Virtual DOM (虚拟DOM)** 是掌握React协调（Reconciliation）机制的基础。

## 栈式协调器（Stack Reconciler）

在Fiber架构诞生前，React的核心更新机制依赖于 **栈式协调器（Stack Reconciler）** 。

其核心在于通过 **递归深度优先遍历** 的方式对比新旧虚拟DOM树（Virtual DOM Tree），并计算最小更新操作（diff算法）。

```mermaid
graph LR
    A[更新开始] --> B[递归遍历VDOM]
    B --> C[深度优先遍历]
    C --> D[同步执行diff]
    D --> E[阻塞主线程]
    E --> F[页面卡顿]
    F --> G[更新结束]
```

以下是一个简化的虚拟DOM树结构示例，栈式协调器正是递归遍历此类结构：

```js
const tree = {
  type: 'div',
  props: {
    id: 'list',
    children: [
      {
        type: 'ul',
        props: {
          children: [
            {
              type: 'li',
              props: {
                children: 'apple'
              }
            },
            // ... 其他子节点
          ]
        }
      }
    ]
  }
}
```

### 主要特性与局限性

1. **同步不可中断（Synchronous & Uninterruptible）**：
   * 更新流程一旦启动（即开始递归遍历与 diff 计算），必须 **连续执行直至完成** 。
   * 无法将庞大的更新任务拆分为小单元，也无法在执行过程中响应更高优先级的任务。

2. **性能瓶颈（Performance Bottlenecks）**：
   * 虽然 Virtual DOM 操作在 JavaScript 层面执行，相比直接操作真实 DOM 已是显著优化，但在处理**大型应用、深层嵌套组件树或复杂数据结构**时，递归遍历和 diff 计算仍可能消耗大量主线程（Main Thread）时间。
   * 长时间占用主线程会导致 **页面渲染卡顿（Jank）**、**交互响应延迟（Input Lag）**，严重损害用户体验（User Experience, UX）。

3. **缺乏任务优先级（Absence of Task Prioritization）**：
   * 所有更新任务均按生成顺序 **同步、无差别执行** 。
   * 当低优先级任务（如后台数据拉取后的UI更新）正在进行时，高优先级任务（如用户输入、动画）必须等待，导致 **高优先级交互无法得到即时响应** （例如，用户输入框输入时，毫秒级的延迟即可被感知为卡顿，而数据加载指示器更新延迟几秒可能尚可接受）。

### 核心瓶颈

栈式协调器主要面临两类影响UX的核心瓶颈：

1. **CPU瓶颈**：
   * **本质**：应用的计算复杂度（Virtual DOM diff、组件渲染逻辑）超出了单次事件循环（Event Loop）中主线程的处理能力上限。
   * **表现**：长时间、同步的JavaScript执行阻塞主线程，导致UI渲染与用户交互停滞。这是栈式架构最直接的性能痛点。

2. **I/O瓶颈**：
   * **本质**：网络请求延迟等I/O操作耗时是客观存在的物理限制。
   * **前端优化目标**：在I/O等待期间，主线程应保持响应能力，优先处理用户可感知的交互；同时，需根据任务来源（用户交互 vs. 后台数据）**区分更新优先级**，确保高优先级任务不被低优先级任务阻塞。栈式架构对此无能为力。

## Fiber架构

Fiber 架构是 React 为解决栈式协调器瓶颈而设计的全新协调引擎。

其核心思想是将 **同步不可中断的更新过程** 重构为 **异步可中断、可恢复且具备优先级调度能力** 的机制。

以下阐述其关键概念：

### Fiber节点（Fiber Node）

```mermaid
graph LR
    A[Fiber节点] --> B[child]
    A --> C[sibling]
    A --> D[return]
    B --> E[子节点]
    C --> F[兄弟节点]
    D --> G[父节点]

    style A fill:#f9f,stroke:#333
    style B fill:#bbf,stroke:#333
    style C fill:#bfb,stroke:#333
    style D fill:#fbb,stroke:#333
```

* **本质**：Fiber节点是Fiber架构下 **工作单元（Work Unit）** 的抽象，也是虚拟DOM节点在Fiber架构中的具体实现形式。

* **核心创新：链表数据结构**：与栈式协调器基于递归树不同，Fiber 节点通过 **显式链表指针** （`child`, `sibling`, `return`）组织成一颗**Fiber树**。这种结构赋予了遍历过程 **可暂停、可恢复、可回溯** 的能力。

* **结构示意**：

  * `child`: 指向当前节点的 **第一个子Fiber节点**。
  * `sibling`: 指向当前节点的 **下一个兄弟Fiber节点**。
  * `return`: 指向当前节点的 **父Fiber节点** （完成当前节点工作后需返回的节点）。

* **Fiber节点对象（源码简化版，附关键注释）**：

  ```ts
  function FiberNode(
    tag: WorkTag, // 节点类型标识：FunctionComponent, ClassComponent, HostRoot(根), HostComponent(DOM元素)等
    pendingProps: mixed, // 从新更新中接收到的、待处理的props
    key: null | string, // React元素的key，用于列表diff优化
    mode: TypeOfMode, // 渲染模式标志位（如ConcurrentMode, StrictMode）
  ) {
    // 实例标识与关联
    this.tag = tag
    this.key = key
    this.elementType = null // 创建该元素的函数/类或DOM标签名 (e.g., 'div', MyComponent)
    this.type = null // 与elementType类似，但对于懒加载组件可能不同
    this.stateNode = null // 关联的类组件实例、Host组件(DOM节点) 或 FiberRoot

    // Fiber树链表指针 (核心数据结构)
    this.return = null // 指向父Fiber节点
    this.child = null // 指向第一个子Fiber节点
    this.sibling = null // 指向下一个兄弟Fiber节点
    this.index = 0 // 在父节点children中的索引

    this.ref = null // ref引用

    // Props 与 State 管理
    this.pendingProps = pendingProps // 新传入的props
    this.memoizedProps = null // 上次渲染使用的props
    this.updateQueue = null // 状态更新、回调函数的队列
    this.memoizedState = null // 上次渲染产生的state (hooks链表等)
    this.dependencies = null // contexts, events订阅等依赖

    this.mode = mode // 渲染模式

    // 副作用 (Effects) 标记
    this.flags = NoFlags // 标记该Fiber节点需要进行的操作(Placement, Update, Deletion等)
    this.subtreeFlags = NoFlags // 子树中存在的副作用标记 (优化遍历)
    this.deletions = null // 记录待删除的子节点 (用于安全卸载)

    // 优先级与调度相关 (Lane 模型)
    this.lanes = NoLanes // 该Fiber上待处理的更新优先级 (lanes)
    this.childLanes = NoLanes // 子树中存在的最高优先级 (优化子树的跳过)

    // 双缓冲技术关键指针
    this.alternate = null // 指向current树或workInProgress树中的对应节点

    // 性能分析(Profiler)相关属性 (开发/分析构建下启用)
    if (enableProfilerTimer) { /* ... */ }
    // 开发模式调试属性
    if (__DEV__) { /* ... */ }
  }
  ```

### 调度器（Scheduler）、协调器（Reconciler）、渲染器（Renderer）

```mermaid
flowchart TB
    S[Scheduler] --> |调度任务| R[Reconciler]
    R --> |生成副作用列表| D[Renderer]
    D --> |更新宿主环境| H[DOM/Native]

    subgraph 核心流程
        direction LR
        R --> |可中断遍历| F[Fiber树]
        F --> |时间切片| T[主线程控制]
    end

    U[用户交互] --> |高优先级| S
    N[网络响应] --> |低优先级| S
```

React Fiber 架构将渲染流程清晰地划分为三个协同工作的层级：

* **调度器（Scheduler）**：

  * **职责**：作为 React 16+ 新增的核心模块，负责 **任务调度**。
    它管理一个任务队列，根据任务的 **优先级**
    （如：`Immediate` - 用户输入、`UserBlocking` - 交互反馈、`Normal` - UI更新、`Low` - 数据分析、`Idle` - 非必要任务）决定任务的执行顺序。
  * **解决关键问题**：直接应对 **I/O瓶颈优化需求** 和 **高优先级任务抢占需求** 。确保用户交互（高优先级）能及时打断并插队正在进行的低优先级渲染任务（如大数据列表更新），极大提升应用响应度（Responsiveness）。
  * **机制**：通常利用浏览器的`requestIdleCallback`(或polyfill/shim)在浏览器空闲期执行低优先级任务，并实现任务的中断与恢复。

* **协调器（Reconciler） - 运行于Fiber架构之上**：

  * **职责**：执行核心的 **diff算法** 。它接收更新请求，在内存中操作 **工作树（workInProgress tree）** ，对比新旧Fiber树（或根据状态变化生成新树），计算出 **副作用列表（Effect List）** - 即描述哪些节点需要被插入、更新或删除。
  * **关键特性**：得益于Fiber节点的链表结构，协调过程是 **可中断的异步过程** 。协调器与调度器紧密配合，根据调度器分配的优先级和时间片进行工作。

* **渲染器（Renderer）** (如 ReactDOM, React Native)：

  * **职责**：**平台特异性渲染**。接收协调器产生的副作用列表，将其 **安全、高效地应用到真实的宿主环境（如浏览器DOM或原生移动视图）** 上，完成最终的UI更新。
  * **关注点分离**：Renderer不关心如何计算更新，只负责执行更新命令。这使得React核心协调逻辑可以跨平台复用。

### 时间切片（Time Slicing）

```mermaid
gantt
    title React时间切片机制执行流程（单位：毫秒）
    dateFormat  X
    axisFormat %L
    section 帧1 (16.6ms)
    JS任务单元A : crit, a1, 0, 4
    JS任务单元B : a2, after a1, 4
    浏览器渲染阶段 : active, b1, after a2, 5
    空闲时段 : done, b2, after b1, 3.6

    section 帧2 (16.6ms)
    JS任务单元C : crit, c1, after b2, 5
    用户输入处理 : active, c2, after c1, 3
    JS任务单元D : c3, after c2, 4
    浏览器渲染阶段 : active, c4, after c3, 4.6
```

* **核心思想**：将原本可能长时间阻塞主线程的大型更新任务，**分解成多个小的、有限时的工作单元**。
* **实现方式**：调度器与协调器协同工作。协调器在遍历处理Fiber节点时，会检查当前帧剩余时间（通过调度器提供的能力）。如果一个工作单元执行时间过长或超过了分配的帧时间（如5ms），协调器会暂停当前工作，将控制权交还给浏览器，让其处理更紧急的任务（如绘制、用户输入）。
* **价值**：有效避免JavaScript长时间独占主线程，保证浏览器有 **足够的时间进行渲染（Rendering）和响应用户输入（Input Handling）**，从而维持界面的 **流畅性（Fluency）** 和 **响应性（Responsiveness）**。这是解决**CPU瓶颈**的核心手段之一。

### 双重缓冲（Double Buffering）

```mermaid
graph LR
    C[Current Tree] --> |屏幕当前显示| D[真实DOM]
    W[WorkInProgress Tree] --> |内存中构建| V[新虚拟DOM]

    C -->|克隆| W
    W -->|提交完成| C
    C -.->|alternate指针| W

    style C fill:#e6f7ff
    style W fill:#f6ffed
    style D stroke:#ff7875
    style V stroke:#52c41a
```

* **技术类比**：借鉴图形学中的双重缓冲技术，避免画面撕裂。

* **在Fiber中的实现**：React在内存中同时维护两棵Fiber树：

  * **当前树（Current Tree）**：对应屏幕上当前显示的UI状态。Fiber节点的`stateNode`指向真实的DOM节点。
  * **工作树（Work-In-Progress Tree, WIP Tree）**：正在后台构建的、反映下一次更新后UI状态的树。构建过程不会直接影响当前显示的UI。

* **工作流程**：

  1. 更新开始时，协调器基于当前树克隆（或创建）出工作树。
  2. 所有diff计算和状态更新都在工作树上进行。
  3. 当工作树完整构建完成（或达到可提交状态），且当前无更高优先级任务时，Renderer将 **原子性地（Atomically）** 将工作树的更新应用到真实DOM上。此过程称为 **提交（Commit）**。
  4. 提交完成后，工作树即成为新的当前树。旧的当前树节点可能被回收或作为下次更新的备用（Alternate）。

* **优势**：

  * **非破坏性更新**：更新计算过程不影响当前显示，确保UI稳定性。
  * **快速回滚**：若更新过程中有更高优先级任务介入，可直接丢弃未完成的工作树，避免显示中间的不一致状态。
  * **并发模式基础**：是实现异步渲染（Concurrent Rendering）的关键机制。

## 结语

Fiber架构通过引入 **Fiber节点（链表结构）**、**任务调度器（Scheduler）**、**时间切片（Time Slicing）** 和 **双重缓冲（Double Buffering）** 等核心机制，成功将React的协调过程从 **同步不可中断** 转变为 **异步可中断且具备优先级调度能力**。

这一变革从根本上解决了栈式协调器面临的 **CPU瓶颈**（长时间任务阻塞主线程）与 **I/O瓶颈优化需求**（优先级调度），为React应用的 **流畅性、响应性** 奠定了坚实基础。理解这些基础概念是深入探索React Concurrent Features（并发特性）如`useTransition`、`useDeferredValue`以及Suspense流式渲染等高级能力的前提。

---

---
url: /czxBlog/article/ur80anlr/index.md
---
# React 原理解析：Diff 算法机制与优化策略
::: info React 的 Diff 算法是其高性能渲染的核心保障，本文将从原理到实现剖析这一关键机制。
:::

## Diff 算法：React 高效渲染的基石

在 React 框架中，**Diff 算法**扮演着至关重要的角色，它决定了在组件状态或属性变更时，React 如何高效地更新 DOM 结构。

其核心功能是在构建 **workInProgress Fiber Tree** 时，智能复用 **current Fiber Tree** 中对应的 FiberNode。

### 核心定位

当组件状态或属性发生变化时，React 需要精确识别需要更新的 DOM 部分。Diff 算法通过以下方式实现这一目标：

```mermaid
flowchart TD
    A[组件状态/属性变化] --> B[生成新JSX对象]
    B --> C[Diff算法对比]
    D[Current Fiber Tree] --> C
    C --> E[生成WorkInProgress Fiber Tree]
    E --> F[DOM更新]
```

**JSX对象**（类组件 render 方法的返回值或函数组件的执行结果）包含描述 DOM 节点的关键信息。
Diff 算法的本质就是对比 **current Fiber Tree** 和 **JSX 对象**，生成 **workInProgress Fiber Tree**。

## 核心策略

### 1. 分层同级比较

React 将 DOM 树分解为多个层级，**只比较同一层级的节点**，避免跨层级比较带来的复杂度爆炸。
同级节点按照**从左到右的顺序**进行对比。

```mermaid
graph TD
    A[Root] --> B[Level 1]
    A --> C[Level 1]
    B --> D[Level 2]
    B --> E[Level 2]
    C --> F[Level 2]
    C --> G[Level 2]
```

### 2. 元素类型对比

当节点类型发生变化时，React 会销毁旧树并创建新树：

```jsx
// 更新前
<div>
  <Button />
</div>
```

```jsx
// 更新后 - 元素类型改变
<div>
  <Input />
</div>
```

### 3. Key 属性的关键作用

Key 是 React 中标识节点唯一性的核心机制，帮助 React 在 Diff 过程中**精准识别节点**：

```jsx
// 更新前
<div>
  <p key="a">a</p>
  <span key="b">b</span>
</div>
```

```jsx
// 更新后
<div>
  <span key="b">b</span>
  <p key="a">a</p>
</div>
```

**关键机制**：当使用 key 时，React 能识别节点只是位置变化而非元素类型改变，从而**复用现有节点**而非重建整个子树。

## 实现机制

### 核心函数：reconcileChildFibers

Diff 算法在 React 源码中通过 `reconcileChildFibers` 函数实现，其核心逻辑如下：

```ts
function reconcileChildFibers(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any
): Fiber | null {
  // 处理对象类型的新子元素
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        return placeSingleChild(
          reconcileSingleElement(returnFiber, currentFirstChild, newChild)
        )
      // 处理其他类型...
    }

    // 处理数组类型
    if (isArray(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild)
    }

    // 处理迭代器类型
    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild)
    }
  }

  // 处理文本节点
  if ((typeof newChild === 'string' && newChild !== '') || typeof newChild === 'number') {
    return placeSingleChild(
      reconcileSingleTextNode(returnFiber, currentFirstChild, `${newChild}`)
    )
  }

  // 处理删除操作
  return deleteRemainingChildren(returnFiber, currentFirstChild)
}
```

## 两轮遍历流程

### 第一轮遍历：可复用节点处理

```mermaid
flowchart TD
    A[开始遍历] --> B{Key & Type相同?}
    B -->|是| C[复用节点]
    B -->|Key相同 Type不同| D[创建新节点<br>标记旧节点删除]
    B -->|Key不同| E[结束第一轮遍历]
    C --> F[继续遍历下一个节点]
    D --> F
    E --> G[进入第二轮遍历]
```

**示例场景**：

```html
<!-- 更新前 -->
<ul>
  <li key="a">a</li>
  <li key="b">b</li>
  <li key="c">c</li>
  <li key="d">d</li>
</ul>

<!-- 更新后 -->
<ul>
  <li key="a">a</li>
  <li key="b">b</li>
  <li key="c2">c2</li> <!-- key改变 -->
  <li key="d">d</li>
</ul>
```

**处理流程**：

1. 处理 key="a"：key 和 type 相同 → **复用**
2. 处理 key="b"：key 和 type 相同 → **复用**
3. 处理 key="c" vs key="c2"：key 不同 → **结束第一轮遍历**

### 第二轮遍历：处理剩余节点

将剩余旧 FiberNode 存入 Map：

```javascript
const existingChildren = mapRemainingChildren(returnFiber, oldFiber)
```

遍历剩余 JSX 元素：

* 从 Map 中查找可复用节点
* 找到则移动复用
* 未找到则创建新节点
* 遍历结束后 Map 中剩余节点标记删除

**复杂场景示例**：

```html
<!-- 更新前 -->
<ul>
  <li key="a">a</li>
  <li key="b">b</li>
  <li key="c">c</li>
  <li key="d">d</li>
  <li key="e">e</li>
</ul>

<!-- 更新后 -->
<ul>
  <li key="a">a</li>
  <li key="b">b</li>
  <li key="e">e</li> <!-- 位置移动 -->
  <li key="f">f</li> <!-- 新增 -->
  <li key="c">c</li> <!-- 位置移动 -->
</ul>
```

**处理流程**：

1. 第一轮遍历处理前两个节点后中断
2. 剩余旧节点存入 Map：`{c, d, e}`
3. 遍历新节点：
   * key="e"：在 Map 中找到 → **移动复用**
   * key="f"：未找到 → **新建**
   * key="c"：在 Map 中找到 → **移动复用**
4. Map 中剩余 key="d" → **标记删除**

## 优化策略

### 1. 时间复杂度优化

React 的 Diff 算法时间复杂度为 $O(n)$，远优于传统树比较算法的 $O(n³)$，这得益于：

* 分层同级比较策略
* Key 机制快速定位节点

### 2. Key 的最佳实践

```jsx
// 推荐：稳定唯一标识
{ items.map(item => (
  <Item key={item.id} data={item} />
)) }

// 避免：数组索引作为key
{ items.map((item, index) => (
  <Item key={index} data={item} /> // 可能导致渲染问题
)) }
```

### 3. 批量更新机制

React 将多个状态变更合并为单次渲染，减少 DOM 操作次数：

```mermaid
sequenceDiagram
    participant User as 用户交互
    participant React as React
    participant DOM as 真实DOM

    User->>React: 触发多个状态更新
    React->>React: 批量处理更新
    React->>React: 执行Diff算法
    React->>DOM: 单次DOM更新
```

### 4. 节点类型优化

对于相同类型的组件，React 会递归比较子节点；对于不同类型的组件，则直接替换整棵子树。

## 总结与最佳实践

React 的 Diff 算法通过以下机制保证高性能：

1. **分层比较策略**：避免跨层级比较
2. **Key 机制**：精确识别节点变化
3. **两轮遍历**：平衡效率与准确性
4. **批量更新**：减少 DOM 操作次数

**开发建议**：

* 为列表项提供稳定唯一的 key
* 避免在渲染过程中改变组件类型
* 保持组件树结构稳定
* 使用 React.memo/PureComponent 减少不必要渲染

理解 Diff 算法的工作原理，有助于开发者编写高性能 React 应用，避免常见的性能陷阱，充分发挥 React 的渲染效能优势。

---

---
url: /czxBlog/article/vhpmovsm/index.md
---
# 移动端适配方案
## 背景

移动端设备由于不同品牌、不同机型，不同设备中，使用的不同浏览器，带来的一系列适配问题。在这些设备中，如何实现展示效果、交互的一致性，是比较头疼的问题。

## 发展

早期的适配方案五花八门。

在2015年双十一左右， 阿里前端团队 AmFe 分享了 `flexiable` 的移动端适配方案，在往后的几年中， `flexiable`成为了主流的移动端适配方案在各大移动端应用中使用。

随着技术的发展，CSS3的`viewport`越来越得到了更多的设备支持， 逐渐的可以直接使用 viewport 来作为 移动端适配方案，2017年左右开始步入开发者的视野。

后来 AmFe 宣布 推荐使用 `viewport` 方案代替 `flexible`，`viewport`方案逐渐成为主流适配方案。

## lib-flexible 方案介绍

### viewport

viewport 即浏览器窗口，在移动端设备中，viewport太窄，为了更好的服务于CSS，提供了 `visual viewport` 和 `layout viewport`

### 物理像素（physical pixel）

物理像素即设备像素，是显示设备中最微小的物理部件。

### 设备独立像素（density-independent pixel）

设备独立像素也称为 密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素，然后由系统转换为物理像素

### CSS像素（CSS pixel）

css像素是一个抽象单位，主要用在浏览器上，用来精确的度量Web页面上的内容。

一般情况下， CSS像素称为设备无关的像素，简称 `DIPs`

### 屏幕密度

屏幕密度是指一个设备表面上存在的像素密度，它通常已每英寸有多少像素来计算（`PPI`）

### 设备像素比（device pixel ratio）

简称 `DPR`，定义了物理像素和设备独立像素的对应关系

```html
设备像素比 = 物理像素 / 设备独立像素
```

### 简要说明

`flexiable` 通过hack手段，根据设备的dpr值相应改变 `<meta>` 标签中viewport的值：

```html
<!-- dpr = 1-->
<meta name="viewport" content="initial-scale=scale,maximum-scale=scale,minimum-scale=scale,user-scalable=no" />
<!-- dpr = 2-->
<meta name="viewport" content="initial-scale=0.5,maximum-scale=0.5,minimum-scale=0.5,user-scalable=no" />
<!-- dpr = 3-->
<meta
  name="viewport"
  content="initial-scale=0.3333333333,maximum-scale=0.3333333333,minimum-scale=0.3333333333,user-scalable=no"
/>
```

从而让页面达到缩放的效果，变相的实现页面的适配功能。

主要的思想：

1. 根据 `dpr`的值来修改 `viewport` 实现1px的线
2. 根据 `dpr`的值来修改 `html`的 `font-size`，从而使用rem实现等比缩放
3. 使用 `hack` 手段用`rem`模拟 `vw`的特性

### 使用

> github: <https://github.com/amfe/lib-flexible>

> px-to-rem: <https://www.npmjs.com/package/postcss-pxtorem>

## px-to-viewport 适配方案

`Flexiable` 是通过javascript 模拟 `vw`的特性，到今天未知，`vw`已经得到了众多浏览器的支持，完全可以考虑直接将`vw`单位用于我们的适配布局中。

在css level3 中，定义了和 viewport相关的四个单位，分别是 `vw`、`vh`、`vmin`、`vmax`。

* `vw`: viewport width 简写，1vw等于 `window.innerWidth` 的 `1%`
* `vh`： viewport height简写，1vh 等于 `window.innerHeight` 的 `1%`
* `vmin`：vmin的值是当前 vw和vh中较小值
* `vmax`： vmax的值是当前 vw和vh中较大值

![viewport](/images/viewport.png)

在一张 750px的设计稿中， 100vw=750px， 1vw=7.5px，通过公式即可转换px单位为vw单位，实现适配。

可以通过 postcss-px-to-viewport 来帮助实现自动转换

> github: [https://github.com/evrone/postcss-px-to-viewport](https://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.md)

### 适用vw适配页面的场景

1. 容器适配
2. 文本适配
3. 大于1px的边框、圆角、阴影
4. 内边距和外边距

---

---
url: /czxBlog/article/vpqgx0t7/index.md
---
# 谈谈微前端
微前端 是最近比较新兴的一个话题，它不具体指某个库某个框架，而是一个思想，一种概念，运用这种思想，
根据自身的需求，从而实现适用于自身的 微前端 。

> 本文根据最近我在公司内部举行的 微前端技术解决方案 分享而写。
> 提供的 微前端方案 也应用于公司内部的项目，并取得了良好的反馈，获得广泛好评。
> 本文不具体谈如何实现微前端，仅讲述微前端的概念，期望能够通过本文理解微前端。

## 前言

微前端 目前在行业内是一个新兴的思想。

诞生这个思想的背景是，在公司内部，常常会有一类项目，这类项目很大、很重，
涉及的业务内容多而杂，还涉及了跨部门共同维护，积累的庞大的技术债 等各种问题。
这类项目在维护成本上、部署成本上等，都会花费巨大的开销，前端开发人员对于维护这类项目，苦不堪言，
急需找到解决这类问题的方案。

基于这样的背景下，开始探讨 解决方案的可行性， 微前端 正是基于此 开始慢慢 出现在人们的视野中。

## 现状

### 发展历程

在 Web 的发展初期，还没有所谓的前端的概念，网页的内容也相对简单，大多仅涉及文字图片信息的展示和表单内容，
这些工作可能网站负责人自己就包办了。
然后微软推出了 **Ajax** 技术，引起了网页的技术变革，从此网站开始具备了动态交互性，
能够在网页发起请求动态获取服务器的内容，这丰富了网页的可交互性，网页的开发也从UI界面和表单交互，进一步增加了
数据和逻辑的开发，前端也慢慢的被划分一个相对独立的职能。

而伴随着 nodejs 的出现，以及 angular 的出现，还包括 vue/react 等库，以及建立在 nodejs 上的生态，
包括grunt、gulp、webpack 等工具的诞生，前端进入了一个喷井式爆发的时期，也是我们所处的时期。前端越来越专业化，
包含的技术内容越来越丰富，依托于nodejs 以及众多的技术框架等，向着工程化进一步的发展，前端项目也越来越大。

### 浮现的问题

你是否维护过一个可能有着四五年以上历史的项目？是否维护过一个糅杂了各种各样的库的项目？
是否维护过一个多个公司部门参与的跨团队联合开发的项目？

对于很多人来说，入职的某个公司，最怕被安排去维护一个这样的项目。因为每一次维护迭代，就如同开盲盒一样，
永远不知道有什么惊喜在等着自己。

对于这类项目，可能存在的问题包括：

* 跨部门，夸团队联合开发，如何沟通？如何协作？
* 业务线多，页面多，如何管理？
* 如何进行代码管理？
* 如何进行分支管理？
* 多部门进行迭代，如何把控版本？
* 存在发布冲突，如何解决？
* 如何进行测试？
* 如何管理公共代码？
* ...

可能改动某一行代码，都会带来意想不到的结果，种种问题的积累，技术债的、业务债的，使得项目越来越臃肿，越来越难以维护。

亟需寻找一种方案，能够解决这些问题。

### iframe嵌入

于是，在大多数时候，我们不得不去选择通过 iframe嵌入 的方式，先把臃肿的项目一点一点的拆开给回各个部门或者团队自行维护，
再提供一个 系统门户应用，用 iframe嵌入 的方式，加上维护一个菜单列表与其他项目入口链接的映射，来糅合成一个 网站应用。

![iframe嵌入](//assets.processon.com/chart_image/630f92445653bb0c5d1040ab.png)

通过 iframe嵌入，在一定程度上，满足了 各部门各团队各业务线 独立开发独立部署的需求，只需要提供对应的页面链接就可以接入到
整个系统中。但也存在着一些问题

#### 安全问题

然而，我们知道， iframe是存在安全问题的，如果攻击者使用 iframe访问一个 未知来源的链接，有可能被注入恶意脚本，从而盗取
系统的隐私信息，这需要我们去严格配置 SCP，以及配置 sandbox，尽可能的保证 iframe 的安全性。

#### 资源加载过多

而由于仅需要提供链接就可以嵌入，那么对于各自的项目来说，灵活度就很高，各个项目可以随意的选择各种技术框架来实现自己的业务，
又或者即使使用了相同的技术框架，但各项目的资源相对独立，对于整个系统而言，需要加载的资源量会十分庞大，
从而导致了页面访问速度变慢，经常会出现页面部分区域白屏等待时间过长等，这也带来了体验问题。

#### 访问地图丢失

由于 iframe 嵌入的站点，独享访问历史记录，与外部的历史记录是相互独立的，即通过浏览器的 前进/回退 按钮来访问历史记录并
不能得到预期的结果，这在一定程度上影响了用户的操作。

## 寻找解决方案

有没有什么其他的方案，来进一步解决这些问题呢？

首先我们明确的知道，单项目管理目前来看不是一个可行的方案，需要在多项目管理上寻求解决方案。

### 多项目公共业务组件

对于多数的大型系统项目而言，大体上都采用以下布局结构：

![微前端-2](//assets.processon.com/chart_image/6311781d079129320755bec5.png)

主体布局结构包括：

* 导航栏 （可选）
* 左侧菜单栏 （可选）
* 内容区域
* 页脚 (可选)

在这种布局结构下，各个业务板块通常通过 导航栏 或者 左侧菜单栏 进行 导航切换，在 内容区域 展示 业务板块。
即，总体上看，对于业务来说，导航栏、左侧菜单栏、页脚，这几个都是可能 共同的，主要的不同点在于 内容区域。

那么我们可以把 共同的部分，如 导航栏、左侧菜单栏、页脚 这几个部分，抽离为公共业务组件，
对于每个业务板块，独立为单独的项目进行开发维护，并在项目中引入这些 公共业务组件。
公共业务组件其中主要负责之一是提供 链接到各个业务板块。

![微前端-3](//assets.processon.com/chart_image/631301e65653bb40f833b613.png)

这种方案具有如下的优点：

* 整体系统根据业务板块拆分为了多个项目；
* 实现了项目的独立性，可独立进行开发、发布；
* 通过在主项目重载渲染，实现类似 **SPA应用** 的访问体验；

但同样也带来了新的问题：

* 公共业务组件

  * 公共业务组件 如何进行管理；
  * 公共业务组件 如何在业务板块项目之间保持同步更新；

以及没有解决的问题：

* 资源加载过多；

  各个业务板块项目重复加载公共业务组件，重复加载各种库资源。

* 项目无法实现统一管理；

### 主项目重载业务项目资源

在上一个方案中，公共业务组件的引入解决了一部分问题，也带来了一部分问题，如何把公共业务组件进行统一管理，并保持一致性？

我们回到 iframe方案，在这个 iframe方案中，有一个主项目用于管理这些 菜单栏、导航栏等。 同样的，可以借鉴这个思路，
也抽象一个主项目，用于管理这些 公共业务组件，然后寻找另一种方式来加载渲染其他的业务板块项目。

我们知道，业务板块的项目，也是通过链接去访问的，而每个链接都对应着一个 html 资源文件，通过加载这个资源，以及HTML内的 css资源、js资源等来渲染页面。那么，我们可以通过解析这个 html资源，然后将得到的 html内容、css文件、js文件，在主项目中加载后渲染到特定的区域，
那么就可以做到在主项目中加载业务板块项目。

![微前端-4](//assets.processon.com/chart_image/6314ea9cf346fb55d89d4e77.png)

在主项目中，实现一个 资源加载器与解析器，通过业务板块项目的访问链接，获取 html资源文件，并解析 html 的内容，包括：

* `<head>` 标签中的 `<title>`, `<link>`, `<script>` 等;
* `<body>` 标签中的 html 内容，`<script>` 等

然后加载 解析得到的 CSS资源、JS资源，将 html内容 插入到 特定的区域中，并进行渲染。
从而呈现完整的网页内容。

这种方案，进一步解决了如下的问题：

* 公共业务组件交由 主项目进行统一管理，直接避免了同步问题；
* 业务板块均在主项目中渲染，提高了用户体验；

然而，也引入了新的问题：

* 业务板块都运行在同一个环境中，多个板块之间切换，加载的资源容易对环境产生污染，
  如污染了某个全局变量、polyfill相互污染等。
* 可能存在 加载资源跨域问题。

但是也拥有了如下的优点：

* 拆分项目，可独立开发和部署；
* 主项目统一管理 公共业务组件，更易于维护；
* 项目间的切换得到体验优化；

当方案思考到了这里，发现，主项目是通过 解析 **链接** 来加载业务板块项目，
而 **链接** 对于现代前端来说，更多的意义是可能是 **路由**。那么我们顺着这个思路，继续优化，

## 新的方案

说起路由，我们很容易想到，像如今的 `react`, `vue`, `angular` 等主流的库/框架， 通过 路由 来实现 `SPA` 应用，
或者说， 通过 **路由分发页面**。

那么，我们可以进一步的扩展这个思路，是否可以通过 **路由分发应用** ？

### 路由

在前端的范畴中，路由指 随着浏览器的地址栏变化，而呈现不同的内容给用户。

通常使用 **hash** 或者 **history API** 实现前端路由。

```js
// hash
;`https://chongzhenxiang.com/#route` // history API
;`https://chongzhenxiang.com/route`
```

路由进一步细化，通过 `/` ，又可以 划分为 一级路由、二级路由、三级路由... 等多级路由。

在现代的前端框架如 `React` / `Vue` / `Angular` 等，均有通过 路由 实现 SPA应用 的技术方案。
而 SPA应用 就是 **路由分发页面** 。

### 路由分发应用

与 **路由分发页面** 类似，我们也可以通过 **路由分发应用** 。

类似于 主项目重载业务项目资源，通过 实现 路由与业务板块项目的映射关系，
在主项目中通过路由寻找业务板块项目，加载相关资源并渲染在相关区域。

### 主应用与子应用

从这里开始， 我们将 主项目 定位为 主应用， 将各个 业务板块项目 定义为 子应用。
在主应用中实现 子应用加载器，加载器通过 解析路由来获取加载对应的子应用。

**主应用：** 作为独立的项目，整个系统的入口应用，负责统一管理公共业务组件（如 菜单栏、导航栏、页脚等），负责实现子应用加载器，负责实现渲染子应用的容器。

**子应用：** 作为独立的项目，系统的各个业务板块分别独立为单独的项目，单独开发维护与部署。

### 注册子应用

主应用需要通过路由发现子应用，需要建议起 路由与子应用的映射关系，所以需要有一套机制，用于向主应用注册子应用，
并关联相关资源文件等。

```json
[
  {
    "AppName": "Sub Application",
    "route": "/sub-app-route",
    "resource": {
      "js": ["https://example.com/index.js"],
      "css": ["https://example.com/style.css"]
    }
  }
  // more ...
]
```

## 微前端

通过将整个系统拆分为一个个小型的项目，小型项目即为子应用，通过细化，将整个系统细化为一个个微小的应用，
从而实现了降低整个系统的复杂性。
一个小型项目可以是某个部门的业务项目，可以是某个业务项目中的某个板块，也可以是一个单独的页面。

这也是为什么将新的方案称之为 **微前端**。

微前端是指，通过将一个系统，拆分为一个个 微小的独立的子应用，通过主应用聚合为一个完整的系统。
微前端是一个与框架无强关联的概念，可以类比于服务端的微服务，是浏览器端的微服务。

![microfront](//assets.processon.com/chart_image/6318b7297d9c0833ec81b2cd.png)

由于子应用是独立的，理论上是支持使用任意的技术框架进行开发，无论是使用 jQuery开发，还是使用 Vue、React、Angular等。
然而在实际中，对于整个系统而言，技术框架的选择应该保持统一性，以保证整个系统的可维护性。

## 微前端的局限性

微前端的技术方案，更适合于 中大型的项目中使用，而对于小型项目而言，由于本身体量不大，没有必要对整个系统进行进一步的细化，
细化反而增加了项目的复杂度。

而对于中大型项目而言，如果是老系统迁移到微前端的方案，那么不可避免的，还需考虑新旧方案之间的迁移过渡的方案以及规划。
如果老系统中存在应用了多种不同的技术框架，或者同框架的不同版本，由于主应用、所有子应用均运行在同一个浏览器环境中，
不可避免的存在环境污染问题，如全局环境污染，polyfill对于原生对象的多次污染等，还包括CSS的命名污染等问题。
所以如何保证子应用的正确渲染，如何避免环境污染问题，也是亟需解决的问题。

## 微前端的未来

目前来看，微前端主要分为 主应用 和 子应用，在 **微** 上，也仅细化到页面级别，然而，对于微前端而已，还可以进一步的细化，
如，细化到页面的某一个区块，细化到某一个逻辑功能，均可以通过微前端的技术方案，共享到主应用以及子应用中使用。
整个系统愈加化整为零，将复杂度进一步的拆解，细化，令每一块功能、逻辑等都能使用通过某个项目提供，甚至独立的项目进行维护和部署。

微前端是一个与框架无关的概念，但在实现微前端时，如果允许多技术框架共存，所带来的问题的，反而比不使用微前端时所存在的问题，要更难以预料，难以解决。在实际的场景中，最好还是限定在统一的技术框架范畴中，避免由于共存不同的技术框架，而引入更为复杂的问题，

## 结语

微前端是一个相对新兴的技术概念，适用于一些前端场景，但最好是你已经考虑清楚了，微前端是解决你的场景问题的最好方案，否则，除非必要，
无需选择微前端方案。

---

---
url: /czxBlog/article/xb4woxjg/index.md
---
# 有用的工具列表
## 浏览器插件

* [Vue.js devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?) 顾名思义，非常有用的浏览器 vue开发调试插件
* [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi) React 开发调试插件
* [Octotree - GitHub code tree](https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc) 对github仓库的文件tree生成侧边栏，方便在线查阅浏览/跳转
* [XPath Helper](https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl) 提取当前网站选中的 DOM 元素的 XPath，做埋点测试之类时有用

## cli开发

* [commander](https://www.npmjs.com/package/commander) 完整的命令行解决方案
* [cac](https://www.npmjs.com/package/cac) 轻量级的用于构建cli工具的解决方案

***

* [minimist](https://www.npmjs.com/package/minimist) 命令行参数解析工具
* [yargs](https://www.npmjs.com/package/yargs) 命令行参数解析工具

***

* [Inquirer](https://www.npmjs.com/package/inquirer) 交互式命令行工具
* [prompt](https://www.npmjs.com/package/prompt) 命令行 对话工具

***

* [shelljs](https://www.npmjs.com/package/shelljs) shell调用工具

* [execa](https://www.npmjs.com/package/execa) shell 调用工具

* [chalk](https://www.npmjs.com/package/chalk) node终端输出美化工具

* [ora](https://www.npmjs.com/package/ora) 终端 loading 工具

* [chokidar](https://www.npmjs.com/package/chokidar) 文件监听工具

* [is-ci](https://www.npmjs.com/package/is-ci) 检查当前环境是否是集成环境

## Http server

* [express](http://expressjs.com/)
* [connect](https://github.com/senchalabs/connect)
* [koa](https://koajs.com/)
* [fastify](https://www.fastify.io/)

## Server Framework

* [Nestjs](https://nestjs.com/) 类Spring boot的 Node端开发框架

* [Next.js](https://nextjs.org/) React 应用开发框架

* [Nuxt.js](https://nuxtjs.org/) Vue 应用开发框架

* [Think.js](https://thinkjs.org/) Node端开发框架

* [Egg.js](https://www.eggjs.org/index) 阿里开源的Node端开发框架

## VSCode 插件

### 皮肤

* [One Dark Pro](https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme) 个人觉得非常耐看，好用，舒服的一个皮肤。
* [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme) 非常全面又好看的文件图标主题

### 辅助开发

* [IntelliCode](https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode) 辅助代码提示
* [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker) 拼写检查插件
* [Error Lens](https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens) 用更友好更直观的方式，将错误信息显示出来
* [Better Comments](https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments) 更加友好的注释高亮
* [Bracket Pair Colorizer](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer) 代码缩进高亮
* [Import Cost](https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost) 显示包体积
* [Todo Tree](https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree) TODO注释高亮
* [indent-rainbow](https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow) 缩进高亮标识
* [Path Intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense) 文件路径提示
* [TypeScript Hero](https://marketplace.visualstudio.com/items?itemName=rbbit.typescript-hero) typescript 辅助开发工具

***

* [any-rule](https://marketplace.visualstudio.com/items?itemName=russell.any-rule) 正则表达式大全

***

* [Rest Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client) 类 Postman 的 Rest工具

## 测试工具

### assertion

* [chai](https://www.npmjs.com/package/chai)
* [should](https://www.npmjs.com/package/should)

### unit

* [jest](https://www.npmjs.com/package/jest)
* [ava](https://www.npmjs.com/package/ava)
* [mocha](https://www.npmjs.com/package/mocha)
* [karma](https://www.npmjs.com/package/karma)
* [tape](https://www.npmjs.com/package/tape)
* [@vue/test-utils](https://www.npmjs.com/package/@vue/test-utils)

### 2e2

* [nightwatch](https://www.npmjs.com/package/nightwatch)
* [cypress](https://www.npmjs.com/package/cypress)

## GIT相关

* [@commitlint/cli](https://www.npmjs.com/package/@commitlint/cli)
* [@commitlint/config-conventional](https://www.npmjs.com/package/@commitlint/config-conventional)
* [commitizen](https://www.npmjs.com/package/commitizen)
* [conventional-changelog-cli](https://www.npmjs.com/package/conventional-changelog-cli)
* [cz-conventional-changelog](https://www.npmjs.com/package/cz-conventional-changelog)
* [husky](https://www.npmjs.com/package/husky)
* [lint-staged](https://www.npmjs.com/package/lint-staged)

## 其他

* [Slidev](https://github.com/slidevjs/slidev) 为开发者打造的演示文稿工具
* [loupe](http://latentflip.com/loupe/) 代码执行流程可视化

---

---
url: /czxBlog/article/xhb2iacu/index.md
---
# 前端路由
在现代前端中，SPA应用是一种主流的前端应用交互方案，其中，前端路由是实现SPA应用的关键技术之一。

## 路由

**路由（Router）** 一般指的是 URI 中 pathname + basename + hash + query 所组成的 路径。

在前端中， **路由** 一般指的是 **随着浏览器中的地址栏的变化，呈现不同的内容给用户**。
浏览器地址栏的变化，即是 访问链接的变化，具体指的就是 pathname + basename + hash + query 部分的变化。

示例：

```
/a/b
/a/b/#/hash
/a/b/#/hash?c=1
```

对于前端路由，一般会选择 监听 hash 部分的变化， 或者监听 pathname 部分的变化，从而一般有两种路由模式：

### hash 模式

通过监听 地址栏中 hash 部分的变化，从而呈现不同的内容。

::: center
**<https://example.com/index.html> ==#/a/b/==**
:::

在浏览器中，通过注册 **hashchange** 事件，监听 **hash** 变化。

```js
window.addEventListener('hashchange', () => {
  const hash = window.location.hash
  console.log(hash) // #/a/b/
})
```

通过 hash 实现路由的优势在于， hash 仅依赖于浏览器，且hash的变化不会直接导致页面刷新，天然适合于实现 前端路由。

### history 模式

通过监听 地址栏中 pathname 部分的变化，从而呈现不同的内容。

history模式是依赖于 浏览器端的 History API 而实现。
History API 允许我们对浏览器会话历史记录进行访问并操作。

::: center
**<https://example.com> ==/a/b/==**
:::

History API 通过 history.pushState() 和 history.replaceState() 方法，新增或者替换历史记录，
通过 popState 事件监听历史记录的变化。

直接操作历史记录的变化，结果会改变浏览器地址栏的显示内容，但不会引起浏览器刷新页面。
但是由于变化的部分一般是 `pathname + basename` 的部分，如果手动刷新页面，可能会导致浏览器通过当前路径
向服务器发起请求找不到对应的资源而返回404，所以一般需要在服务器端的HTTP服务器进行配置，将相关的路径请求资源，
都指向同一个html资源文件。

> [History API](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API)

### 其他模式

除了上述两种一般用于浏览器端中的路由模式，为了满足其他的场景，比如 在SSR场景下，需要在服务端模拟路由在生成页面内容，
或者在 electron 桌面应用中。一般会基于 memory 实现一种 仅通过 memory 的变化的路由的模式。

在这个模式中，通过一个普通的 JavaScript 字符串或者对象，来实现模拟 路由路径地址以及相关功能。

## Router解析

前端路由在不同的库或者框架中实现，一般会采用一套通用的解析规则，在实现细节上有所差异。

一个路由地址，一般包含如下几个部分：

* **path** 表示路由的路径
* **params** 表示路由的路径动态匹配结果
* **query** 表示路由携带的参数，未解析前为 queryString, 解析后为 queryObject

如一个 路由地址： `/a/b/?c=1` 中， `/a/b/` 部分一般称为 **path** ， `?c=1` 部分一般被称为 `query`。

### 具名路由

具名路由，也称 静态路由 指在声明一个路由时，对地址栏路径地址使用 全等匹配，仅当声明的路由与路径地址全等时，才命中路由。

```js
// 浏览器地址栏： https://example.com/a/b/
// 声明路由：
const routes = [
  {
    path: '/a/b', // 命中当前路由
  },
  {
    path: '/a/c', // 不一致，未命中
  },
  {
    path: '/a', // 不一致，未命中
  },
  {
    path: '/a/b/c', // 不一致，未命中
  },
]
```

### 路由匹配

路由匹配，指通过 一套匹配规则，对地址栏路径地址 进行 规则匹配，当命中匹配规则时，则命中路由。
一般场景下， 通过 `/:pathname` 的格式来表示路由路径中的动态部分。

如 `/user/:id`， 则可以匹配 `/user/123`，`/user/456` 等满足规则的地址栏路径。

`/:pathname` 部分会被解析到 `params` 对象中，如上述的 通过`/user/:id`规则解析 `/user/123`，表示为：

```js
const currentRoute = {
  path: '/user/123',
  params: { id: 123 },
}
```

### 其他

在不同的框架或库中， 对路由解析会在基于上述的规则的基础上，进行补充和扩展，提供更加丰富的功能，以满足更多的场景。

比如， **Vue-Router** 使用了 `path-to-regexp` 库作为其路由解析的依赖，该库提供了非常丰富且灵活的路径匹配功能，
能够适配非常多的从简单到复杂的场景。**React-Router** 则在其内部实现了和扩展了相关的规则。

---

---
url: /czxBlog/article/z7btimbk/index.md
---
# 玩转 CSS @property
`@property` CSS at-rule是 [CSS Houdini API](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Houdini)
的一部分，它允许开发者显式地定义他们的 [CSS 自定义属性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/--*),
允许进行属性类型检查、设定默认值以及定义该自定义属性是否可以被继承。

`@property` 的出现，极大的增强了 CSS 的能力。

::: info CSS Houdini
`CSS Houdini` 开放 CSS 的底层 API 给开发者，使得开发者可以通过这套接口自行扩展 CSS，并提供相应的工具允许开发者介入浏览器渲染引擎的样式和布局流程中，使开发人员可以编写浏览器可以解析的 CSS 代码，从而创建新的 CSS 功能。
:::

***

通常情况下，我们定义和使用一个 CSS 自定义属性是这样的：

```css
:root {
  --c-red: #fff;
}

p {
  color: (--c-red);
}
```

而有了 `@property` 规则，我们可以这样做：

```css
@property --c-red {
  syntax: '<color>';
  inherits: false;
  initial-value: #f00;
}

p {
  color: var(--c-white);
}
```

效果：

:::: demo 代码演示

::: code-tabs
@tab HTML

```html
<p class="css-vars">这是使用 css vars 定义的文字颜色</p>
<p class="css-property">这是使用 css @property 定义的文字颜色</p>
```

@tab CSS

```css
.css-vars {
  --c-red: #f00;
  color: var(--c-red);
}
@property --p-red {
  syntax: '<color>';
  inherits: false;
  initial-value: #f00;
}
.css-property {
  color: var(--p-red);
}
```

:::
::::

## @property

`@property` 规则提供了一个直接在样式表中注册自定义属性的方式，而无需运行任何 JS 代码。
有效的 `@property` 规则会注册一个自定义属性，就像 `CSS.registerProperty` 函数被使用同样的参数调用了一样。

### 语法

```css
@property <custom-property-name> {
  syntax: <string>;
  inherits: <boolean>;
  initial-value: <declaration-value>;
}
```

* `<custom-property-name>`: 自定义属性名，定义后可在 CSS 中通过 `var(<custom-property-name>)` 进行引用。
* syntax：该自定义属性的语法规则，也可以理解为表示定义的自定义属性的类型。
* inherits：该自定义属性是否可以被继承。
* initial-value：该自定义属性的初始值。

一个有效的 `@property` 规则代表一项自定义属性的注册，使用自定义属性名作为规则内代码序列的序部。

`@property` 规则中 `syntax` 和 `inherits` 描述符是必需的;
如果其中任何一项缺失，整条规则都将失效并且会被忽略。
`initial-value` 描述符仅在 `syntax` 描述符为通用 `syntax` 定义时是可选的，
否则 `initial-value` 也是必需的——如果此时该描述符缺失，整条规则都将失效且被忽略。

未知的描述符自身都是无效的，且会被忽略。但是不会造成整条 `@property` 规则的失效。

### syntax语法类型

* `<length>` : 任何有效的 length 值， 如 `12px`， `12rem` 等。
* `<number>` : 任何有效的 number 值， 如 `12`， `12.5`, `-12` 等。
* `<percentage>` : 任何有效的 percentage 值， 如 `12%` 等。
* `<length-percentage>` : 任何有效的 length-percentage 值， 如 `12px` 或 `12%` 等。
* `<color>` : 任何有效的 color 值， 如 `#fff` 或 `rgb(255, 255, 255)` 等。
* `<image>` : 任何有效的 image 值, 如 `url('foo.png')`，或 `linear-gradient(red, blue)` 等。
* `<url>` : 任何有效的 url 值， 如 `url('foo.png')` 等。
* `<integer>` : 任何有效的 integer 值， 如 `12` 等。
* `<angle>` : 任何有效的 angle 值， 如 `12deg` 等。
* `<time>` : 任何有效的 time 值， 如 `12s` 等。
* `<resolution>` : 任何有效的 resolution 值， 如 `12dpi` 等。
* `<transform-function>` : 任何有效的 transform-function 值， 如 `rotate(12deg)` 等。
* `<custom-ident>` : 任何有效的 custom-ident 值， 如 `foo` 等。

### syntax语法符号

`syntax` 支持 `+`、`#`、`|` 符号， 用于接收特殊的类型定义。

* `syntax: '<color#>'` : 接受逗号分隔的颜色值列表
* `syntax: '<length+>'` ：接受以空格分隔的长度值列表
* `syntax: '<length | length+>'`：接受单个长度或者以空格分隔的长度值列表

## 示例

在了解完 `@property` 规则之后，我们来看一些例子。

### 渐变过渡效果

通常我们实现一个渐变图案的代码如下：

::::demo title="渐变图案"
::: code-tabs

@tab HTML

```html
<div class="gradient"></div>
```

@tab CSS

```css
.gradient {
  width: 150px;
  height: 150px;
  margin: auto;
  background: linear-gradient(45deg, #f66, #ff0);
}
```

:::
::::

我们改造一下代码，使用 自定义属性实现，并尝试通过修改自定义属性，实现渐变过渡效果：

:::: demo title="自定义属性"
::: code-tabs

@tab HTML

```html
<div class="gradient"></div>
<p>鼠标悬停到方块中查看效果</p>
```

@tab CSS

```css
.gradient {
  --color-1: #f66;
  --color-2: #ff0;
  width: 150px;
  height: 150px;
  margin: auto;
  background: linear-gradient(45deg, var(--color-1), var(--color-2));
  transition: background 1s;
}
.gradient:hover {
  --color-1: #fcc;
  --color-2: #606;
}
```

::::

可以看到，虽然我们使用 `transition` 添加了 过渡动画，在 `hover` 时修改了 自定义属性。
当我们把鼠标移动到 `.gradient` 上时，并没有渐变过渡动画效果，我们只是得到了 两侦之间的变化。

#### 使用 @property 进行改造

现在，我们把使用 `@property` 替换 CSS 自定义属性：

```css
@property --houdini-color-1 {
  syntax: '<color>';
  inherits: false;
  initial-value: #f66;
}

@property --houdini-color-2 {
  syntax: '<color>';
  inherits: false;
  initial-value: #ff0;
}
```

使用了 @property 语法，定义了两个 CSS Houdini 自定义变量 `--houdini-color-1` 和 `--houdini-color-2`，在 hover 变化的时候，改变这两个颜色。

同时， 修改 `transition` 语句，**不再是对`background` 进行过渡，而是对`--houdini-color-1` 和 `--houdini-color-2` 进行过渡**。

:::: demo title="自定义属性" desc="鼠标悬停到方块中查看效果"
::: code-tabs

@tab HTML

```html
<div class="gradient"></div>
```

@tab CSS

```css
@property --houdini-color-1 {
  syntax: '<color>';
  inherits: false;
  initial-value: #f66;
}

@property --houdini-color-2 {
  syntax: '<color>';
  inherits: false;
  initial-value: #ff0;
}

.gradient {
  width: 150px;
  height: 150px;
  margin: auto;
  background: linear-gradient(45deg, var(--houdini-color-1), var(--houdini-color-2));
  transition:
    --houdini-color-1 1s,
    --houdini-color-2 1s;
}
.gradient:hover {
  --houdini-color-1: #fcc;
  --houdini-color-2: #606;
}
```

:::
::::

可以看到， 渐变过渡动画效果成功了！

由此，我们可以实现更加复杂的渐变过渡效果：

:::: demo title="渐变过渡动画"
::: code-tabs

@tab HTML

```html
<div class="bg-animate"></div>
```

@tab CSS

```css
@property --an-color-1 {
  syntax: '<color>';
  inherits: false;
  initial-value: fuchsia;
}
@property --an-color-2 {
  syntax: '<color>';
  inherits: false;
  initial-value: #f79188;
}
@property --an-color-3 {
  syntax: '<color>';
  inherits: false;
  initial-value: red;
}

.bg-animate {
  width: 150px;
  height: 150px;
  margin: auto;
  background: linear-gradient(45deg, var(--an-color-1), var(--an-color-2), var(--an-color-3));
  animation: change 10s infinite linear;
}
@keyframes change {
  20% {
    --an-color-1: red;
    --an-color-2: #a93ee0;
    --an-color-3: fuchsia;
  }
  40% {
    --an-color-1: #ff3c41;
    --an-color-2: #e228a0;
    --an-color-3: #2e4c96;
  }
  60% {
    --an-color-1: orange;
    --an-color-2: green;
    --an-color-3: teal;
  }
  80% {
    --an-color-1: #ae63e4;
    --an-color-2: #0ebeff;
    --an-color-3: #efc371;
  }
}
```

:::
::::

### 复杂背景动画

我们通过代码实现一个复杂的 渐变图案背景：

:::: demo title="复杂背景"
::: code-tabs

@tab HTML

```html
<div class="bg"></div>
```

@tab CSS

```css
.bg {
  width: 100%;
  height: 350px;
  background-image: radial-gradient(
      circle at 86% 7%,
      rgba(40, 40, 40, 0.04) 0%,
      rgba(40, 40, 40, 0.04) 50%,
      rgba(200, 200, 200, 0.04) 50%,
      rgba(200, 200, 200, 0.04) 100%
    ), radial-gradient(
      circle at 15% 16%,
      rgba(99, 99, 99, 0.04) 0%,
      rgba(99, 99, 99, 0.04) 50%,
      rgba(45, 45, 45, 0.04) 50%,
      rgba(45, 45, 45, 0.04) 100%
    ), radial-gradient(
      circle at 75% 99%,
      rgba(243, 243, 243, 0.04) 0%,
      rgba(243, 243, 243, 0.04) 50%,
      rgba(37, 37, 37, 0.04) 50%,
      rgba(37, 37, 37, 0.04) 100%
    ), linear-gradient(#6cc, #09c);
}
```

:::
::::

如果我们想让它动起来，如果不是用 `@property`，可能要废一番功夫，但是，在 `@property` 的支持下，
我们可以实现不错的动画效果：

:::: demo title="复杂背景动画"
::: code-tabs

@tab HTML

```html
<div class="bg"></div>
```

@tab CSS

```css
@property --per-1 {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 75%;
}

@property --per-2 {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 99%;
}

@property --per-3 {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 15%;
}

@property --per-4 {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 16%;
}

@property --per-5 {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 86%;
}

@property --angle {
  syntax: '<angle>';
  inherits: false;
  initial-value: 0deg;
}

.bg {
  width: 100%;
  height: 350px;
  background-image: radial-gradient(
      circle at var(--per-5) 7%,
      rgba(40, 40, 40, 0.04) 0%,
      rgba(40, 40, 40, 0.04) 50%,
      rgba(200, 200, 200, 0.04) 50%,
      rgba(200, 200, 200, 0.04) 100%
    ), radial-gradient(
      circle at var(--per-3) var(--per-4),
      rgba(99, 99, 99, 0.04) 0%,
      rgba(99, 99, 99, 0.04) 50%,
      rgba(45, 45, 45, 0.04) 50%,
      rgba(45, 45, 45, 0.04) 100%
    ), radial-gradient(
      circle at var(--per-1) var(--per-2),
      rgba(243, 243, 243, 0.04) 0%,
      rgba(243, 243, 243, 0.04) 50%,
      rgba(37, 37, 37, 0.04) 50%,
      rgba(37, 37, 37, 0.04) 100%
    ), linear-gradient(#6cc, #09c);
  animation: move 30s infinite alternate linear;
}
@keyframes move {
  100% {
    --per-1: 85%;
    --per-2: 49%;
    --per-3: 45%;
    --per-4: 39%;
    --per-5: 70%;
    --angle: 360deg;
  }
}
```

:::
::::

## 参考

* [MDN CSS Properties and Values API](https://developer.mozilla.org/zh-CN/docs/Web/API/CSS_Properties_and_Values_API)
* [CSS Houdini API css-properties-values-api](https://drafts.css-houdini.org/css-properties-values-api/#syntax-strings)

---

---
url: /czxBlog/build-tools/webpack/index.md
---
# webpack 指南

---

---
url: /czxBlog/build-tools/webpack/what-is-webpack/index.md
---
# 什么是 webpack ?
本质上，**webpack** 是一个用于现代 JavaScript 应用程序的 ==静态模块打包工具=={.important}。

当 **webpack** 处理应用程序时，它会在内部从一个或多个入口点构建一个 **依赖图(dependency graph)** ，
然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。

## Webpack 解决了什么？

在复杂的前端项目中，我们会面临诸多挑战：

* **模块化开发**： 现代前端使用 ES Modules、CommonJS 等将代码拆分为小模块。浏览器对原生 ES Modules 的支持虽在提升，但在兼容性、性能（大量 HTTP 请求）上仍有不足。
* **资源多样性**： 项目不仅需要 JavaScript，还包括 CSS（Sass/Less）、图片、字体、HTML 模板等，浏览器无法直接处理非 JS 资源。
* **代码优化**： 未压缩的代码体积庞大；重复代码；未使用的代码（Dead Code）影响性能。
* **开发效率**： 手动管理依赖、刷新浏览器、等待构建缓慢。
* **兼容性**： 需要使用新语法（ES6+、JSX、TypeScript）但需确保在旧浏览器中运行。

**Webpack 的核心价值正是优雅地解决上述问题！**

## webpack 工作流程

* **初始化**： 读取配置，创建 Compiler 实例，加载插件。
* **开始编译**： 从配置的 **entry** 开始，调用 Compiler 的 `run` 方法启动编译。
* **确定依赖**： 从入口文件开始，对遇到的每一个 `import/require` 语句，解析模块路径，**递归** 地构建项目的依赖图(Dependency Graph)。
* **Loader 处理**： 对依赖图中的每个模块（文件），根据 `module.rules` 配置，使用匹配的 Loader 进行转换（如 TS -> JS, SCSS -> CSS -> JS 可处理字符串）。
* **编译模块**： 经过 Loader 转换后的模块内容，被解析为 **AST 语法树**，分析其依赖关系和导出内容。
* **生成 Chunks**： 将处理好的模块及其依赖，根据配置（入口点、动态导入、SplitChunksPlugin 优化策略）组合成 **Chunk(s)**。一个 Bundle 通常对应一个 Chunk（但可通过代码分割有多个）。
* **输出资源**： 根据 `output` 配置，将每个 Chunk 转换为最终的输出文件（Bundle）。在这个过程中，插件可以介入执行特定任务（如生成 HTML、压缩代码、拷贝静态文件等）。
* **完成**： 所有 Chunks 和 Assets 输出到目标目录，构建结束。

```mermaid
graph LR
    A[入口 Entry] --> B[解析依赖图]
    B --> C[Loader 转换模块]
    C --> D[编译模块 AST]
    D --> E[生成 Chunks]
    E --> F[应用插件 Plugin]
    F --> G[输出 Bundles]
```

## Webpack 带来的核心优势

* **模块化打包**： 解决依赖管理和浏览器加载问题，将碎片化模块打包成少量高效资源。

* **万物皆模块**： 通过 Loader，任何资源都能像 JS 模块一样被导入和使用 (import './style.css')。

* **强大的预处理/转换能力**： 利用 Loader 链，支持 Babel (ES6+/JSX/TS)、Sass/Less、PostCSS 等现代开发工具链。

* **高度可扩展性**： 庞大的 Plugin 生态系统覆盖开发、优化、部署等全生命周期需求。

* **开发效率提升**：

  * **开发服务器(webpack-dev-server)**: 提供热更新(HMR)，文件修改后局部刷新，保持应用状态。
  * **Source Map**: 调试打包后的代码如同调试源代码。

* **生产环境优化**：

  * **代码压缩/混淆(TerserPlugin)**: 减小文件体积。
  * **Tree Shaking**: 移除未使用的 JS 代码 (ES Module 静态结构)。
  * **Code Splitting / Lazy Loading**: 拆分代码，按需加载，提升首屏速度。
  * **Scope Hoisting**: 提升作用域，减少闭包，优化运行速度。
  * **文件哈希命名**： 利用缓存策略提升加载性能。

## Webpack 在现代前端中的地位

尽管时下其它工具如 Vite 在开发体验（利用原生 ESM）上带来了革新，
Webpack 凭借其 **无与伦比的成熟度、稳定性、灵活性和极其丰富的生态系统**，依然是：

* 大型复杂项目的首选： 其配置的深度和 Plugin 生态能应对极其复杂的定制化需求。
* 生产优化的标杆： 在构建生产环境优化 Bundle 方面经验丰富，功能强大且可靠。

## 社区支持

* [vue-cli](https://github.com/vuejs/vue-cli) -&#x20;

  Vue 官方维护的，基于 webpack 构建，集成了常规 Vue 项目的开发、构建、部署流程等套件，易上手。

* [create-react-app](https://github.com/facebook/create-react-app) -&#x20;

  Create React App 是官方支持的创建单页 React 应用程序的方式。它提供了无需配置的现代化构建环境。

  目前已经不再维护，不推荐使用。

* [awesome-webpack](https://webpack.docschina.org/awesome-webpack/)

---

---
url: /czxBlog/cli/index.md
---
本篇仅收集记录 常用的命令行，及在具体场景中的使用，并不对它们进行详细介绍。

## 拷贝

### 拷贝一个文件

将 `file.txt` 拷贝到 `documents/` 目录下

```sh
cp file.txt documents/
```

### 拷贝一个目录

把 `music/` 整个目录拷贝到 `media/` 目录下

```sh
cp -a music media/
# 或者写成
cp -a music/ media/music/
```

### 创建文件副本

从 `file.txt` 创建副本 `file.bak.txt`

```sh
cp file.txt file.bak.txt
# 或者写成
cp file{,.bak}.txt
```

### 创建目录副本

从 `music/` 创建副本

```sh
cp -a music/ media/
# 如果 media 目录不存在
cp -a music media/
```

## 移动

### 移动文件

将 `file.txt` 移动到 `documents/` 目录下

```sh
mv file.txt documents/
# 不要忽略 document 后面的 `/`，不然会被当成重命名文件
```

### 重命名文件

将 `file.txt` 重命名为 `readme.md`

```sh
mv file.txt readme.md
```

### 移动目录

将 目录 `music/` 移动到 `media/` 目录下

```sh
mv music media/
# 或者写成
mv music/ media/music
```

### 重命名目录

将 目录 `music/` 重命名为 `media/`

```sh
mv music/ media/
```

## 合并目录文件

将 `images/` 目录合并到 `images2/` 目录中

```sh
# -a 相当于 -rlptgoD , 表示归档，同名文件会被覆盖
rsync -a images/ images2/
```

## 创建

### 创建文件

创建 `file.txt`

```sh
touch file.txt # 如果文件存在，则更新它的权限和修改时间
# 或者使用
> file.txt  # 如果文件存在，则会清空文件内容
```

### 创建目录

创建 `music/` 目录

```sh
mkdir music
# 创建一连串的文件夹
mkdir -p media/music/rock
```

## 查看信息

### 文件和目录大小

```sh
du -sh node_modules/
```

### 文件信息

```sh
stat -x file # MacOS
stat file    # Linux
```

### 文件内容

查看文件内容

```sh
cat file.txt
# 如果文件太大，可以使用 `less` 来一次查看一页内容
less file.txt
```

### 目录文件

查看目录中的文件

```sh
ls folder
# -l: 以列表格式显示. -a: 显示包括隐藏文件的所有文件. -la 结合以上两个选项.
ls -la folder
# -r: 倒序显示. -t: 按修改时间排序. -h: 以易读的格式显示大小.
ls -alrth folder
```

显示目录下所有文件和子目录的文件树

```sh
tree folder  # Linux
find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g' # MacOS
# 也可以在 MacOS 上使用 `brew install tree` 安装 `tree` 命令行工具
```

## 打开文件

使用默认程序打开文件

```sh
xdg-open file # Linux
open file     # MacOS
start file    # Windows
```

在任意程序中打开文件

```sh
open -a appName file
```

## 删除

### 删除一个文件

删除 `file.txt`

```sh
rm file.txt
```

### 删除一个目录

删除 `music/` 目录

```sh
rm -r music
```

## 解压缩

### 压缩整个目录

将 目录 `music/` 压缩到 `archive.zip`

```sh
zip -r archive.zip music
```

### 解压文件

将 `archive.zip` 解压

```sh
unzip archive.zip
```

### 速览压缩文件

速览压缩包中的文件

```sh
zipinfo archive.zip
# 或者
unzip -l archive.zip
```

## 搜索

### 找出陈旧文件

找出所有最近一次修改在 5 天之前的文件

```sh
find folder -mtime +5
```

### 检索文件内容

```sh
grep -i "music" file.txt
```

`grep` 能在文件中检索特定内容，一些常见的配套命令行参数:

* `-i`：大小写敏感
* `-A/-B/-C <N>`：顺带显示前后文，`-A`表示后面 N 行，-B表示前面 N 行，`-C`表示前后各 N 行
* `-E`：使用正则表达式来匹配
* `-v`：反选（输出不匹配的行）
* `-l`：只输出能匹配到内容的文件名
* `-F`：不要将检索内容视为正则表达式
* `-r`：递归匹配目录下所有文件的内容
* `-o`：只输出匹配上了的部分（而不是整行）
* `-a`：也对二进制文件进行检索，而不是忽略它们！

## 强制退出程序

```sh
killall program_name
```

## 网络

### 服务器响应

```sh
curl -i https://chongzhenxiang.cn
```

### 检查域名/地址连接

检查域名或者地址某端口是否能够连接

```sh
nc -vz chongzhenxiang.cn 443
nc -vz 1.1.1.1 443
```

### 域名DNS配置

```sh
dig chongzhenxiang.cn
```

### 域名所有人和注册信息

```sh
whois chongzhenxiang.cn
```

## 热键

* `Ctrl + A` 跳转到你当前编辑的命令行行首
* `Ctrl + E` 跳转到你当前编辑的命令行行尾
* `Ctrl + L` 清屏，和 clear 指令类似
* `Ctrl + U` 清除行中光标之前的内容（在行尾时即清除整行）
* `Ctrl + H` 和退格一样
* `Ctrl + R` 能让你搜索之前使用过的命令行记录
* `Ctrl + C` 强制停止当前的程序
* `Ctrl + D` 退出当前 shell （壳层/命令行界面）
* `Ctrl + Z` 将当下运行的程序挂起，使用 fg 来恢复运行
* `Ctrl + W` 删除光标前的一个词
* `Ctrl + K` 清除行中光标之后的内容
* `Ctrl + T` 交换光标前两个字符
* `Esc + T` 交换光标前两个词
* `Alt + F` 将光标移至行内下一个词处
* `Alt + B` 将光标移至行内上一个词处
* `Tab` 自动补全文件/目录的名称

### MacOS

```sh
!!                            # 再一次执行上一条指令
sudo !!                       # 以管理员身份执行上一条指令
!<word>                       # 加上特定命令行前缀再执行上一条指令
!<word>:p                     # 显示上一条指令加上前缀，但不要执行
<space>command                # 执行指令，但不要存到历史记录中
echo "ls -l" | at midnight    # 在特定时间执行指令
caffeinate -u -t 3600         # 接下来一小时内阻止你的mac休眠
ls -lhs                       # 将目录中文件按大小排序显示
qlmanage -p <file>            # 从命令行调用"速览"
top -o vsize                  # 查看是什么拖慢了你的mac
```

---

---
url: /czxBlog/cpwp/index.md
---
# 中国程序员容易发音错误的单词
::: tip 数据来源 [chinese-programmer-wrong-pronunciation](https://github.com/shimohq/chinese-programmer-wrong-pronunciation)
:::

你说得对，我经常读错。

是的，第一个单词我就读错了。（怪不好意思的）

| 单词          | 正确发音（英音）                                                                                                       | 正确发音（美音）                                                                                             | 错误发音                |
| ------------- | ---------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ | ----------------------- |
| access        | /'ækses/ @[audioReader](https://dict.youdao.com/dictvoice?audio=access\&type=1)                                         | /ˈækses/ @[audioReader](https://dict.youdao.com/dictvoice?audio=access\&type=2)                               | ❌ /ək'ses/              |
| Adobe         | /ə'dəʊbi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Adobe\&type=1)                                         | /ə'dəʊbi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Adobe\&type=2)                               | ❌ /əˈdub/               |
| admin         | /'ædmɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=admin\&type=1)                                          | /ˈædmɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=admin\&type=2)                                | ❌ /ɜ:d'mɪn/             |
| adversarial   | /ˌædvəˈseəriəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=adversarial\&type=1)                             | /ˌædvərˈseriəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=adversarial\&type=2)                   | ❌ /ədˈvɜːrsəriəl/       |
| agile         | /'ædʒaɪl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=agile\&type=1)                                         | /ˈædʒl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=agile\&type=2)                                 | ❌ /ə'dʒaɪl/             |
| amazon        | /'æməzən/ @[audioReader](https://dict.youdao.com/dictvoice?audio=amazon\&type=1)                                        | /ˈæməzɑːn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=amazon\&type=2)                             | ❌ /'əmeizən/ /ə'meizən/ |
| analogy       | /əˈnælədʒi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=analogy\&type=1)                                     | /əˈnælədʒi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=analogy\&type=2)                           | ❌ /ænə'lɒdʒi/           |
| Angular       | /'æŋgjʊlə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Angular\&type=1)                                      | /ˈæŋɡjələr/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Angular\&type=2)                           | ❌ /'æŋɡələ/ /'æŋdʒʌlə/  |
| AJAX          | /'eidʒæks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=AJAX\&type=1)                                         | /'eidʒæks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=AJAX\&type=2)                               | ❌ /ə'dʒʌks/             |
| alias         | /ˈeɪliəs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=alias\&type=1)                                         | /ˈeɪliəs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=alias\&type=2)                               | ❌ /ə'lais/              |
| align         | /əˈlaɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=align\&type=1)                                          | /əˈlaɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=align\&type=2)                                | ❌ /ə'lidʒen/            |
| Apache        | /ə'pætʃɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Apache\&type=1)                                        | /əˈpætʃi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Apache\&type=2)                              | ❌ /ʌpʌtʃ/               |
| app           | /æp/ @[audioReader](https://dict.youdao.com/dictvoice?audio=app\&type=1)                                                | /æp/ @[audioReader](https://dict.youdao.com/dictvoice?audio=app\&type=2)                                      | ❌ /eipi'pi/             |
| archive       | /'ɑːkaɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=archive\&type=1)                                       | /'ɑːkaɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=archive\&type=2)                             | ❌ /'ətʃɪv/              |
| array         | /ə'rei/ @[audioReader](https://dict.youdao.com/dictvoice?audio=array\&type=1)                                           | /əˈreɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=array\&type=2)                                 | ❌ /æ'rei/               |
| ASCII         | /'æski/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ascii\&type=1)                                           | /ˈæski/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ascii\&type=2)                                 | ❌ /ɑːsk/                |
| aspect        | /'æspekt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=aspect\&type=1)                                        | /ˈæspekt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=aspect\&type=2)                              | ❌ /ə'spekt/             |
| async         | /əˈsɪŋk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=async\&type=1)                                          | /æˈsɪŋk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=async\&type=2)                                | ❌ /'æsɪŋk/              |
| avatar        | /'ævətɑː/ @[audioReader](https://dict.youdao.com/dictvoice?audio=avatar\&type=1)                                        | /ˈævətɑːr/ @[audioReader](https://dict.youdao.com/dictvoice?audio=avatar\&type=2)                             | ❌ /ə'vʌtɑ/              |
| Azure         | /'æʒə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=azure\&type=1)                                            | /ˈæʒər/ @[audioReader](https://dict.youdao.com/dictvoice?audio=azure\&type=2)                                 | ❌ /ˈæzʊʒə/              |
| Bazel         | /ˈbeɪzəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=bazel\&type=1)                                         | /ˈbeɪzəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=bazel\&type=1)                               | ❌ /bæ zəl/              |
| bind          | /baɪnd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=bind\&type=1)                                            | /baɪnd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=bind\&type=2)                                  | ❌ /bɪnd/                |
| BIOS          | /ˈbaɪɒs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=bios\&type=1)                                           | /'baɪɑs/                                                                                                     | ❌ /ˈbɪɒs/               |
| cache         | /kæʃ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=cache\&type=1)                                             | /kæʃ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=cache\&type=2)                                   | ❌ /kætʃ/                |
| canal         | /kəˈnæl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=canal\&type=1)                                          | /kəˈnæl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=canal\&type=2)                                | ❌ /ˈkænl/               |
| chaos         | /ˈkeɪɒs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=chaos\&type=1)                                          | /ˈkeɪɑːs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=chaos\&type=2)                               | ❌ /ˈtʃoʊs/              |
| Chrome        | /krəʊm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=chrome\&type=1)                                          | /kroʊm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=chrome\&type=2)                                | ❌ /tʃɔːm/               |
| clang         | /klæŋ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=clang\&type=1)                                            | /klæŋ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=clang\&type=2)                                  | ❌ /sɪlæŋ/               |
| context       | /ˈkɒntekst/ @[audioReader](https://dict.youdao.com/dictvoice?audio=context\&type=1)                                     | / ˈkɑːntekst/ @[audioReader](https://dict.youdao.com/dictvoice?audio=context\&type=2)                         | ❌ /kənˈtekst/           |
| Coq           | IPA French \['kɔkʲ] 读若拼音“goq” @[audioReader](https://upload.wikimedia.org/wikipedia/commons/4/47/Fr-coq.ogg)        |                                                                                                              | ❌ IPA English \['kʰɒk]   |
| daemon        | /'diːmən/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Daemon\&type=1)                                        | /ˈdiːmən/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Daemon\&type=2)                              | ❌ /dæmən/               |
| debt          | /det/ @[audioReader](https://dict.youdao.com/dictvoice?audio=debt\&type=1)                                              | /det/ @[audioReader](https://dict.youdao.com/dictvoice?audio=debt\&type=2)                                    | ❌ /de'bit/              |
| deny          | /dɪ'naɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deny\&type=1)                                           | /dɪˈnaɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deny\&type=2)                                 | ❌ /'dæni/               |
| deprecate     | /ˈdeprəkeɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deprecate\&type=1)                                  | /ˈdeprəkeɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deprecate\&type=2)                        |                         |
| deque         | /'dek/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deque\&type=1)                                            | /dɛk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deque\&type=2)                                   | ❌ /di'kju/              |
| digest        | n. /'dɑɪdʒɛst/ v. /dɑɪ'dʒɛst/ @[audioReader](https://dict.youdao.com/dictvoice?audio=digest\&type=1)                    | /daɪˈdʒest,dɪˈdʒest/ @[audioReader](https://dict.youdao.com/dictvoice?audio=digest\&type=2)                   | ❌ /'dɪgɛst/             |
| Dijkstra      | Dutch:/ˈdɛikstra/ English:/ˈdaɪkstrə/ @[audioReader](https://upload.wikimedia.org/wikipedia/commons/8/85/Dijkstra.ogg) | @[audioReader](https://upload.wikimedia.org/wikipedia/commons/8/85/Dijkstra.ogg)                             |                         |
| Django        | /ˈdʒæŋɡoʊ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Django\&type=1)                                       | /ˈdʒæŋɡoʊ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Django\&type=2)                             | ❌ /diˈdʒæŋɡoʊ/          |
| doc           | /dɒk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=doc\&type=1)                                               | /dɒk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=doc\&type=2)                                     | ❌ /daʊk/                |
| dotnet        | /dɒtnet/ @[audioReader](https://dict.youdao.com/dictvoice?audio=dotnet\&type=1)                                         | /dɑːtnet/ @[audioReader](https://dict.youdao.com/dictvoice?audio=dotnet\&type=2)                              | ❌ /daʊtnet/             |
| edition       | /ɪˈdɪʃ(ə)n/ @[audioReader](https://dict.youdao.com/dictvoice?audio=edition\&type=1)                                     | /ɪˈdɪʃn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=edition\&type=2)                              | ❌ /eˈdɪʃn/              |
| ephemeral     | /ɪˈfemərəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ephemeral\&type=1)                                   | /ɪˈfemərəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ephemeral\&type=2)                         | ❌ /efe'merəl/           |
| epoch         | /ˈiːpɒk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=epoch\&type=1)                                          | /ˈepək/ @[audioReader](https://dict.youdao.com/dictvoice?audio=epoch\&type=2)                                 | ❌ /'ɛpətʃ/              |
| execute       | /ˈeksɪkjuːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=execute\&type=1)                                    | /ˈeksɪkjuːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=execute\&type=2)                          |                         |
| executor      | /ɪɡˈzekjətə(r)/ @[audioReader](https://dict.youdao.com/dictvoice?audio=executor\&type=1)                                | /ɪɡˈzekjətər/ @[audioReader](https://dict.youdao.com/dictvoice?audio=executor\&type=2)                        |                         |
| event         | /ɪ'vent/ @[audioReader](https://dict.youdao.com/dictvoice?audio=event\&type=1)                                          | /ɪˈvent/ @[audioReader](https://dict.youdao.com/dictvoice?audio=event\&type=2)                                | ❌ /'ɪvənt/              |
| exit          | /ˈeksɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=exit\&type=1)                                           | /ˈeksɪt; ˈeɡzɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=exit\&type=2)                         | ❌ /ig'zit/              |
| facade        | /fə'sɑːd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=facade\&type=1)                                        | /fəˈsɑːd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=facade\&type=2)                              | ❌ /'feikeid/            |
| fedora        | /fɪ'dɔːrə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=fedora\&type=1)                                       | /fɪˈdɔːrə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=fedora\&type=2)                             | ❌ /'fedərə/             |
| format        | /'fɔːmæt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=format\&type=1)                                        | /ˈfɔːrmæt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=format\&type=2)                             | ❌ /fɔ'mæt/              |
| gauge         | /ɡeɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=gauge\&type=1)                                           | /ɡeɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=gauge\&type=2)                                 | ❌ /ɡɑudʒ/               |
| Git           | /ɡɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=git\&type=1)                                               | /ɡɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=git\&type=2)                                     | ❌ /dʒɪt/                |
| GNU           | /gnu:/ @[audioReader](https://upload.wikimedia.org/wikipedia/commons/2/24/En-gnu.ogg)                                  | /gnuː,gnjuː/ @[audioReader](https://upload.wikimedia.org/wikipedia/commons/2/24/En-gnu.ogg)                  |                         |
| Grafana       | /grəˈfɑːnˌɑː/ @[audioReader](http://www.howtopronounce.cc/file/e204a97ed1e440c5ab15ea0117beb955.mp3)                   | /grəˈfɑːnˌɑː/ @[audioReader](http://www.howtopronounce.cc/file/e204a97ed1e440c5ab15ea0117beb955.mp3)         |                         |
| GraphQL       | /græf kju ɛl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=GraphQL\&type=1)                                   | /græf kju ɛl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=GraphQL\&type=2)                         | ❌ /dʒɪgræf kju ɛl/      |
| GUI           | /ˈɡu:i/ @[audioReader](https://dict.youdao.com/dictvoice?audio=GUI\&type=1)                                             | /ˈɡu:i/ @[audioReader](https://dict.youdao.com/dictvoice?audio=GUI\&type=2)                                   |                         |
| Haskell       | /ˈhæskəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=haskell\&type=1)                                       | /ˈhæskəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=haskell\&type=2)                             | ❌ /hæˈskəl/             |
| height        | /haɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=height\&type=1)                                           | /haɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=height\&type=2)                                 | ❌ /heɪt/                |
| hidden        | /'hɪdn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=hidden\&type=1)                                          | /ˈhɪdn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=hidden\&type=2)                                | ❌ /'haɪdn/              |
| IEEE          | /aɪ ˈtrɪpəl i/ @[audioReader](https://dict.youdao.com/dictvoice?audio=I_triple_e\&type=1)                               | /aɪ ˈtrɪpəl i/ @[audioReader](https://dict.youdao.com/dictvoice?audio=I_triple_e\&type=2)                     | ❌ /'aɪ'iː'iː'iː/        |
| image         | /'ɪmɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=image\&type=1)                                          | /ˈɪmɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=image\&type=2)                                | ❌ /ɪ'meɪdʒ/             |
| implement     | /'ɪmplɪm(ə)nt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=implement\&type=1)                                | /ˈɪmplɪmənt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=implement\&type=2) /ˈɪmpləˌment/          | ❌ /ɪm'plem(ə)nt/        |
| integer       | /'ɪntɪdʒə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=integer\&type=1)                                      | /ˈɪntɪdʒər/ @[audioReader](https://dict.youdao.com/dictvoice?audio=integer\&type=2)                           | ❌ /ˈɪntaɪgə/            |
| issue         | /'ɪʃuː/ @[audioReader](https://dict.youdao.com/dictvoice?audio=issue\&type=1)                                           | /ˈɪʃuː/ @[audioReader](https://dict.youdao.com/dictvoice?audio=issue\&type=2)                                 | ❌ /ˈaɪʃuː/              |
| Java          | /'dʒɑːvə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=java\&type=1)                                          | /ˈdʒɑːvə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=java\&type=2)                                |                         |
| jpg           | /'dʒeɪpeɡ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=JPEG\&type=1)                                         | /'dʒeɪpeɡ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=JPEG\&type=2)                               | ❌ /ˈdʒeɪˈpi:ˈdʒiː/      |
| key           | /kiː/ @[audioReader](https://dict.youdao.com/dictvoice?audio=key\&type=1)                                               | /kiː/ @[audioReader](https://dict.youdao.com/dictvoice?audio=key\&type=2)                                     | ❌ /kei/                 |
| kubernetes\*   | /kubз'netɪs/ @[audioReader](https://content.swncdn.com/biblestudytools/audio/lexicons/greek-mp3/2942g.mp3)             | /kuːbə˞'netiz/ @[audioReader](https://content.swncdn.com/biblestudytools/audio/lexicons/greek-mp3/2942g.mp3) |                         |
| lambda        | /ˈlæmdə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=lambda\&type=1)                                         | /ˈlæmdə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=lambda\&type=2)                               | ❌ /ˈlɒŋmdɑ/             |
| Ldap          | /el'dæp/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ldap\&type=1)                                           | /el'dæp/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ldap\&type=2)                                 | ❌ /el'daːp/             |
| legacy        | /'leɡəsi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=legacy\&type=1)                                        | /'leɡəsi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=legacy\&type=2)                              | ❌ /'li:gasi/            |
| linear        | /'lɪnɪə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=linear\&type=1)                                         | /ˈlɪniər/ @[audioReader](https://dict.youdao.com/dictvoice?audio=linear\&type=2)                              | ❌ /'laɪə/               |
| LINQ          | /lɪŋk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=link\&type=1)                                             | /lɪŋk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=link\&type=2)                                   | ❌ /lɪŋkju:/             |
| Linux         | /'lɪnəks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=linux\&type=1)                                         | /ˈlaɪnəks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=linux\&type=2) /ˈlɪnəks/                    | ❌ /ˈlɪnʌks/ /ˈlɪnjuːks/ |
| locale        | /ləʊ'kɑːl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=locale\&type=1)                                       | /loʊˈkæl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=locale\&type=2)                              | ❌ /ˈloʊk(ə)l/           |
| Lucene        | /lu'siːn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=lucene\&type=1)                                        | /lu'siːn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=lucene\&type=2)                              | ❌ /'lu:sən/             |
| macro         | /ˈmækrəʊ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=macro\&type=1)                                         | /ˈmækroʊ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=macro\&type=2)                               | ❌ /ˈmakroʊ/             |
| main          | /meɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=main\&type=1)                                             | /meɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=main\&type=2)                                   | ❌ /mɪn/                 |
| margin        | /'mɑːdʒɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=margin\&type=1)                                       | /ˈmɑːrdʒɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=margin\&type=2)                            | ❌ /'mʌgɪn/              |
| matrix        | /ˈmeɪtrɪks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=matrix\&type=1)                                      | /ˈmeɪtrɪks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=matrix\&type=2)                            | ❌ /ˈmɑ:trɪks/           |
| maven         | /'meɪvn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=maven\&type=1)                                          | /ˈmeɪvn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=maven\&type=2)                                | ❌ /'maːvn/              |
| max           | /mæks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=max\&type=1)                                              | /mæks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=max\&type=2)                                    | ❌ /mɑ:ks/               |
| Microsoft     | /'maikrəusɔft/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Microsoft\&type=1)                                | /ˈmaɪkrəsɔːft/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Microsoft\&type=2)                      | ❌ /'mikrəusɔft/         |
| migrate       | /maɪˈɡreɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=migrate\&type=1)                                     | /ˈmaɪɡreɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=migrate\&type=2)                           | ❌ /ˈmɪɡreɪt/            |
| miscellaneous | /ˌmɪsəˈleɪniəs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=miscellaneous\&type=1)                           | /ˌmɪsəˈleɪniəs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=miscellaneous\&type=2)                 |                         |
| module        | /'mɒdjuːl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=module\&type=1)                                       | /ˈmɑːdʒuːl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=module\&type=2)                            | ❌ /'məʊdl/              |
| native        | /ˈneɪtɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=native\&type=1)                                        | /ˈneɪtɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=native\&type=2)                              | ❌ /ˈnætɪv/              |
| nginx         | Engine X                                                                                                               | Engine X                                                                                                     |                         |
| null          | /nʌl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=null\&type=1)                                              | /nʌl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=null\&type=2)                                    | ❌ /naʊ/                 |
| obsolete      | /ˈɒbsəliːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=obsolete\&type=1)                                    | /ˌɑːbsəˈliːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=obsolete\&type=2)                        |                         |
| OS X          | OS ten                                                                                                                 | OS ten                                                                                                       | ❌ /ɔs eks/              |
| phantom       | /'fæntəm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=phantom\&type=1)                                       | /ˈfæntəm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=phantom\&type=2)                             | ❌ /'pæntəm/             |
| parameter     | /pə'ræmɪtə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=parameter\&type=1)                                   | /pəˈræmɪtər/ @[audioReader](https://dict.youdao.com/dictvoice?audio=parameter\&type=2)                        | ❌ /'pærəmɪtə/           |
| premise       | /ˈpremɪs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=premise\&type=1)                                       | /ˈpremɪs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=premise\&type=2)                             | ❌ /prɪ'mɪs/             |
| privilege     | /'prɪvəlɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=privilege\&type=1)                                  | /ˈprɪvəlɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=privilege\&type=2)                        | ❌ /'prɪvɪlɪdʒ/          |
| probe         | /prəʊb/ @[audioReader](https://dict.youdao.com/dictvoice?audio=probe\&type=1)                                           | /proʊb/ @[audioReader](https://dict.youdao.com/dictvoice?audio=probe\&type=2)                                 | ❌ /proʊbi/              |
| Prometheus    | /prə-ˈmē-thē-əs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=prometheus\&type=1)                             | /pro'miθɪəs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=prometheus\&type=2)                       |                         |
| putty         | /ˈpʌti/ @[audioReader](https://dict.youdao.com/dictvoice?audio=putty\&type=1)                                           | /ˈpʌti/ @[audioReader](https://dict.youdao.com/dictvoice?audio=putty\&type=2)                                 | ❌ /ˈpuːti/              |
| Qt            | /kjuːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=cute\&type=1)                                            | /kjuːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=cute\&type=2)                                  |                         |
| query         | /'kwɪəri/ @[audioReader](https://dict.youdao.com/dictvoice?audio=query\&type=1)                                         | /ˈkwɪri/ @[audioReader](https://dict.youdao.com/dictvoice?audio=query\&type=2)                                | ❌ /'kwaɪri/             |
| Realm         | /relm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=realm\&type=1)                                            | /relm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=realm\&type=2)                                  | ❌ /riəlm/               |
| reconcile     | /ˈrekənsaɪl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=reconcile\&type=1)                                  | /ˈrekənsaɪl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=reconcile\&type=2)                        |                         |
| Redux         | /ri'dʌks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=redux\&type=1)                                         | /ri'dʌks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=redux\&type=2)                               | ❌ /'ridju:ks/           |
| resume        | /rɪ'zju:m/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resume\&type=1)                                       | /rɪˈzuːm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resume\&type=2)                              | ❌  /rɪ'sju:m/           |
| résumé        | /rezjumeɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=résumé\&type=1)                                       | /ˈrezəmeɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=résumé\&type=2)                             | ❌  /rɪ'sju:m/           |
| resolved      | /rɪ'zɒlvd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resolved\&type=1)                                     | /rɪˈzɑːlvd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resolved\&type=2)                          | ❌ /rɪ'səʊvd/            |
| resort        | /rɪˈzɔ:t/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resort\&type=1)                                        | /rɪˈzɔːrt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resort\&type=2)                             | ❌ /rɪˈsɔ:t/             |
| retina        | /'retɪnə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=retina\&type=1)                                        | /ˈretɪnə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=retina\&type=2)                              | ❌ /ri'tina/             |
| RISC-V        | /'rɪsk faɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=risk-five\&type=1)                                  | /'rɪsk faɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=risk-five\&type=2)                        | ❌ /'rɪsk v/             |
| route         | /ruːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=route\&type=1)                                            | /ruːt,raʊt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=route\&type=2)                             | ❌ /rəʊt/                |
| San Jose      | /sænhəu'zei/ @[audioReader](https://dict.youdao.com/dictvoice?audio=san%20jose\&type=1)                                 | /sænhəu'zei/ @[audioReader](https://dict.youdao.com/dictvoice?audio=san%20jose\&type=2)                       | ❌ /sæn'ju:s/            |
| safari        | /sə'fɑːrɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=safari\&type=1)                                       | /səˈfɑːri/ @[audioReader](https://dict.youdao.com/dictvoice?audio=safari\&type=2)                             | ❌ /sæfərɪ/              |
| scheme        | /skiːm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=scheme\&type=1)                                          | /skiːm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=scheme\&type=2)                                | ❌ /s'kæmə/              |
| scala         | /ˈskɑːlɑ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=scala\&type=1)                                         | /ˈskɑːlɑ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=scala\&type=2)                               | ❌ /ˈskæːlɑ/             |
| segue         | /'sɛɡwe/ @[audioReader](https://dict.youdao.com/dictvoice?audio=segue\&type=1)                                          | /ˈseɡweɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=segue\&type=2)                               | ❌ /se'dʒ/               |
| SQL           | /ˈsiːkwəl/ /ˈesˈkjuːˈel/                                                                                               | /ˈsiːkwəl/ /ˈesˈkjuːˈel/                                                                                     | ❌ /sərk(ə)l/            |
| sudo          | /'suːduː/                                                                                                              | /'suːduː/                                                                                                    |                         |
| suite         | /swiːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=suite\&type=1)                                           | /swiːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=suite\&type=2)                                 | ❌ /sjuːt/               |
| telemetry     | /təˈlemətri/ @[audioReader](https://dict.youdao.com/dictvoice?audio=telemetry\&type=1)                                  | /təˈlemətri/ @[audioReader](https://dict.youdao.com/dictvoice?audio=telemetry\&type=2)                        | ❌ /ˈtelɪmətri/          |
| thymeleaf     | /ˈtaɪmˌlɪːf/ @[audioReader](https://dict.youdao.com/dictvoice?audio=thymeleaf\&type=1)                                  | /ˈtaɪmˌlɪːf/ @[audioReader](https://dict.youdao.com/dictvoice?audio=thymeleaf\&type=2)                        | ❌ /θiːmɪlɪːf/           |
| tuple         | /tjʊpəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=tuple\&type=1)                                          | /tuːpəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=tuple\&type=2)                                |                         |
| typical       | /'tɪpɪkl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=typical\&type=1)                                       | /ˈtɪpɪkl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=typical\&type=2)                             | ❌ /'taɪpɪkəl/           |
| Ubuntu        | /ʊ'bʊntʊ/ @[audioReader](https://upload.wikimedia.org/wikipedia/commons/b/b5/En-Ubuntu_pronunciation.oga)              | /ʊ'bʊntʊ/ @[audioReader](https://upload.wikimedia.org/wikipedia/commons/b/b5/En-Ubuntu_pronunciation.oga)    | ❌ /juː'bʊntʊ/           |
| UEFI          | U-E-F-I                                                                                                                | U-E-F-I                                                                                                      | ❌ /jufi/ /ɔːfi/         |
| Vagrant       | /ˈveɪɡrənt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Vagrant\&type=1)                                     | /ˈveɪɡrənt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Vagrant\&type=2)                           | /ˈvagɹent/              |
| variable      | /'veəriəbl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=variable\&type=1)                                    | /ˈveriəbl,ˈværiəbl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=variable\&type=2)                  | ❌ /və'raiəbl/           |
| verbose       | /vɜːˈbəʊs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=verbose\&type=1)                                      | /vɜːrˈboʊs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=verbose\&type=2)                           | ❌ /'vɜːrboʊs/           |
| vue           | /v'ju:/ @[audioReader](https://dict.youdao.com/dictvoice?audio=vue\&type=1)                                             | /v'ju:/ @[audioReader](https://dict.youdao.com/dictvoice?audio=vue\&type=2)                                   | ❌ /v'ju:i/              |
| width         | /wɪdθ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=width\&type=1)                                            | /wɪdθ,wɪtθ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=width\&type=2)                             | ❌ /waɪdθ/               |
| YouTube       | /'juː'tjuːb/ @[audioReader](https://dict.youdao.com/dictvoice?audio=youtube\&type=1)                                    | /'juː'tjuːb/ @[audioReader](https://dict.youdao.com/dictvoice?audio=youtube\&type=2)                          | ❌ /'juː'tʊbɪ/           |
| Vite          | /vit/ @[audioReader](https://dict.youdao.com/dictvoice?audio=vite\&type=1)                                              | /vit/ @[audioReader](https://dict.youdao.com/dictvoice?audio=vite\&type=2)                                    | ❌ /vaɪt/                |

---

---
url: /czxBlog/defensive-css/index.md
---
# 防御性CSS
## 什么是防御性CSS ？

防御性CSS 是 一系列的 CSS 实践技巧。
设计师和开发人员可以使用这些实践技巧来编写 安全、健壮的 CSS 代码，从而减少 用户界面 可能发生的错误。

我们 可以 将防御性CSS 当做一种策略，它可以帮助我们揭示一些 潜在的问题，
使我们在 进行 设计 或 编写代码时，尽可能的避免这些问题，更好的完成 用户界面构建和交互。

对于 设计师而言，防御性CSS 可以帮助 设计师 了解可能发生的 未知的内容，处理这些未知的内容，完善设计。

对于 开发人员， 防御性CSS 可以当做一种 高阶的 CSS重置 。

当前， 防御性CSS 包括了 `24` 个 防御技巧。

---

---
url: /czxBlog/defensive-css/accidental-hover-on-mobile/index.md
---
# Accidental Hover On Mobile
## Accidental Hover On Mobile

在应用中，我们会使用 `hover` 效果向用户提供 元素可点击或者出于活动状态的提示。
这在具有鼠标或触控面板的设备来说表现良好，但是这在移动端的设备上， `hover` 效果可能会令人困惑。

```css
.card:hover {
  background: blue;
}
```

在页面中滚动时，手指可能会意外地轻点半下，这将触发特定元素的 `hover` 状态。

:::demo-wrapper
如果是桌面端浏览器，请打开 控制台，切换为 移动设备。在下面元素上点击，会看到 `hover` 效果。

这种意外的触发了 `hover` 状态，可能不是用户想看到的，毕竟在 移动设备上，并不需要 `hover` 。

对此，我们可以通过 `hover` 媒体查询，来解决这个问题。
检测到用户当前的设备是否可以将 鼠标指针 悬停在 元素上。

```css
@media (hover: hover) {
  .card:hover {
    /* Add hover styles.. */
  }
}
```

:::demo-wrapper
如果是桌面端浏览器，请打开 控制台，切换为 移动设备。在下面元素上点击。

可以看到，在 桌面端浏览器中，`hover` 效果被激活，在移动端浏览器中，不触发 `hover` 效果。

---

---
url: /czxBlog/defensive-css/auto-fit-fill/index.md
---
# Auto-fit Vs Auto-fill
## Auto-fit Vs Auto-fill

当我们在使用 `CSS Grid` 网格布局时，会经常使用到 `minmax()` 函数。
在使用 `minmax()` 函数时，决策使用 `auto-fit` 还是 `auto-fill` 关键词非常重要，
如果使用不当，可能会导致意想不到的后果。

使用 `minmax()` 函数 时：

* `auto-fit`： 将展开网格项以填充可用空间。
* `auto-fill`： 将保留可用空间，而不改变网格项的宽度。

![auto fit fill](/images/defensive-css/auto-fit-fill.png){style="border:var(--vp-c-divider) 1px solid;border-radius:5px;box-shadow:var(--vp-shadow-2)"}

尽管如此，使用 `auto-fit` 可能会导致网格项太宽，尤其是当它们小于预期时。请看以下示例。

```css
.wrapper {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  grid-gap: 1rem;
}
```

如果只有一个网格项并且使用 `auto-fit` ，则该项目将展开以填充容器宽度。

:::demo-wrapper
四个子项：

一个子项：

***

在大多数情况下，不需要 这样的行为。所以在我看来，使用 `auto-fill` 会更好。

:::demo-wrapper
四个子项：

一个子项：

## 示例

```css
.wrapper {
  --sizing: auto-fit;
  display: grid;
  grid-template-columns: repeat(var(--sizing), minmax(100px, 1fr));
  grid-gap: 1rem;
}
```

:::: demo title="auto-fit-fill" desc="调整容器大小查看效果"
::: code-tabs

@tab HTML

```html
<div class="demo-wrapper">
  <div class="wrapper" id="gridWrapper">
    <div class="card">
      <div class="card__thumb"></div>
      <p>css grid 布局</p>
    </div>
    <div class="card">
      <div class="card__thumb"></div>
      <p>css grid 布局</p>
    </div>
    <div class="card-outline"></div>
    <div class="card-outline"></div>
  </div>
</div>
<div class="actions">
  <input type="checkbox" id="toggle" />
  <label for="toggle">启用 auto-fill</label>
</div>
```

@tab CSS

```css
.demo-wrapper {
  position: relative;
  width: 300px;
  max-width: 100%;
  resize: horizontal;
  overflow: hidden;
  border-right: solid 2px var(--vp-c-border, #c2c2c4);
  padding-right: 3rem;
  padding-left: 1rem;
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
  background: var(--vp-c-bg-alt, #f0f0f0);
}
.demo-wrapper::after {
  content: 'Resize me';
  position: absolute;
  right: 0;
  top: 50%;
  writing-mode: tb-rl;
  transform: translateY(-50%);
  font-size: 13px;
  line-height: 1.2;
}
.wrapper {
  --sizing: auto-fit;
  display: grid;
  grid-template-columns: repeat(var(--sizing), minmax(100px, 1fr));
  grid-gap: 1rem;
  width: 100%;
}
.wrapper .card {
  border-radius: 5px;
  overflow: hidden;
}
.wrapper .card__thumb {
  height: 90px;
  background: var(--vp-c-brand-1, #f0f0f0);
}
.wrapper .card p {
  margin: 0;
  padding: 5px 10px;
  background: var(--vp-c-brand-3, #f0f0f0);
}
.wrapper .card-outline {
  display: none;
  border: 1px dashed;
  border-radius: 5px;
  min-height: 20px;
}

.wrapper.checked {
  --sizing: auto-fill;
}

.wrapper.checked .card-outline {
  display: block;
}
```

@tab Javascript

```js
const wrapper = document.querySelector('#gridWrapper')
document.querySelector('#toggle').addEventListener('change', (e) => {
  wrapper.classList.toggle('checked', e.target.checked)
})
```

:::
::::

---

---
url: /czxBlog/defensive-css/background-repeat/index.md
---
# Background repeat
## Background repeat

通常，当使用大图像作为背景时，我们往往会忘记考虑在大屏幕上查看时的情况。
默认情况下，该背景将重复。

这在笔记本电脑屏幕上大多不可见，但在较大的屏幕上可以清楚地看到。
::::demo-wrapper
:::center
小屏幕

大屏幕

:::
::::

为提前避免该行为，请确保重置 `background-repeat` 。

```css
.hero {
  background-image: url('..');
  background-repeat: no-repeat;
}
```

---

---
url: /czxBlog/defensive-css/button-minimum-width/index.md
---
# Button Minimum Width
## Button Minimum Width

一个常见的错误是假设按钮宽度应等于其内容加水平填充。
这对于单语言网站（例如：英语）可能如预期般工作，但对于多语言网站很容易出现意外的问题。

请看以下示例：

:::demo-wrapper
英语：
Done

中文：
完成

阿拉伯语：
تم
:::

可以看到， 在 英语 和 中文 下， 按钮的宽度表现很好，因为其内容足够长。
但是在 阿拉伯语 中， 按钮的宽度就很窄，从拥护体验来说，这很不友好，
因为对一个主要的按钮来说，它的表现应该足够的直观，方便用户操作。

为避免这种情况，我们可以提前设置按钮的最小宽度。

```css
button {
  min-width: 90px;
}
```

:::demo-wrapper
英语：
Done

中文：
完成

阿拉伯语：
تم
:::

---

---
url: /czxBlog/defensive-css/component-spacing/index.md
---
# Component Spacing
## Component Spacing

在一些布局场景中， 我们应该考虑不同的内容长度对布局的影响。
这意味着，我们需要将 **间距** 添加到组件中，即使它看起来不需要。

:::demo-wrapper

在此示例中，右侧有一个部分标题和一个操作按钮。
目前，它看起来还不错。但是，让我们看看当标题更长时会发生什么。

:::demo-wrapper

可以看到， 文本距离操作按钮太近了。也许我们可以考虑换行，但在我们将在其它章节讨论。
现在我们关注 **间距** 。

如果标题有 间距 和 文本截断 ，我们不会看到这样的问题。

```css
.section__title {
  margin-right: 1rem;
}
```

:::demo-wrapper

---

---
url: /czxBlog/defensive-css/default-flexbox-stretching/index.md
---
# Default FlexBox Stretching
## Default FlexBox Stretching

在 flexbox 中，flex 项的默认行为是拉伸。如果子项的内容长于其同级项，则会导致其他项拉伸。

但这不容易被发现， 除非我们向 Flex 项中添加比预期更长的内容。

***

在这个示例中，我们有一个包含 图像、标题、介绍 的组件。

```html
<div class="food">
  <img class="food__img" src="image/food.jpg" alt="" />
  <div class="food__content">
    <h3>一份美食</h3>
    <p><!-- Description goes here.. --></p>
  </div>
</div>
```

```css
.food {
  display: flex;
}
```

:::demo-wrapper

可以发现，当内容长度过长时，搞过了图片的高度时，图片被拉伸了。

为了解决这个问题，我们需要覆盖默认的拉伸行为。

```css
.food__img {
  align-self: flex-start;
}
```

:::demo-wrapper

---

---
url: /czxBlog/defensive-css/fixed-sizes/index.md
---
# Fixed sizes
## Fixed sizes

破坏布局的常见情况之一是， 具有固定宽度或固定高度的容器，填充了长度不一的内容，
当内容过长时，就会发生 内容溢出的情况，导致 布局被破坏。

### 固定高度

一种常见的情况是， 一个卡片容器的高度是固定的，但是 它的内容 却大于 容器的高度，
导致了布局被破坏。

```css
.card {
  height: 100px;
}
```

:::demo-wrapper

为了避免内容从 卡片 中溢出，我们需要使用 `min-height` 而不是 `height` 。

```css
.card {
  min-height: 100px;
}
```

:::demo-wrapper

这样就可以避免内容从 卡片 中溢出。

### 固定宽度

另一种常见的情况是，一个标签的内容太靠近左右边缘，发生溢出。
这是由于使用了 固定宽度。

```css
.tag {
  width: 100%;
}
```

:::demo-wrapper

要解决这个问题，我们可以使用 `min-width` 替代 `width`

```css
.tag {
  min-width: 100px;
}
```

:::demo-wrapper

---

---
url: /czxBlog/defensive-css/flex-box-wrapping/index.md
---
# FlexBox Wrapping
## FlexBox Wrapping

当下 `CSS FlexBox` 是用途最宽泛，最有用的 CSS 布局功能之一。
它只需要给 容器添加一个 `display: flex` 就可以使 容器内的 子项 一个个并排排序，简单强大，十分诱人。

但是有一个问题，如果容器没有足够的空间时，在默认情况下，这些子项不会被换行到新行中。
因此，我们需要使用 `flex-wrap: wrap` 来改变这个行为。

下面是一个 典型例子，我们有一组选项，应该彼此相邻：

:::demo-wrapper

当容器空间较小时，容器内的子项将被挤压，甚至溢出容器。这应该是意料之中的，实际上并不是一个“问题”。

:::demo-wrapper

请注意，这些子项仍然彼此相邻。为了解决这个问题，我们需要使用 `flex-wrap: wrap`：

:::demo-wrapper

## 示例：面包屑导航

::::demo title="面包屑导航" desc="调整容器大小查看效果"
::: code-tabs

@tab HTML

```html
<div class="wrapper">
  <ul class="breadcrumbs" id="breadcrumbs">
    <li class="item"><a href="#">Home</a></li>
    <li class="item"><a href="#">Article</a></li>
    <li class="item"><a href="#">Defensive CSS</a></li>
  </ul>
</div>
<div class="actions">
  <input type="checkbox" id="toggle" />
  <label for="toggle">启用 Flex Wrap</label>
</div>
```

@tab CSS

```css
.wrapper {
  position: relative;
  width: 300px;
  max-width: 100%;
  display: flex;
  align-items: center;
  resize: horizontal;
  overflow: hidden;
  flex: 1;
  border-right: solid 2px var(--vp-c-border, #c2c2c4);
  padding-right: 3rem;
  padding-left: 1rem;
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
  background: var(--vp-c-bg-alt, #f0f0f0);
}
.wrapper::after {
  content: 'Resize me';
  position: absolute;
  right: 0;
  top: 50%;
  writing-mode: tb-rl;
  transform: translateY(-50%);
  font-size: 13px;
  line-height: 1.2;
}
.breadcrumbs {
  display: flex;
  list-style: none;
  padding-left: 0;
}
.item:not(:last-child):after {
  content: '>';
  margin-left: 0.5rem;
  margin-right: 1rem;
}
.item a {
  color: var(--vp-c-brand, #5086a1);
}
```

@tab Javascript

```js
const breadcrumbs = document.querySelector('#breadcrumbs')
document.querySelector('#toggle').addEventListener('change', (e) => {
  breadcrumbs.style.flexWrap = e.target.checked ? 'wrap' : 'nowrap'
})
```

:::
::::

---

---
url: /czxBlog/defensive-css/grid-fixed-values/index.md
---
# Grid fixed values
## Grid fixed values

假设我们有一个 网格 布局，包含一个 aside 和 一个 main。
CSS 如下所示：

```css
.wrapper {
  display: grid;
  grid-template-columns: 250px 1fr;
  gap: 1rem;
}
```

:::demo-wrapper

由于空间不足，这将在较小的视口尺寸上导致溢出。
为避免此类问题，请在使用上述 CSS 网格时始终使用媒体查询。

在视口尺寸较小时，换行显示，在视口尺寸较大时，使用 网格布局。

```css
@media (min-width: 600px) {
  .wrapper {
    display: grid;
    grid-template-columns: 250px 1fr;
    gap: 1rem;
  }
}
```

:::demo-wrapper

:::center
调整浏览器窗口大小查看效果。
:::

---

---
url: /czxBlog/defensive-css/grouping-vendor-selector/index.md
---
# Grouping Vendor Selector
## Grouping Vendor Selector

不建议对带有不同浏览器前缀的选择器进行分组。

例如，设置输入占位符的样式需要每个浏览器有多个选择器。

这是由于， 根据 [W3C](https://www.w3.org/TR/selectors/#grouping) ，如果选择器分组中，有某一个
选择器 无效，则会使整个分组的所有选择器都无效。

```css
/* 请不要这样做 */
input::-webkit-input-placeholder,  /* [!code warning] */
input:-moz-placeholder {
  /* [!code warning] */
  color: #222;
}
```

相反，请这样做：

```css
input::-webkit-input-placeholder {
  color: #222;
}

input:-moz-placeholder {
  color: #222;
}
```

---

---
url: /czxBlog/defensive-css/image-distortion/index.md
---
## Image Distortion

当我们无法控制网页中的图像的横纵比时，最好提前考虑并提供 图像横纵比不一致 时的解决方案。

在下面的示例中，我们有一个带有照片的卡片组件。看起来不错。

:::demo-wrapper

当时，如果使用的图片的尺寸横纵比不一致，图片会被拉伸：

:::demo-wrapper

最简单的解决方法是使用 CSS `object-fit` 。

```css
.card__image {
  object-fit: cover;
}
```

## 示例

:::: demo title="object-fit: cover" desc="调整容器大小查看效果"
::: code-tabs

@tab HTML

```html
<div class="wrapper">
  <img id="image" src="/images/defensive-css/ratio.png" />
</div>
<div class="actions">
  <input type="checkbox" id="toggle" />
  <label for="toggle">启用 object-fit</label>
</div>
```

@tab CSS

```css
.wrapper {
  position: relative;
  width: 300px;
  max-width: 100%;
  display: flex;
  align-items: center;
  resize: horizontal;
  overflow: hidden;
  flex: 1;
  border-right: solid 2px var(--vp-c-border, #c2c2c4);
  padding-right: 3rem;
  padding-left: 1rem;
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
  background: var(--vp-c-bg-alt, #f0f0f0);
}
.wrapper::after {
  content: 'Resize me';
  position: absolute;
  right: 0;
  top: 50%;
  writing-mode: tb-rl;
  transform: translateY(-50%);
  font-size: 13px;
  line-height: 1.2;
}

#image {
  width: 100%;
  height: 140px;
}
```

@tab Javascript

```js
const image = document.querySelector('#image')
document.querySelector('#toggle').addEventListener('change', (e) => {
  image.style.objectFit = e.target.checked ? 'cover' : 'initial'
})
```

:::
::::

---

---
url: /czxBlog/defensive-css/image-inner-border/index.md
---
# Image Inner Border
## Image inner border

在处理用户头像时，以清晰的方式显示它们，并且与 视图 很好的保持统一性，可能具有一定的挑战性。
因为有些 头像的亮度很高，有些头像的亮度很低，又有可能有些是 jpg 格式，有些是 png 格式，
对透明度的支持不一，就很可能与背景色 混合 在一起。

::::demo-wrapper
:::center

由于头像存在透明部分，导致与背景色融合在一起，看不出来 头像的 UI 为 圆形，与其它的部分失去了整体性。

对此，我们可以增加 边框，可以让 UI 看起来更为舒服。

```css
.avatar {
  position: relative;
}
.avatar::after {
  position: absolute;
  content: '';
  top: 0;
  left: 0;
  display: block;
  z-index: 2;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  border: 2px solid #000;
  opacity: 0.1;
}
```

::::demo-wrapper
:::center

---

---
url: /czxBlog/defensive-css/image-maximum-width/index.md
---
# Image Maximum Width
## Image Maximum Width

作为一般规则， 请不要忘记为 所有图像设置 `max-width: 100%`。
这可以添加到你的 CSS 重置 规则中。

```css
img {
  max-width: 100%;
  object-fit: cover;
}
```

---

---
url: /czxBlog/defensive-css/input-zoom-on-ios-safari/index.md
---
# Input Zoom On iOS Safari
## Input Zoom On iOS Safari

在 iOS Safari 中， 当我们 聚焦 一个 `input` 元素进行输入时，默认情况整个网页都会进行缩放。
这是 Safari 的默认行为。虽然在输入时方法 `input` 输入框，可以让用户看到 更大的文字，
但是，不再聚焦 `input` 元素，离开输入框后，整个网页并不会缩小复原，这就很让人恼了。

:::demo-wrapper img no-padding

:::

解决方法很简单，只需要添加 `font-size` 属性到 `input` 元素即可。

```css
input {
  font-size: 16px;
}
```

:::demo-wrapper img no-padding

:::

---

---
url: /czxBlog/defensive-css/long-content/index.md
---
# Long Content
## Long Content

这是常见的联系人列表，现在看起来很完美。

:::demo-wrapper

但是，由于 联系人名字是由用户输入的，因此我们需要注意如何在内容过长的情况下保护布局。

如：

:::demo-wrapper

在此类布局中，一致性很重要。为了实现这一点，我们可以简单地使用 `text-overflow` 来截断名称。

```css
.username {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
```

:::demo-wrapper

## 示例

在某些情况下，我们可能需要截断对用户不重要或不影响用户体验的文本。在这种情况下，截断文本是个好主意。

:::: demo title="text-overflow: ellipsis" desc="调整容器大小查看效果"
::: code-tabs

@tab HTML

```html
<p>调整容器大小查看效果：</p>
<div class="wrapper">
  <div class="container">
    <h3 id="title">编写防御性CSS 是避免样式混乱的好方法</h3>
    <div class="more">more</div>
  </div>
</div>
<div class="actions">
  <input type="checkbox" id="toggle" />
  <label for="toggle">启用 text-overflow</label>
</div>
```

@tab CSS

```css
.wrapper {
  position: relative;
  width: 300px;
  max-width: 100%;
  display: flex;
  align-items: center;
  resize: horizontal;
  overflow: hidden;
  flex: 1;
  border-right: solid 2px var(--vp-c-border, #c2c2c4);
  padding-right: 3rem;
  padding-left: 1rem;
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
  background: var(--vp-c-bg-alt, #f0f0f0);
}
.wrapper::after {
  content: 'Resize me';
  position: absolute;
  right: 0;
  top: 50%;
  writing-mode: tb-rl;
  transform: translateY(-50%);
  font-size: 13px;
  line-height: 1.2;
}

.container {
  width: 100%;
  display: flex;
  align-items: center;
}
.container h3 {
  padding-right: 20px;
  min-width: 0;
}
.container h3.ellipsis {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
```

@tab Javascript

```js
const til = document.querySelector('#title')
document.querySelector('#toggle').addEventListener('change', (e) => {
  til.classList.toggle('ellipsis', e.target.checked)
})
```

:::
::::

---

---
url: /czxBlog/defensive-css/minimum-content-size-in-flex-box/index.md
---
# Minimum Content Size In CSS FlexBox
## Minimum Content Size In CSS FlexBox

CSS FlexBox 的 最小内容大小：
如果 flex 项的文本元素或图像大于项本身，则浏览器不会收缩它们。这是 flexbox 的默认行为。

:::demo-wrapper

可以看到内容发生了溢出，即使我们使用 `overflow-wrap: break-word` 来强制换行，也不会起作用。

```css
.card__title {
  overflow-wrap: break-word;
}
```

要改变 FlexBox 的默认行为，我们需要将 FlexBox 的子项 的 `min-width` 设置为 0。

```css
.card__title {
  overflow-wrap: break-word;
  min-width: 0;
}
```

:::demo-wrapper

***

同样的， 在 列方向上，也可以使用 `min-height` 来改变 FlexBox 的默认行为。

---

---
url: /czxBlog/defensive-css/minimum-content-size-in-grid/index.md
---
# Minimum Content Size In CSS Grid
## Minimum Content Size In CSS Grid

网格布局的最小内容大小：
CSS 网格的子项具有默认的最小内容大小，即 `auto` 。
这意味着，如果存在大于网格项的元素，它将溢出。

```css
.wrapper {
  width: 250px;
  display: grid;
  grid-template-columns: 1fr 100px;
  grid-gap: 20px;
}
```

:::demo-wrapper

由于 左侧栏中的内容长度过宽，大于剩余的内容空间，导致了 内容溢出。

为了解决这个问题，我们有三种不同的解决方案：

1. 在 网格项中使用 `min-width: 0`
2. 使用 `minmax()`
3. 在 网格项中使用 `overflow: hidden`

作为 防御性 CSS 策略，选择使用 哪种方案并不重要，只要能够解决问题即可。

在这里，我们选择 `min-width: 0`

:::demo-wrapper

---

---
url: /czxBlog/defensive-css/scroll-chaining/index.md
---
# Scroll Chaining
## Scroll Chaining

我们可能会经常遇到， 当我们打开一个 modal 框并开始滚动，并滚动到底后继续滚动时，
modal 框的外部容器 `body` 元素还会继续滚动。

这被称之为 **滚动关联(scroll chaining)** 。

:::demo-wrapper no-padding

在过去，我们需要一些技术方案（如，使用JavaScript事件）来解决这个问题。
但是现在，我们可以直接使用 CSS 属性 `overscroll-behavior` 来解决这个问题。

```css
.modal {
  overscroll-behavior-y: contain; /* [!code highlight] */
  overflow-y: auto;
}
```

:::demo-wrapper no-padding

---

---
url: /czxBlog/defensive-css/scroll-gutter/index.md
---
# Scroll Gutter
## Scroll Gutter

与滚动相关的另一件事是滚动条装订线。
以前面的 [例子](/defensive-css/scroll-chaining/) 为例，当内容变长时，添加滚动条将导致布局偏移。
发生布局偏移的原因是为滚动条保留空间。

:::demo-wrapper
\<button type="button" class="add-btn-120" @click="toggle">
{{ show ? '重置内容' : '添加内容' }}


请注意，当内容因显示滚动条而变长时，内容是如何移动的。
我们可以通过使用属性 `scrollbar-gutter` 来避免这种行为。

```css
.body {
  scrollbar-gutter: stable;
}
```

:::demo-wrapper
\<button type="button" class="add-btn-120" @click="toggle2">
{{ show2 ? '重置内容' : '添加内容' }}


`scrollbar-gutter: stable` 将会预先为 滚动条保留空间。
因此，在计算 内填充 `padding` 时，应考虑滚动条的宽度，从而适配 UI 效果。

---

---
url: /czxBlog/defensive-css/scrollbar-on-demand/index.md
---
# Scrollbar On Demand
## Scrollbar On Demand

按需使用滚动条。当下，我们可以控制是否显示滚动条，或者仅在内容较长的时候显示滚动条。
但强烈建议在不确定内容的情况下使用 `auto` 作为 `overflow` 属性值。

:::demo-wrapper

可以看到，即使内容很短，也能看到 滚动条，这对 UI 而言很不利。
在不需要 滚动条的时候看到滚动条是一件令人不快的事情。

使用 `overflow-y: auto` 时，滚动条只有在内容较长时才可见。
这是更好的 视觉交互体验。

:::demo-wrapper

---

---
url: /czxBlog/defensive-css/sticky-with-grid/index.md
---
# Position Sticky With CSS Grid
## Position Sticky With CSS Grid

你有没有试过与 网格布局的 子项 一起使用 `position: sticky`？
网格项的默认行为是拉伸。因此，以下示例中的 aside 元素等于 main 元素高度。

:::demo-wrapper

若要使其按预期工作，需要重置 `align-self` 属性。

```css
aside {
  align-self: start;
  position: sticky;
}
```

:::demo-wrapper

---

---
url: /czxBlog/defensive-css/text-over-image/index.md
---
# Text Over Image
## Text Over Image

在 图像 上显示文本时，需要考虑 图像 加载失败时的情况，文本会成什么样。

看下面的示例：

:::demo-wrapper no-padding

但是，当图片加载失败时, 文本几乎看不见。

:::demo-wrapper no-padding

我们可以通过为 `<img>` 元素添加背景颜色来解决这个问题。
仅当图像加载失败时，此背景才可见。

:::demo-wrapper no-padding

---

---
url: /czxBlog/defensive-css/using-space-between/index.md
---
# Using Space Between
## Using Space Between

在 Flex 容器中， 我们可以使用 `space-between` 来定义项目之间的间距。
当子项的数量 符合我们的 布局预期时，在 UI 效果上来看还不错。
但是，如果 项目的数量过多或过少时，布局就会看起来很糟糕。

请看下面示例：

```css
.wrapper {
  display: flex;
  justify-content: space-between;
}
```

:::demo-wrapper

项目为 4 个时，看起来还不错。

项目为 3 个时，间隔就过大了。

对此，我们有不同的解决方案：

* 使用 `margin` 设置外边距作为间隔
* 使用 flexbox `gap` 设置间隔
* 在父元素上使用 `padding` 作为 子元素 间隔
* 添加空白元素作为间隔

比如，我们使用 `gap` 设置 间隔

```css
.wrapper {
  display: flex;
  gap: 1rem;
}
```

:::demo-wrapper

---

---
url: /czxBlog/defensive-css/variable-fallback/index.md
---
# CSS Variable Fallback
## CSS Variable Fallback

CSS 变量越来越多的应用于前端开发中。
但我们可能在使用 CSS 变量的过程中，可能由于某些原因导致 CSS 变量值为空，特别是，如果这个 CSS 变量
的值是通过 JavaScript 控制的。

下面有一个例子：

```css
.message__bubble {
  max-width: calc(100% - var(--actions-width));
}
```

变量 `--actions-width` 在 CSS 函数 `calc()` 中使用， 它的值通过 JavaScript 控制的。
假设 JavaScript 由于某些原因，设置 `--actions-width` 的值失败了。
这会导致 `calc()` 计算的 `max-width` 值为 无效的，这可能导致 意外的布局问题。

我们可以提前避免这种情况，给 `--actions-width` 设置一个 回退值。

```css
.message__bubble {
  max-width: calc(100% - var(--actions-width, 70px));
}
```

如果未定义变量，将使用回退 `70px` 。
可以使用这种方法避免设置变量可能失败（例如：来自 Javascript）。

---

---
url: /czxBlog/defensive-css/vertical-media-queries/index.md
---
# Vertical Media Queries
## Vertical Media Queries

有时候，构建一个组件，并且通过调整浏览器的宽度的大小进行测试，是非常有用的。
但可能会经常的忽略针对 高度 进行测试。

一种常见的场景是，在一个 main 和 aside 布局的场景中，一些 辅助的导航链接位于 aside 的底部位置。

请看以下示例，辅助导航链接 通过 `position:sticky` 粘在 aside 的底部。在高度足够的情况下，看起来
还不错。

:::demo-wrapper

但是，如果浏览器窗口的高度较小，辅助导航链接会被挤压，与其他内容发生重叠。

:::demo-wrapper

通过使用 CSS 垂直媒体查询，我们可以避免这个问题。

```css
@media (min-height: 600px) {
  .aside__nav {
    position: sticky;
    bottom: 1rem;
  }
}
```

这样，只有当视口高度大于或等于 600px 时，辅助导航才会粘在底部。

可能有更好的方法来实现该行为（例如使用 margin-auto ），但在此示例中专注于 `vertical media queries`。

---

---
url: /czxBlog/design-pattern/index.md
---
# 设计模式

---

---
url: /czxBlog/design-pattern/adapter/index.md
---
# 适配器模式
## 什么是适配器模式？

\==Adapter(适配器)模式== 是一种结构型设计模式。

用于将不兼容的接口转换为客户端期望的接口。它通过创建一个中间层（适配器），
使原本因接口不匹配而无法协作的类或对象能够协同工作。适配器模式的核心是 **转换**，而非修改原有代码。

## 实现适配器模式

在 JavaScript 中，适配器模式可以通过以下两种方式实现：

### 对象适配器

通过组合（持有被适配对象的实例）实现接口转换：

```ts
// 被适配的旧接口
class OldLogger {
  logMessage(message) {
    console.log(`旧日志格式: [${new Date()}] ${message}`)
  }
}

// 新系统期望的接口
class NewLoggerAdapter {
  constructor(oldLogger) {
    this.oldLogger = oldLogger
  }

  // 适配旧接口到新接口
  print(text) {
    this.oldLogger.logMessage(text.toUpperCase()) // 转换逻辑
  }
}

// 使用适配器
const oldLogger = new OldLogger()
const adapter = new NewLoggerAdapter(oldLogger)
adapter.print('hello world') // 输出：旧日志格式: [当前时间] HELLO WORLD
```

### 函数适配器

通过高阶函数包装原有函数：

```ts
// 旧函数：参数顺序是 (width, height)
function calculateArea(width, height) {
  return width * height
}

// 适配器：将新接口 (height, width) 转换为旧接口
const adaptedCalculateArea = (height, width) => calculateArea(width, height)

console.log(adaptedCalculateArea(10, 5)) // 输出 50
```

## 优点

* **解耦性**：分离客户端代码与被适配对象，避免直接依赖不兼容的接口。
* **复用性**：整合旧代码或第三方库时无需修改其源码。
* **灵活性**：适配器可以作为临时过渡方案，支持逐步重构。
* **开闭原则**：通过新增适配器扩展功能，而非修改现有代码。

## 缺点

* **复杂度增加**：过多适配器会使得代码结构复杂，维护成本上升。
* **性能损耗**：额外的调用层可能轻微影响性能（通常可忽略）。
* **可能掩盖问题**：滥用适配器可能导致设计缺陷被隐藏，而非彻底解决。

## 适用场景

* **整合第三方库**：将外部库的接口转换为符合当前系统的接口。
* **旧系统改造**：逐步迁移遗留代码时，新旧接口共存。
* **统一接口规范**：多个类/对象功能类似但接口不同，需统一调用方式。
* **数据格式转换**：如将 XML 响应适配为 JSON 格式。

---

---
url: /czxBlog/design-pattern/builder/index.md
---
# 建造者模式
## 什么是建造者模式？

\==Builder(建造者)模式== 是一种创建型设计模式。

它用于分步骤构建复杂对象。
它通过将对象的构造过程与其表示分离，允许相同的构建过程创建不同的表示。

该模式的核心思想是：

* **分离构建步骤**：将对象的构建分解为多个独立步骤。
* **统一构建流程**：通过一个指挥者（Director）控制构建顺序。
* **灵活组合**：通过不同建造者（Builder）实现不同配置的对象。

## 实现建造者模式

下面是一个简单的示例，展示了建造者模式的实现：

```js
// 1. 产品类（最终要构建的复杂对象）
class Pizza {
  constructor() {
    this.base = null
    this.sauce = null
    this.toppings = []
  }

  describe() {
    return `Pizza with ${this.base} base, ${this.sauce} sauce, and toppings: ${this.toppings.join(', ')}`
  }
}

// 2. 建造者接口（定义构建步骤）
class PizzaBuilder {
  constructor() {
    this.pizza = new Pizza()
  }

  prepareBase(base) {
    this.pizza.base = base
    return this // 返回this支持链式调用
  }

  addSauce(sauce) {
    this.pizza.sauce = sauce
    return this
  }

  addTopping(topping) {
    this.pizza.toppings.push(topping)
    return this
  }

  build() {
    return this.pizza
  }
}

// 3. 指挥者（可选，封装构建流程）
class PizzaDirector {
  constructor(builder) {
    this.builder = builder
  }

  makeMargherita() {
    return this.builder
      .prepareBase('thin crust')
      .addSauce('tomato')
      .addTopping('mozzarella')
      .addTopping('basil')
      .build()
  }

  makePepperoni() {
    return this.builder
      .prepareBase('thick crust')
      .addSauce('spicy tomato')
      .addTopping('pepperoni')
      .addTopping('cheese')
      .build()
  }
}

// 使用示例
const builder = new PizzaBuilder()

// 方式1: 直接使用建造者（链式调用）
const customPizza = builder
  .prepareBase('gluten-free')
  .addSauce('pesto')
  .addTopping('mushrooms')
  .addTopping('olives')
  .build()
console.log(customPizza.describe()) // Pizza with gluten-free base...

// 方式2: 通过指挥者创建预定义对象
const director = new PizzaDirector(builder)
const margherita = director.makeMargherita()
console.log(margherita.describe()) // Pizza with thin crust base...
```

## 优点

* **分离构造与表示**：将对象的构建细节封装在建造者中，客户端无需了解内部结构。
* **灵活扩展**：新增建造者即可支持新类型的对象，符合开闭原则。
* **精细控制构建过程**：分步构建允许精确控制对象配置。
* **复用构建逻辑**：指挥者封装通用构建流程，避免代码重复。
* **链式调用**：提供流畅接口（Fluent Interface），提升代码可读性。

## 缺点

* **增加代码复杂度**：需创建多个新类（产品、建造者、指挥者）。
* **过度设计风险**：简单对象直接构造更高效，无需使用此模式。
* **建造者依赖**：产品类发生变更时，所有建造者都需要同步修改。

## 适用场景

* **构造复杂对象**：当对象需要多个步骤/组件组合时（如配置复杂的 UI 组件）。
* **不同对象变体**：需要创建多个相似但配置不同的对象（如不同套餐的 Pizza）。
* **避免构造函数参数爆炸**：当构造函数参数过多（>4个）且部分可选时。
* **不可变对象**：配合返回新对象的链式调用，适合构建不可变对象。
* **多步骤构造过程**：当对象构造需要特定顺序或条件检查时。

---

---
url: /czxBlog/design-pattern/command/index.md
---
# 命令模式
\==命令模式== 在前端领域的用例相对有限，这里仅做简单的介绍。

## 什么是命令模式？

\==Command(命令)模式== 旨在将方法调用、请求或操作封装到单一对象中，从而根据我们不同的请求对客户进行参数化
和 传递可供执行的方法调用。这种模式将调用操作的对象与知道如何实现该操作的对象解耦，并在交换出具体类（对象）
方面提供更大的整体灵活性。

用基于类的变成语言解释 **具体类** 是最恰当的，它们与抽象类的思想有关。
一个抽象类定义一个结构，但不一定为它所有的成员函数提供实现。
它作为一个基类，派生出其他类。实现确实功能的派生类被称为一个 **具体类**。

```mermaid
classDiagram
  Client --> Receiver
  Client <--> ConcreteCommand
  Receiver <-- ConcreteCommand
  Invoker <--> Command
  Command <-- ConcreteCommand
  class Receiver{
    +action()
  }
  class Command{
    +execute()
  }
  class ConcreteCommand{
    +execute()
  }
```

\==Command(命令)模式== 背后的主要思想是：它为我们提供了一种分离职责的手段，这些职责包括从执行命令的任意地方
发布命令以及将该职责转而委托给不同对象。

实施明智的、简单那的命令对象将把 **Action** 动作和调用该动作的对象绑定在一起。它们始终包括一个执行操作
（如 `run()` 或 `execute()`）。所有具有相同接口的 Command 对象可以根据需要轻松交换，这被认为是该模式的一个更大的好处。

## 使用命令模式

假设我们有一个在线购物系统，用户可以下单、跟踪订单 和 取消订单。

```ts
class OrderManager {
  constructor() {
    this.orders = []
  }

  placeOrder(order, id) {
    this.orders.push(id)
    return `Successfully ordered ${order} (${id})`
  }

  trackOrder(id) {
    return `Order ${id} is in progress`
  }

  cancelOrder(id) {
    this.orders = this.orders.filter(order => order.id !== id)
    return `Order ${id} has been canceled`
  }
}
```

在 `OrderManager` 类中，我们可以访问 `placeOrder`、`trackOrder` 和 `cancelOrder` 方法。

```ts
const manager = new OrderManager()

manager.placeOrder('shoes', '1234')
manager.trackOrder('1234')
manager.cancelOrder('1234')
```

但是，直接在 manager 实例上调用方法也有缺点。我们可能在未来的某些时候，重命名这些方法，或者某些功能发生变化，
或者移除它们。

假设我们把 `placeOrder` 方法重命名为 `addOrder`，这意味着我们需要确保在整个程序应用中没有任何位置调用
`placeOrder` 方法，这在大型的程序中可能是一个大问题。

我们希望将方法与管理者对象解耦，并为每个命令创建独立的命令函数！

我们开始对 `OrderManager` 类进行重构，移除 `placeOrder` 、`trackOrder` 和 `cancelOrder` 方法，
并添加一个新的 `execute` 方法，此方法将执行任何给它的命令。

每个命令都应该可以访问 manager 的 `orders`，我们将作为它的第一个参数传递。

```ts
class OrderManager {
  constructor() {
    this.orders = []
  }

  execute(command, ...args) {
    return command.execute(this.orders, ...args)
  }
}
```

我们需要为订单管理器创建三个 Command：

* `PlaceOrderCommand`
* `CancelOrderCommand`
* `TrackOrderCommand`

```ts
class Command {
  constructor(execute) {
    this.execute = execute
  }
}

function PlaceOrderCommand(order, id) {
  return new Command((orders) => {
    orders.push(id)
    return `Successfully ordered ${order} (${id})`
  })
}

function CancelOrderCommand(id) {
  return new Command((orders) => {
    orders = orders.filter(order => order.id !== id)
    return `Order ${id} has been canceled`
  })
}

function TrackOrderCommand(id) {
  return new Command(() => `Order ${id} is in progress`)
}
```

它们不再直接耦合到 `OrderManager` 实例，而是独立的、解耦的函数，
我们可以通过 `OrderManager` 上可用的 `execute` 方法调用它们。

```ts
class OrderManager {
  constructor() {
    this.orders = []
  }

  execute(command, ...args) {
    return command.execute(this.orders, ...args)
  }
}

const manager = new OrderManager()

manager.execute(new PlaceOrderCommand('shoes', '1234'))
manager.execute(new TrackOrderCommand('1234'))
manager.execute(new CancelOrderCommand('1234'))
```

## 优点

命令模式允许我们将方法与执行作的对象解耦。
如果正在处理具有特定生命周期的命令，或者应该排队并在特定时间执行的命令，它将提供更多控制权。

## 缺点

命令模式的用例非常有限，并且通常会向应用程序添加不必要的样板内容。

---

---
url: /czxBlog/design-pattern/composite/index.md
---
# 组合模式
## 什么是组合模式？

\==Composite（组合）模式== 是一种结构型设计模式。

它用于将对象组织成树形结构，以表示 **“部分-整体”** 的层次关系。
它允许客户端以统一的方式处理单个对象和组合对象，忽略对象层次结构的差异。

组合模式主要由以下部分组成：

### Component（抽象构件）

* 定义所有对象的通用接口（包括叶子节点和容器）。
* 声明操作子节点的方法（如 add、remove）。

### Leaf（叶子节点）

* 表示树中的末端对象（无子节点）。
* 实现 Component 接口的基本行为。

### Composite（容器节点）

* 包含子节点（Leaf 或 Composite）。
* 实现操作和管理子节点的方法。

## 实现组合模式

```js
// 1. 抽象构件
class Component {
  constructor(name) {
    this.name = name
  }

  // 默认抛出错误（叶子节点需重写）
  add(component) {
    throw new Error('Leaf nodes cannot add children.')
  }

  remove(component) {
    throw new Error('Leaf nodes cannot remove children.')
  }

  // 核心方法（所有构件必须实现）
  operation(depth = 0) {
    throw new Error('Subclass must implement operation().')
  }
}

// 2. 叶子节点（无子节点）
class Leaf extends Component {
  operation(depth = 0) {
    console.log(`${' '.repeat(depth * 2)}Leaf: ${this.name}`)
  }
}

// 3. 容器节点（可包含子节点）
class Composite extends Component {
  constructor(name) {
    super(name)
    this.children = []
  }

  add(component) {
    this.children.push(component)
  }

  remove(component) {
    const index = this.children.indexOf(component)
    if (index !== -1)
      this.children.splice(index, 1)
  }

  operation(depth = 0) {
    console.log(`${' '.repeat(depth * 2)}Composite: ${this.name}`)
    // 递归调用子节点的 operation()
    this.children.forEach(child =>
      child.operation(depth + 1)
    )
  }
}

// 客户端使用
const root = new Composite('Root')
const branch1 = new Composite('Branch 1')
const branch2 = new Composite('Branch 2')

root.add(branch1)
root.add(branch2)

branch1.add(new Leaf('Leaf A'))
branch1.add(new Leaf('Leaf B'))
branch2.add(new Leaf('Leaf C'))

root.operation()
```

```console
Composite: Root
  Composite: Branch 1
    Leaf: Leaf A
    Leaf: Leaf B
  Composite: Branch 2
    Leaf: Leaf C
```

## 优点

* **统一处理**：客户端无需区分叶子节点和容器节点。
* **开闭原则**：新增节点类型无需修改现有代码。
* **简化复杂结构**：通过递归机制处理树形结构，代码简洁。
* **灵活性**：动态组合对象，构建任意复杂度的结构。

## 缺点

* **违反单一职责**：Component 需同时管理叶子/容器逻辑（通过异常处理限制叶子节点）。
* **过度泛化**：所有构件使用相同接口，可能包含不适用方法（如叶子节点的 add()）。
* **类型检查问题**：需在运行时检查节点类型（如避免在叶子上调用 add()）。

## 适用场景

* **树形结构处理**：

  * 文件系统（文件是叶子，文件夹是容器）。
  * 组织架构（员工是叶子，部门是容器）。
  * UI 组件库（按钮是叶子，面板是容器）。

* **统一操作需求**：

  * 递归计算（如目录总大小）。
  * 批量执行（如禁用整个表单控件）。

* **嵌套菜单/导航**：

  菜单项（叶子）和子菜单（容器）的统一渲染。

---

---
url: /czxBlog/design-pattern/decorator/index.md
---
# 装饰者模式
## 什么是装饰者模式？

\==Decorator(装饰者)模式== 是一种结构型设计模式。

它允许动态地为对象添加额外的职责，而无需修改其原有代码。
它通过将对象包装在装饰者类中，以透明的方式扩展功能，避免了静态继承带来的类爆炸问题，
符合开闭原则（对扩展开放，对修改关闭）。

## 实现装饰者模式

在 JavaScript 中，装饰者模式可以通过以下方式实现：

### 函数装饰（高阶函数）

通过高阶函数包装原函数，添加新功能：

```ts
function logDecorator(func) {
  return function (...args) {
    console.log('Function called:', func.name)
    const result = func.apply(this, args)
    console.log('Result:', result)
    return result
  }
}

// 使用
const add = (a, b) => a + b
const decoratedAdd = logDecorator(add)
decoratedAdd(2, 3) // 输出日志并计算结果
```

### 对象方法装饰

替换对象的方法以实现增强功能：

```ts
function decorateMethod(obj, methodName, decorator) {
  const originalMethod = obj[methodName]
  obj[methodName] = function (...args) {
    console.log('Method execution started')
    const result = originalMethod.apply(this, args)
    console.log('Method execution ended')
    return result
  }
}

// 使用
const calculator = { add: (a, b) => a + b }
decorateMethod(calculator, 'add', original => original)
calculator.add(1, 2) // 输出执行日志
```

### 类装饰（基于组合）

通过装饰类包裹原对象，扩展其方法：

```ts
class Coffee {
  cost() { return 5 }
}

class MilkDecorator {
  constructor(coffee) {
    this.coffee = coffee
  }

  cost() { return this.coffee.cost() + 2 }
}

class SugarDecorator {
  constructor(coffee) {
    this.coffee = coffee
  }

  cost() { return this.coffee.cost() + 1 }
}

// 使用
let coffee = new Coffee()
coffee = new MilkDecorator(coffee)
coffee = new SugarDecorator(coffee)
console.log(coffee.cost()) // 输出：8
```

### ES7/TypeScript 装饰器语法

利用 `@decorator` 语法糖简化实现（需 Babel 或 TypeScript 支持）：

```ts
function log(target, key, descriptor) {
  const originalMethod = descriptor.value
  descriptor.value = function (...args) {
    console.log(`Calling ${key} with args:`, args)
    return originalMethod.apply(this, args)
  }
  return descriptor
}

class Example {
  @log
  add(a, b) { return a + b }
}
```

## 优点

* **动态扩展**：运行时添加或移除功能，灵活性强。
* **单一职责**：每个装饰类只关注一个功能，代码更清晰。
* **替代继承**：避免多层继承导致的类膨胀问题。
* **开闭原则**：无需修改原有代码即可扩展功能。

## 缺点

* **复杂度增加**：多层装饰可能导致代码结构复杂，调试困难。
* **性能开销**：装饰链较长时，可能影响执行效率。
* **依赖管理**：装饰者需要与原对象保持接口一致，否则可能破坏调用逻辑。

## 适用场景

* **动态功能扩展**：如为对象添加日志、缓存、权限检查等。
* **不可修改的第三方库**：在不修改源码的情况下增强功能。
* **组合替代继承**：需要多维度扩展对象功能时。
* **中间件机制**：如 Express 的中间件、Redux 的 enhancer。

---

---
url: /czxBlog/design-pattern/facade/index.md
---
# 外观模式
:::tip 当系统复杂度达到需要频繁查阅文档才能调用时，就是考虑引入外观模式的最佳时机。它如同一位优秀的翻译官，在复杂的技术细节与简洁的业务逻辑之间架起沟通的桥梁。
:::

## 什么是外观模式？

\==Facade(外观)模式== 是一种结构型设计模式，核心思想是 **为复杂的子系统提供一个简化的统一接口**。
如同建筑外墙隐藏内部结构，它通过创建一个高层接口，将底层模块的复杂性屏蔽，使客户端调用更简单直观。

## 实现外观模式

```ts
// 复杂子系统
class CPU {
  start() { console.log('启动CPU') }
}
class Memory {
  load() { console.log('加载内存') }
}

// 外观接口
class ComputerFacade {
  constructor() {
    this.cpu = new CPU()
    this.memory = new Memory()
  }

  start() {
    this.cpu.start()
    this.memory.load()
    console.log('计算机启动完成')
  }
}

// 客户端调用
const computer = new ComputerFacade()
computer.start() // 隐藏底层细节
```

**实际应用示例：浏览器事件处理**：

```ts
// 封装不同浏览器的事件处理差异
const eventFacade = {
  addListener(element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler, false)
    }
    else if (element.attachEvent) {
      element.attachEvent(`on${type}`, handler)
    }
    else {
      element[`on${type}`] = handler
    }
  },

  removeListener(element, type, handler) {
    // 类似实现移除逻辑...
  }
}

// 统一调用方式
eventFacade.addListener(document.getElementById('btn'), 'click', handleClick)
```

## 优点

* **简化接口**：将复杂调用简化为清晰的方法
* **解耦系统**：客户端与子系统松耦合，易于维护
* **渐进式重构**：逐步替换旧代码的利器
* **安全隔离**：隐藏敏感操作，提升安全性

## 潜在局限

* **过度封装风险**：可能创建"上帝对象"
* **灵活性限制**：需要平衡简化与扩展性

## 最佳实践

* 明确外观层的职责边界
* 避免直接暴露子系统内部
* 保持外观接口的稳定性

---

---
url: /czxBlog/design-pattern/factory/index.md
---
# 工厂模式
你可能每天都在使用 ==工厂模式=={.caution} ！

## 什么是工厂模式？

\==Factory(工厂)== 模式是一种创建型模式，涉及创建对象的概念。

它不显式的要求使用一个构造函数。
Factory 可以提供一个通用的接口来创建对象，我们可以指定我们所希望创建的工厂对象的类型。

```mermaid
classDiagram
  Product <-- ConcreteProduct
  Creator --> ConcreteCreator
  ConcreteProduct <.. ConcreteCreator
  class Creator {
    +factoryMethod()
    +operation()
  }
  class ConcreteCreator {
    +factoryMethod()
  }
```

## 使用工厂模式

假设我们的应用程序需要许多用户。
我们需要创建具有 `firstName`、`lastName` 和 `email` 属性的新用户。
工厂函数还会向新创建的对象添加 `fullName` 属性，该属性将返回 `firstName` 和 `lastName`。

```ts
function createUser({ firstName, lastName, email }) {
  return {
    firstName,
    lastName,
    email,
    fullName() {
      return `${this.firstName} ${this.lastName}`
    },
  }
}
```

我们可以通过调用 `createUser` 函数来轻松创建多个用户。

```ts
const user1 = createUser({
  firstName: 'Jame',
  lastName: 'Wick',
  email: 'jame@wick.com'
})

const user2 = createUser({
  firstName: 'Juan',
  lastName: 'Jonson',
  email: 'juan@jonson.com'
})

console.log(user1)
console.log(user2)
```

对于对象创建过程相对比较复杂，这种方法特别有用。
比如，我们需要根据动态因素或者配置文件创建对象。

```ts
function createStore() {
  if (process.env.NODE_ENV === 'production') {
    return { env: 'production' }
  }

  return { env: 'development' }
}
```

---

---
url: /czxBlog/design-pattern/filter/index.md
---
# 过滤器模式
## 什么是过滤器模式？

\==Filter(过滤器)模式== 是一种结构型设计模式。

它允许使用不同标准过滤一组对象，并通过逻辑操作（AND、OR）组合这些标准。
核心思想是 **解耦过滤逻辑与业务代码，使系统更灵活、可扩展**。
在 JavaScript 中，通常结合高阶函数（如 `filter()`）实现。

## 实现 Filter(过滤器)模式

### 简单实现（函数式风格）

```js
// 过滤器函数
function genderFilter(gender) {
  return persons =>
    persons.filter(p => p.gender === gender)
}

function statusFilter(status) {
  return persons =>
    persons.filter(p => p.maritalStatus === status)
}

// 组合过滤器
const andFilter = (f1, f2) => persons => f2(f1(persons))
function orFilter(f1, f2) {
  return persons =>
    [...new Set([...f1(persons), ...f2(persons)])]
}

// 使用示例
const getSingleFemales = andFilter(
  genderFilter('Female'),
  statusFilter('Single')
)

console.log(getSingleFemales(persons)) // [Alice]
```

### 类实现（对象方面）

```js
// 1. 定义数据对象
class Person {
  constructor(name, gender, maritalStatus) {
    this.name = name
    this.gender = gender
    this.maritalStatus = maritalStatus
  }
}

// 2. 定义过滤器接口
class Criteria {
  meetCriteria(persons) {
    throw new Error('必须实现 meetCriteria 方法')
  }
}

// 3. 具体过滤器实现
class GenderCriteria extends Criteria {
  constructor(gender) {
    super()
    this.gender = gender
  }

  meetCriteria(persons) {
    return persons.filter(p => p.gender === this.gender)
  }
}

class MaritalStatusCriteria extends Criteria {
  constructor(status) {
    super()
    this.status = status
  }

  meetCriteria(persons) {
    return persons.filter(p => p.maritalStatus === this.status)
  }
}

// 4. 组合过滤器 (AND/OR)
class AndCriteria extends Criteria {
  constructor(criteria1, criteria2) {
    super()
    this.criteria1 = criteria1
    this.criteria2 = criteria2
  }

  meetCriteria(persons) {
    return this.criteria2.meetCriteria(this.criteria1.meetCriteria(persons))
  }
}

class OrCriteria extends Criteria {
  constructor(criteria1, criteria2) {
    super()
    this.criteria1 = criteria1
    this.criteria2 = criteria2
  }

  meetCriteria(persons) {
    const result1 = this.criteria1.meetCriteria(persons)
    const result2 = this.criteria2.meetCriteria(persons)
    // 合并并去重
    return [...new Set([...result1, ...result2])]
  }
}

// 5. 使用示例
const persons = [
  new Person('Alice', 'Female', 'Single'),
  new Person('Bob', 'Male', 'Single'),
  new Person('Charlie', 'Male', 'Married')
]

// 创建过滤器
const female = new GenderCriteria('Female')
const single = new MaritalStatusCriteria('Single')
const singleFemale = new AndCriteria(female, single)
const maleOrSingle = new OrCriteria(
  new GenderCriteria('Male'),
  single
)

// 应用过滤器
console.log(singleFemale.meetCriteria(persons))
// 输出: [Person{name: 'Alice', ...}]

console.log(maleOrSingle.meetCriteria(persons))
// 输出: [Bob, Charlie, Alice] (男性或单身)
```

## 优点

* **开闭原则**：新增过滤标准无需修改已有代码。
* **解耦**：过滤逻辑与业务逻辑分离。
* **可组合性**：通过 AND/OR 轻松组合多个条件。
* **复用性**：过滤器可在多处重复使用。
* **函数式友好**：天然契合 JavaScript 的高阶函数特性。

## 缺点

* **性能开销**：链式过滤可能需多次遍历数据（大型数据集需优化）。
* **类膨胀**：每个新标准需创建新类（可改用函数式简化）。
* **过度设计**：简单场景下直接使用 Array.filter() 更合适。

## 适用场景

* **动态查询条件**：如电商产品的多维度筛选（价格、品牌、评分）。
* **数据报表**：按不同业务标准过滤统计信息。
* **权限系统**：组合角色/权限规则过滤用户。
* **API 数据过滤**：后端返回数据集，前端按需过滤展示。
* **复杂条件组合**：需要支持 AND/OR/NOT 逻辑的查询。

---

---
url: /czxBlog/design-pattern/flyweight/index.md
---
# 享元模式
## 什么是享元模式？

\==Flyweight(享元)模式== 是一种结构型设计模式，用于优化重复、缓慢以及数据共享效率较低的代码。

它旨在通过与相关的对象共享尽可能多的数据来减少应用程序中内存的使用（如：应用程序配置、状态等）。

Flyweight 数据共享会涉及获取多个对象使用的若干相似对象或数据结构，
以及将这些数据放到一个单一的外部对象中。
我们可以将该对象传递给依赖这些数据的对象，而不是在每一个对象都存储相同的数据。

## 使用享元模式

我们通过实现一个系统来管理图书馆中的所有书籍。

我们使用构造函数来创建图书馆中的书籍，每个书籍都有 `id`、 `title`、`author`、`isbn` 等基本属性，
同时，还需要使用 `checkoutDate`、`checkoutMember` `dueReturnDate` 等属性来管理借阅信息。

```ts
class Book {
  constructor(id, title, author, isbn) {
    this.title = title
    this.author = author
    this.isbn = isbn
    this.id = id
    this.checkoutDate = null
    this.checkoutMember = null
    this.dueReturnDate = null
  }
}
```

还需要添加 `updateCheckout` 方法来更新借阅信息:

```ts
class Book {
  // ...
  updateCheckout(checkoutDate, checkoutMember, dueReturnDate) {
    this.checkoutDate = checkoutDate
    this.checkoutMember = checkoutMember
    this.dueReturnDate = dueReturnDate
  }
}
```

`Book` 的每一个实例表示一本书。在刚开始对于少量书籍可能是行得通的。
但是，当图书馆夸大到拥有一个更大的库存，每本书都有多个副本时，就会发现随着时间的推移，
管理系统运行的越来越慢，使用数以千计的书籍对象可能会淹没可用内存。

我们可以使用 ==享元模式== 来改善这个问题。

我们将 `Book` 的数据分为 内部状态和 外部状态 两个部分。

内部状态包含 `title`、`author`、`isbn` 等基本属性。
外部状态包含 `checkoutDate`、`checkoutMember` `dueReturnDate` 等属性。

`Book` 只需要存储内部状态，虽然仍然会处理相当多的书籍对象，当需要处理的数据明显减少了：

```ts
export class Book {
  constructor(title, author, isbn) {
    this.title = title
    this.author = author
    this.isbn = isbn
  }
}
```

我们可以使用一个工厂来创建 `Book`，该工厂会返回一个 `Book` 的实例，在集合中存储图书馆中的书，
当往集合中添加数据时，如果该书已存在，则不会添加，否则往集合中添加新的实例。

```ts
const bookDatabase: Map<Book> = new Map()

export function createBook(title, author, isbn) {
  if (bookDatabase.has(isbn)) {
    return bookDatabase.get(isbn)
  }
  else {
    const book = new Book(title, author, isbn)
    bookDatabase.set(isbn, book)
    return book
  }
}
```

我们还需要追踪图书馆的书籍总数，书籍可能存在或者多个副本，当我们添加新的副本时，我们不必要每次都创建新的 `Book` 实例，
而是可以复用已经存在的 `Book` 实例：

```ts
const bookList = [] // 图书馆中的书籍（包含副本）

function addBook(title, author, isbn, sales, availibility) {
  const book = createBook(title, author, isbn)
  bookList.push({
    book,
    sales,
    availibility,
    isbn,
  })
}
```

而对于书籍借出记录，我们也进行单独的管理:

```ts
const bookCheckoutRecords = new Map()

function addRecord(isbn, checkoutDate, checkoutMember, dueReturnDate) {
  // 从图书馆中找到对应的可用的书籍
  const item = bookList.find(book => book.isbn === isbn && book.availibility)
  if (item) {
    const record = {
      book: item.book,
      checkoutDate,
      checkoutMember,
      dueReturnDate
    }
    item.availibility = false
    const recordId = `${isbn}-${checkoutMember}-${checkoutDate}`
    bookCheckoutRecords.set(recordId, record)
  }
  else {
    console.log(`isbn ${isbn} is not available`)
  }
}
```

完美！在图书馆书籍总数 和 借出记录中，我们复用了 `book` 对象，不必每次都创建新的 `Book` 对象。

当我们添加新的书籍副本时：

```ts
addBook('JavaScript', 'James', '978-1-59327-482-1', 100, true)
addBook('JavaScript', 'Jams', '978-1-59327-482-1', 100, true)
addBook('HTML', 'Jhon', '978-1-59327-482-2', 80, true)
addBook('HTML', 'Jhon', '978-1-59327-482-2', 80, false)
addBook('CSS', 'Yang', '978-1-59327-482-3', 50, true)
```

虽然书籍总数增加了 5 本，但在 bookDatabase 中，只新增了 3 本不同的图书。

当我们添加新的借出记录时，如果图书馆中有对应的书籍，那么就可以复用已经存在的 `book` 对象，不必创建新的 `book` 对象。

```ts
addRecord('978-1-59327-482-1', '2022-01-01', 'Jams', '2018-01-31')
addRecord('978-1-59327-482-2', '2022-01-01', 'Li', '2018-02-01')
addRecord('978-1-59327-482-3', '2022-01-01', 'Huang', '2018-03-31')
addRecord('978-1-59327-482-4', '2022-01-01', 'Has', '2018-04-11')
```

## 优点

当我们需要创建大量对象时，并且在这些对象中存在大量相同的数据时，享元模式 非常有用，可以大大减少内存开销。

---

---
url: /czxBlog/design-pattern/interceptor/index.md
---
# 拦截过滤器模式
## 什么是拦截过滤器模式？

\==Interceptor(拦截过滤器)模式== 是一种结构型设计模式。

它用于在请求处理流程中动态添加预处理（如验证、日志）和后处理逻辑。
它通过可插拔的过滤器链在核心业务逻辑执行前后拦截请求/响应，实现横切关注点（Cross-Cutting Concerns）的解耦。

它主要由 四个部分 组成：

### 过滤器（Filter）

执行具体拦截任务的独立模块（如身份验证、日志记录）。

### 过滤器链（Filter Chain）

管理过滤器的有序执行，控制流程传递。

### 目标对象（Target）

核心业务逻辑（如 API 处理器）。

### 过滤器管理器（Filter Manager）

创建和组装过滤器链（可选）。

## 实现拦截过滤器模式

::: steps

* 创建过滤器接口

  ```js
  class Filter {
    execute(request, response, chain) {
      throw new Error('execute() must be implemented')
    }
  }
  ```

* 实现具体过滤器

  ```js
  // 身份验证过滤器
  class AuthFilter extends Filter {
    execute(request, response, chain) {
      console.log('AuthFilter: Checking authentication')
      if (!request.headers.token) {
        throw new Error('Unauthorized!')
      }
      chain.execute(request, response) // 传递到下一个过滤器
    }
  }

  // 日志过滤器
  class LogFilter extends Filter {
    execute(request, response, chain) {
      console.log(`LogFilter: ${request.url} at ${new Date()}`)
      chainexecute(request, response)
      consolelog('LogFilter: Response sent')
    }
  }
  ```

* 创建过滤器链

  ```js
  class FilterChain {
    constructor() {
      this.filters = []
      this.target = null
    }

    addFilter(filter) {
      this.filters.push(filter)
      return this // 支持链式调用
    }

    setTarget(target) {
      this.target = target
    }

    execute(request, response) {
      if (this.filters.length === 0) {
        this.target?.execute(request, response)
        return
      }

      const [currentFilter, ...remainingFilters] = this.filters
      const nextChain = new FilterChain()
      nextChain.filters = remainingFilters
      nextChain.target = this.target

      currentFilter.execute(request, response, nextChain)
    }
  }
  ```

* 目标对象（业务逻辑）

  ```js
  class ApiHandler {
    execute(request, response) {
      console.log('Processing API request')
      response.status = 200
      response.body = { data: 'Success' }
    }
  }
  ```

* 客户端使用

  ```js
  // 组装过滤器链
  const chain = new FilterChain()
  chain
    .addFilter(new AuthFilter())
    .addFilter(new LogFilter())
    .setTarget(new ApiHandler())

  // 模拟请求
  const request = { url: '/api/data', headers: { token: 'abc123' } }
  const response = {}

  try {
    chain.execute(request, response)
    console.log('Response:', response)
  }
  catch (err) {
    console.error('Error:', err.message)
  }

  // 输出顺序:
  // AuthFilter: Checking authentication
  // LogFilter: /api/data at [timestamp]
  // Processing API request
  // LogFilter: Response sent
  // Response: { status: 200, body: { data: "Success" } }
  ```

:::

## 优点

* **解耦性**

  业务逻辑与横切关注点（如日志、安全）分离。

* **可复用性**

  过滤器可在不同场景重复使用。

* **灵活扩展**

  动态增删过滤器，无需修改核心代码。

* **职责清晰**

  每个过滤器专注单一任务。

## 缺点

* **性能开销**

  链式调用增加额外处理时间。

* **调试复杂度**

  多级过滤增加调试难度。

* **过度设计风险**

  简单场景可能引入不必要的复杂性。

---

---
url: /czxBlog/design-pattern/mediator/index.md
---
# 中介者模式
> \==中介者==，指 “协助谈判和解决冲突的中立方”

## 什么是中介者模式？

\==中介者模式== 是一种行为型设计模式。它允许我们公开一个统一的接口，系统的不同部分可以通过该接口进行通信。

如果一个系统的各个组件之间看起来有太多的直接关系，也许是时候需要一个中心控制点了，以便各个组件可以通过
这个中心控制点进行通信。

Mediator 模式促进松散耦合的方式是：确保组件的交互是通过这个中心点来处理的，而不是通过显式地引用彼此。
这种模式可以帮助我们解耦系统并提高组件的可重用性。

一个典型的例子是机场交通控制系统。机场控制塔（中介者）处理飞机的起飞和降落，因为所有的通信（监听到货发出的通知）
都是从飞机到控制塔，而不是从飞机和飞机直接相互听信的。
中央控制系统是该系统成功的关键，而这也是中介者在软件设计中所担任的角色。

```mermaid
classDiagram
  Colleague1 <--> Mediator
  Mediator <--> Colleague4
  Mediator <--> Colleague5
  Colleague2 <--> Mediator
  Colleague3 <--> Mediator
  class Colleague1 {
    +mediator
  }
  class Colleague2 {
    +mediator
  }
  class Colleague3 {
    +mediator
  }
  class Colleague4 {
    +mediator
  }
  class Colleague5 {
    +mediator
  }
  class Mediator {
    +component
  }
```

## 使用中介者模式

我们来实现一个简单的 聊天室 应用，在这个应用中，用户之间不会直接交谈，而是通过将消息发送到
聊天室（中介者）中，再由聊天室将消息广播给其他用户。

```ts
class ChatRoom {
  logMessage(user, message) {
    const time = new Date()
    const sender = user.getName()

    console.log(`${time} [${sender}]: ${message}`)
  }
}

class User {
  constructor(name, chatroom) {
    this.name = name
    this.chatroom = chatroom
  }

  getName() {
    return this.name
  }

  send(message) {
    this.chatroom.logMessage(this, message)
  }
}
```

在这个应用中，我们创建一个聊天室（中介者）实例，然后创建新的用户实例加入到聊天室中，
用户通过 `send()` 将消息发送给其他用户：

```ts
const chatroom = new ChatRoom()

const user1 = new User('John', chatroom)
const user2 = new User('Jane', chatroom)
const user3 = new User('Bob', chatroom)

user1.send('Hi!')
user2.send('Hello!')
```

## 优点

* **降低复杂度**：将多个对象间的一对多关系转换为一对一关系。
* **解耦**：对象之间不再直接引用，通过中介者进行交互。
* **符合迪米特原则**：对象只需知道中介者，不需要知道其他对象。

## 缺点

中介者可能会变得庞大和复杂，难以维护。

## 中介者 与 观察者

> 在 Observer 模式中，不存在封装约束的单一对象。Observer 和 Subject (合作) 必须合作才能维持约束。
> Communication (通信) 模式由观察者和目标互连的方式所决定：
> 单一目标通常有很多观察者，有时一个目标的观察者是另一个观察者的目标。

中介者 和 观察者 都能够促进松耦合；然而，中介者模式通过限制对象严格通过 中介者进行通信来实现这一目的。
观察者模式创建观察者对象，观察者对象订阅他们的对象发布其感兴趣的事件。

---

---
url: /czxBlog/design-pattern/middleware/index.md
---
# 中间件模式
::: tip
中间件模式通过将复杂流程分解为独立处理单元，显著提升了代码的可维护性和扩展性，
是 JavaScript 生态中不可或缺的设计模式。
:::

## 什么是中间件模式？

\==Middleware(中间件)模式== 是一种通过串联多个处理函数来处理请求的设计模式。

每个函数（中间件）接收输入，执行特定操作，可选择修改数据，并将控制权传递给下一个函数。
这种模式在 Web 开发（如 **Express/Koa**）、数据流处理等场景中广泛应用。

```mermaid
flowchart TD
  I[Input]
  O[Output]
  I --> Middleware1 -- next --> Middleware2 -- next --> O
```

## 实现中间件模式

以下是基于 Express 风格的中间件实现：

```js
function createMiddleware() {
  const middlewares = []

  const use = fn => middlewares.push(fn)

  const execute = async (context) => {
    let index = 0
    const next = async () => {
      if (index < middlewares.length) {
        const middleware = middlewares[index++]
        await middleware(context, next) // 关键：传入next实现链式调用
      }
    }
    await next()
  }

  return { use, execute }
}

// 使用示例
const app = createMiddleware()

// 中间件1：日志记录
app.use(async (ctx, next) => {
  console.log('Request started at', new Date())
  await next() // 传递控制权
  console.log('Request ended')
})

// 中间件2：数据处理
app.use(async (ctx, next) => {
  ctx.data = { modified: true }
  await next()
})

// 执行中间件链
const context = {}
app.execute(context).then(() => {
  console.log('Context:', context) // 输出修改后的数据
})
```

### 核心流程

* **注册顺序**：中间件按 use() 调用顺序排列。
* **控制传递**：next() 将执行权交给下一个中间件。
* **洋葱模型**：执行顺序类似洋葱（请求从外向内，响应从内向外）。

## 优点

* **解耦性**：每个中间件专注单一职责（如日志、验证）。
* **可扩展性**：动态添加/移除中间件，无需修改核心逻辑。
* **灵活性**：支持异步操作（通过 async/await）。
* **复用性**：通用中间件（如 CORS 处理）可跨项目复用。

## 缺点

* **性能开销**：多层函数调用可能影响性能（需控制中间件数量）。
* **错误处理复杂**：需统一错误处理机制（如 Express 的 error-handling middleware）。
* **调试困难**：深层调用栈增加调试难度。
* **顺序依赖**：中间件顺序错误可能导致逻辑问题（如先验证后解析 Body）。

## 适用场景

* **Web 框架**：

  * 请求/响应处理（Express/Koa）。
  * 身份验证、日志、压缩、CORS。

* **数据处理管道**：

  * 数据转换链（如图像处理管道）。
  * 消息队列消费流程。

* **状态管理**：

  Redux 中间件（如 redux-thunk、redux-logger）。

* **构建工具**：

  Webpack 插件（基于 tapable 的中间件系统）。

---

---
url: /czxBlog/design-pattern/mixin/index.md
---
# 混入模式
::: tip
Mixin 模式在 JavaScript 中提供了一种强大的代码复用机制，尤其适合需要横向扩展功能的场景。
然而，需谨慎处理命名冲突和代码组织问题。随着 ES6 Class 和组合式 API（如 Vue 3 Composables、React Hooks）的普及，Mixin 的使用有所减少，但其核心思想（组合优于继承）仍是现代开发的重要原则。
:::

## 什么是混入模式？

\==Mixin(混入)模式== 是一种行为型设计模式，它允许在不使用传统继承的情况下向类或对象添加功能。
它通过组合而非继承实现代码复用，支持将多个功能模块（Mixin）动态“混合”到目标对象中，避免了单继承的局限性。

```mermaid
classDiagram
  newObject <-- Mixin1
  newObject <-- Mixin2
  class Mixin1 {
    +operation1()
  }
  class Mixin2 {
    +operation2()
  }
  class newObject {
    +operation1()
    +operation2()
  }
```

## 实现混入模式

### 对象合并

将 Mixin 对象的方法复制到目标类的原型中（使用 `Object.assign`）：

```js
const loggerMixin = {
  log(message) {
    console.log(`Log: ${message}`)
  }
}

class User {}
Object.assign(User.prototype, loggerMixin)

const user = new User()
user.log('Hello') // Log: Hello
```

### 函数式混入

通过函数返回扩展后的类，支持链式组合多个 Mixin：

```js
function Serializable(Base) {
  return class extends Base {
    serialize() {
      return JSON.stringify(this)
    }
  }
}

function Loggable(Base) {
  return class extends Base {
    log() { console.log('Logged') }
  }
}

class User {}
const EnhancedUser = Serializable(Loggable(User))
const user = new EnhancedUser()
user.serialize() // 调用 Serializable 方法
```

## 优点

* **灵活复用代码**

  跨不同类共享功能，无需建立复杂的继承链。

* **避免继承陷阱**

  解决单继承限制，支持多 Mixin 组合。

* **模块化清晰**

  功能拆分为独立模块，便于维护和扩展。

* **动态组合**

  运行时按需添加或移除功能。

## 缺点

* **命名冲突**

  多个 Mixin 的同名方法/属性可能被覆盖（如 serialize 方法重复）。

* **隐式依赖**

  代码逻辑分散，难以追踪方法来源。

* **原型污染**

  直接修改原型可能导致副作用（如影响其他实例）。

* **类型检查失效**

  instanceof 无法检测 Mixin 的存在。

## 适用场景

* **跨层级共享功能**

  例如日志、事件管理、序列化等通用功能。

* **替代多继承**

  需要组合多个独立功能的场景（如游戏角色的技能系统）。

* **动态扩展对象**

  运行时按需增强对象能力（如插件系统）。

---

---
url: /czxBlog/design-pattern/module/index.md
---
# 模块模式
::: warning 建议优先使用 ES6 模块（静态加载、显式依赖）和 class（面向对象）实现类似功能。

模块模式的价值更多体现在遗留项目维护或需要精细控制闭包的场景中。
:::

## 什么是模块模式？

\==Module (模块)模式== 是用于封装代码、实现私有作用域的一种设计模式。

它通过闭包和立即执行函数表达式（IIFE），将变量和方法划分为“私有”和“公有”两部分，从而减少全局污染、提高代码可维护性。

## 实现模块模式

### 基本模块模式

通过 IIFE 创建闭包，返回一个包含公有方法的对象：

```ts
const myModule = (function () {
  // 私有变量和方法
  let privateVar = '私有数据'
  function privateMethod() {
    console.log(privateVar)
  }

  // 公有接口
  return {
    publicMethod() {
      privateMethod()
    },
  }
})()

myModule.publicMethod() // 输出 "私有数据"
```

### 揭示模块（Revealing Module）模式

明确声明公有方法，直接暴露内部函数引用，增强可读性：

```ts
const myModule = (function () {
  function privateMethod() { /* ... */ }
  function publicMethod() {
    privateMethod()
  }

  return { publicMethod } // 直接暴露公有方法
})()
```

### 其它

* AMD 模块
* CommonJS 模块
* ES6 模块

## 优点

* **封装性**

  私有变量和方法仅在模块内部可见，避免外部误操作。

* **减少全局污染**

  所有逻辑封装在模块内，避免全局命名冲突。

* **代码组织清晰**

  通过公有接口管理外部可访问的方法，提高可维护性。

* **支持依赖注入**

  可通过参数注入依赖（如 jQuery）：

  ```ts
  const myModule = (function ($) {
    // 使用 $ 作为局部变量
  })(jQuery)
  ```

## 缺点

* **内存占用**

  闭包导致私有变量无法被垃圾回收，长期存在可能增加内存消耗。

* **扩展性差**

  模块是单例的，难以直接继承或扩展（需通过组合或混入模式实现）。

* **测试困难**

  私有方法无法直接测试，需通过公有接口间接验证。

* **ES6 替代方案**

  ES6 模块（import/export）和 class 语法更现代，模块模式在部分场景下已过时。

---

---
url: /czxBlog/design-pattern/mvc/index.md
---
# MVC
:::info
MVC 实际上是三个经典设计模式的变体：Observer （观察者）模式、Strategy （策略）模式 和 Composite（组合）模式。
它也可以使用 Factory （工厂）模式 和  Template（模板）模式。
:::

## 什么是MVC模式？

MVC 是一种软件设计模式，它将应用程序分成三个部分：**Model**，**View**，**Controller**。

```mermaid
flowchart TD
  V["`**View**
  *UI,Represets current model state*`"]
  C["`**Controller**
  *Makes decision
  for the View*`"]
  M["`**Model**
  *Domain-specific
  data*`"]
  IO(User Input/
  Display Output)
  IO <==> V
  V -. "Pull data <br>via getters" .-> M
  C -. "Pull data <br>via getters" .-> M
  V -- "Updates" --> C
  M -- "Informs<br>Observers <br>Of Changes" --> V
  C -- "Passes<br>calls" --> V
  C -- "Modifies" --> M
  V -- "Observers" --> M
```

### Model

Model 管理应用程序的数据。Model 不涉及用户界面，也不涉及表示层，而是代表应用程序可能需要的特度形式的数据。
当 Model (模型) 改变时，它通常会通知它的观察者（如 View），以便它们可以做出相应的改变（更新）。

### View

视图是 Model 的可视化表示，表示当前状态的筛选视图。一个 View 通常检测一个 Model，并在 Model 更改是进行通知，
使 View 本身能够相应的更新。

用户可以与 View 交互，包括读取和编辑 Model ，即在 Model 中获取或设置属性值。

### Controller

Controller 是 Model 和 View 之间的中介，当用户操作 View 时，它通常负责更新 Model 。

## 实现 MVC 模式

在 JavaScript 中，MVC 常用于构建单页应用（SPA），通过解耦代码提升可维护性。

以下是一个原生 JavaScript 实现的简单 Todo 应用：

::: code-tabs

@tab index.js

```js
import TodoController from './todo-controller'
import TodoModel from './todo-model'
import TodoView from './todo-view'

// 初始化
const model = new TodoModel()
const view = new TodoView()
const controller = new TodoController(model, view)
```

@tab todo-model.js

```js
class TodoModel {
  constructor() {
    this.todos = []
    this.listeners = []
  }

  addTodo(text) {
    this.todos.push({ text, completed: false })
    this.emitChange()
  }

  toggleTodo(index) {
    this.todos[index].completed = !this.todos[index].completed
    this.emitChange()
  }

  on(event, listener) {
    this.listeners.push(listener)
  }

  emitChange() {
    this.listeners.forEach(listener => listener(this.todos))
  }
}
```

@tab todo-view.js

```js
class TodoView {
  constructor() {
    this.todoList = document.getElementById('todo-list')
    this.addButton = document.getElementById('add-todo')
    this.input = document.getElementById('todo-input')
  }

  bindAddTodo(handler) {
    this.addButton.addEventListener('click', () => {
      const text = this.input.value
      if (text) {
        handler(text)
        this.input.value = ''
      }
    })
  }

  render(todos) {
    this.todoList.innerHTML = todos
      .map((todo, index) => `
        <li class="${todo.completed ? 'completed' : ''}">
          ${todo.text}
          <button onclick="controller.toggleTodo(${index})">✓</button>
        </li>
      `)
      .join('')
  }
}
```

@tab todo-controller.js

```js
class TodoController {
  constructor(model, view) {
    this.model = model
    this.view = view

    this.view.bindAddTodo(this.handleAddTodo.bind(this))
    this.model.on('change', todos => this.view.render(todos))
  }

  handleAddTodo(text) {
    this.model.addTodo(text)
  }

  toggleTodo(index) {
    this.model.toggleTodo(index)
  }
}
```

:::

## 优点

* **解耦代码**：数据、界面、逻辑分离，便于维护。
* **可复用性**：View 可复用（如 Web 和移动端共用 Model）。
* **可测试性**：Model 和 Controller 可独立测试。
* **团队协作**：不同开发者可并行开发不同组件。

## 缺点

* **复杂度高**：小型项目可能因分层过度而冗余。
* **数据流混乱**：若未严格分层，可能导致 View 直接操作 Model。
* **性能开销**：频繁的 DOM 更新可能影响性能（需优化或结合虚拟 DOM）。

## 适用场景

* 复杂交互的 SPA（如管理后台、社交平台）。
* 长期维护的项目：结构清晰降低迭代成本。
* 团队协作开发：明确分工，减少代码冲突。

---

---
url: /czxBlog/design-pattern/mvp/index.md
---
# MVP
::: tip
MVP 模式通过强制视图与逻辑解耦，显著提升前端代码的可维护性和可测试性，特别适合业务复杂的 Web 应用。
尽管在现代框架（如 React/Vue）中部分职责被组件化替代，但其分层思想仍深刻影响前端架构设计。
:::

## 什么是MVP模式？

MVP (模型-视图-表示器) 是 一种用户界面架构模式，核心目标是分离业务逻辑与视图逻辑，
提升代码可维护性和可测试性。它是 MVC 的变体，通过明确角色分工解决传统 MVC 在 Web 前端中的耦合问题。

```mermaid
flowchart TD
  V["`**View**
  *UI and UI events*`"]
  P["`**Presenter**
  *Formats data for display*`"]
  M["`**Model**
  *Domain-specific data*`"]

  V -- Passes calls --> P
  P -- Manipulates --> M
  M -- Raises events --> P
  P -- Updates --> V
```

它将应用程序分成三个部分：**Model**，**View**，**Presenter**。

### Model (模型)

负责数据和业务逻辑（如数据获取、验证、存储）。

独立于 UI，不直接与 View 交互。

### View (视图)

被动的 UI 层，仅负责渲染和用户输入转发。

通过接口/约定与 `Presenter` 通信（无业务逻辑）。

### Presenter（协调器）

中介者角色：监听 View 事件，调用 Model，更新 View。
包含展示逻辑（如数据格式化、状态控制）。

## 实现 MVP 模式

::: code-tabs

@tab index.js

```js
// 初始化
const model = new UserModel()
const view = new UserListView()
const presenter = new UserPresenter(model, view)

// 首次渲染
presenter.loadInitialData()
```

@tab user-model.js

```js
class UserModel {
  constructor() {
    this.users = []
  }

  addUser(name) {
    this.users.push({ id: Date.now(), name })
    return this.users
  }
}
```

@tab user-list-view.js

```js
class UserListView {
  constructor(presenter) {
    this.presenter = presenter
    this.list = document.getElementById('user-list')
    this.form = document.getElementById('user-form')
    this.form.addEventListener('submit', e => this.onSubmit(e))
  }

  render(users) {
    this.list.innerHTML = users.map(u => `<li>${u.name}</li>`).join('')
  }

  onSubmit(e) {
    e.preventDefault()
    const name = document.getElementById('name-input').value
    this.presenter.addUser(name) // 转发给 Presenter
  }
}
```

@tab user-presenter.js

```js
class UserPresenter {
  constructor(model, view) {
    this.model = model
    this.view = view
  }

  addUser(name) {
    if (!name.trim())
      return // 简单验证
    const updatedUsers = this.model.addUser(name)
    this.view.render(updatedUsers) // 更新视图
  }
}
```

:::

## 优点

* **关注点分离**

  View 只处理 UI，Model 只处理数据，Presenter 负责协调。

* **高可测试性**

  Presenter 可脱离 View 测试（通过 Mock View）。

* **避免框架依赖**

  View 可为原生 DOM 操作，易于替换 UI 库。

* **清晰的代码结构**

  各层职责明确，适合团队协作

## 缺点

* **复杂度增加**

小型项目可能过度设计（需手动绑定事件/更新视图）。

* **Presenter 膨胀风险**

复杂页面可能导致 Presenter 臃肿（需拆分或引入状态管理）。

* **手动更新视图**

相比 MVVM 的自动绑定，需手动调用 `render()` 。

---

---
url: /czxBlog/design-pattern/mvvm/index.md
---
# MVVM
## 什么是 MVVM 模式？

\==MVVM（Model-View-ViewModel）== 是一种用于分离用户界面逻辑与业务逻辑的架构模式，核心是数据驱动视图。
它通过 **ViewModel** 将 **Model** 和 **View** 解耦，实现双向数据绑定：

```mermaid
flowchart TD
  V["`**View**
  *User interface*`"]
  VM["`**View Model**
  *State and Operations*`"]
  M["`**Model**
  *Domain-specific data*`"]

  V -- Data bindings<br>and commands --> VM
  VM -- Updates --> M
  M -- Sends notifications --> VM
  VM -- Sends notifications --> V
```

### Model

数据模型（如 API 数据、业务逻辑）。

### View

用户界面（DOM 元素）。

### ViewModel

连接 Model 和 View 的桥梁，处理数据转换和交互逻辑。

## 实现 MVVM 模式

以 Vue.js 为例，核心机制是响应式系统和模板引擎：

```html
<!-- View (HTML模板) -->
<div id="app">
  <input v-model="message"> <!-- 双向绑定 -->
  <p>{{ message }}</p>     <!-- 数据渲染 -->
</div>
```

```js
// ViewModel (Vue实例)
const vm = new Vue({
  el: '#app',
  data: {
    message: 'Hello MVVM!' // Model数据
  }
})

// 修改Model自动更新View
vm.message = 'Updated!' // <p>内容同步变化
```

## 关键机制

* 双向数据绑定

  View（如输入框）修改 → 自动更新 Model → ViewModel 通知其他依赖视图更新。

* 依赖追踪

  Vue 通过 `Object.defineProperty`/ `Proxy` 监听数据变化，触发视图更新。

* 模板编译

  将模板（如 `{{ message }}`）编译为虚拟 DOM，高效更新真实 DOM。

## 优点

| 优点           | 说明                                               |
| -------------- | -------------------------------------------------- |
| **开发效率高** | 自动同步数据视图，减少手动 DOM 操作（如 jQuery）。 |
| **代码解耦**   | View、ViewModel、Model 职责分离，便于维护。        |
| **可测试性**   | ViewModel 可独立测试（不依赖 UI）。                |
| **数据驱动**   | 聚焦数据变化，而非视图操作。                       |

## 缺点

| 缺点         | 说明                                               |
| ------------ | -------------------------------------------------- |
| **学习曲线** | 需理解响应式原理、虚拟 DOM 等概念。                |
| **性能开销** | 深度监听大对象或频繁更新可能影响性能（需优化）。   |
| **过度绑定** | 滥用双向绑定可能导致数据流混乱（推荐单向数据流）。 |
| **黑箱化**   | 框架封装复杂，调试底层问题较困难。                 |

---

---
url: /czxBlog/design-pattern/observer/index.md
---
# 观察者模式
## 什么是观察者模式？

::: important 《设计模式：可复用面向对象软件的基础》
一个或多个观察者对目标的状态感兴趣，它们通过将自己依附在目标对象上以便注册所感兴趣的内容。
目标状态发生改变并且观察者可能对这些状态感兴趣，就会发送一个通知消息，调用每个观察者的更新方法。
当观察者不在对目标状态感兴趣时，它们可以简单地将自己从中分离。
:::

在 ==观察者模式== 中，一个对象被称为 **被观察者（Subject）** ，它维持着一系列的依赖于它（观察者）的对象，
将有关状态的任何变更自动通知给他们（观察者）。

当一个目标需要告诉观察者发生了什么事情，它会向观察者广播一个通知（可以包括与通知主题相关的特定数据）。

当我们不在希望某个特定的观察者获得其注册目标发出的改变通知时，该目标可以将它从观察者列表中删除。

## 使用 观察者模式

一个 Observer 对象通常包含三个重要组成部分：

* **observers**： 观察者数组，每当特定目标状态发生改变时，观察者会接受到通知。
* **subscribe() / unsubscribe()**： 将 `observer` 添加到 `observers` 列表，或者从 `observers` 列表中移除
* **notify()**： 用于通知所有观察者，目标状态已经发生改变的方法

在 `ES6` 中，我们可以使用 `class` 来实现：

```ts
class Observable {
  constructor() {
    this.observers = []
  }

  subscribe(observer) {
    if (!this.observers.includes(observer))
      this.observers.push(observer)
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter(item => item !== observer)
  }

  notify(context) {
    this.observers.forEach(observer => observer(context))
  }
}
```

我们来通过构建一个简单的程序，以便更直观的了解观察者模式的作用。

该程序仅包含 一个按钮、一个复选框，以及点击次数记录，和 一个日志。

```html
<div id="app">
  <button id="btn" type="button">点击我！</button>
  <label for="checkbox">
    <input type="checkbox" id="checkbox" />
    <span>切换选择状态！</span>
  </label>
  <p>点击次数：<span id="count">0</span></p>
  <div id="logger">
    <h3>日志</h3>
  </div>
</div>
```

期望实现的两个功能：

1. 当用户点击按钮或者复选框时，均在日志中打印相应的信息。
2. 仅点用户点击按钮时，点击次数记录 **+1**。

我们需要将 按钮的点击事件 和 复选框的变化事件 变为可观测的对象，因此，我们需要通过事件监听的
方式，当用户进行交互时使用 `notify()` 通知观察者。

```ts
// 创建可观察对象
const observable = new Observable()

btnEl.addEventListener('click', () => {
  // 点击按钮发送通知
  observable.notify({ type: 'click', message: '点击按钮' })
})

checkboxEl.addEventListener('change', (ev) => {
  // 点击复选框发送通知
  observable.notify({ type: 'checkbox', message: `点击复选框: ${ev.target.checked}` })
})
```

日志接收通知，并打印相关信息：

```ts
const logger = new Logger()
observable.subscribe(({ type, message }) => {
  logger.log(`${type} ${message}`)
})
```

点击次数记录:

```ts
observable.subscribe(({ type }) => {
  if (type === 'click')
    countEl.textContent = Number(countEl.textContent) + 1
})
```

**完整示例：**

:::: demo normal

::: code-tabs

@tab HTML

```html
<div id="app">
  <button id="btn" type="button">点击我！</button>
  <label for="checkbox">
    <input type="checkbox" id="checkbox" />
    <span>切换选择状态！</span>
  </label>
  <p>点击次数：<span id="count">0</span></p>
  <div id="logger">
    <h3>日志</h3>
  </div>
</div>
```

@tab Typescript

```ts
const btnEl = document.getElementById('btn')
const checkboxEl = document.getElementById('checkbox')
const loggerEl = document.getElementById('logger')
const countEl = document.getElementById('count')

class Logger {
  render(type, message) {
    const line = document.createElement('p')
    line.textContent = `${getCurrentDate()} [${type}] ${message}`
    loggerEl.appendChild(line)
  }

  log(message) {
    this.render('log', message)
  }
}

class Observable {
  constructor() {
    this.observers = []
  }

  subscribe(observer) {
    if (!this.observers.includes(observer))
      this.observers.push(observer)
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter(item => item !== observer)
  }

  notify(context) {
    this.observers.forEach(observer => observer(context))
  }
}

const logger = new Logger()
// 创建可观察对象
const observable = new Observable()

// 日志 观察者
observable.subscribe(({ type, message }) => {
  logger.log(`${type} ${message}`)
})

// 点击次数 观察者
observable.subscribe(({ type }) => {
  if (type === 'click')
    countEl.textContent = Number(countEl.textContent) + 1
})

btnEl.addEventListener('click', () => {
  // 点击按钮发送通知
  observable.notify({ type: 'click', message: '点击按钮' })
})

checkboxEl.addEventListener('change', (ev) => {
  // 点击复选框发送通知
  observable.notify({ type: 'checkbox', message: `点击复选框: ${ev.target.checked}` })
})

function getCurrentDate() {
  return new Intl.DateTimeFormat(
    'zh-CN',
    { hour: 'numeric', minute: 'numeric', second: 'numeric', fractionalSecondDigits: 3 },
  ).format(new Date())
}
```

::::

## 优点

使用观察者模式是实现关注点分离和单一职责原则的绝佳方式。
观察者对象与可观察对象之间不存在紧耦合，可以随时进行（解）耦。
可观察对象负责监控事件，而观察者只需处理接收到的数据。

## 缺点

* 观察者并不在乎订阅者的顺序，这可能很难保证应用程序的特定部分是按照我们期望的方式运行。
* 订阅者之间无视彼此的存在，我们很难追踪他们的依赖关系。

## 相关模式

* **发布/订阅模式**

  通常在 JavaScript 里，观察者模式通常会使用 ==Publish/Subscribe== 模式这一变体实现。

* **中介者模式**

  \==中介者模式== 本质上是观察者模式的变体，但中介者模式通过限制对象严格通过中介者进行通信来实现这一目的。

---

---
url: /czxBlog/design-pattern/prototype/index.md
---
# 原型模式
## 什么是原型模式？

\==Prototype(原型)模式== 是一种 创建型设计模式。

其核心思想是通过 **复制现有对象**（原型对象）来创建新对象，而不是通过类实例化。
在 JavaScript 中，由于语言本身的 **基于原型的继承机制**，原型模式天然地与对象的行为和继承紧密结合。

:::tip
原型模式在 JavaScript 中既是设计模式，也是语言核心机制。
它适合高频创建对象和动态扩展的场景，但需警惕共享状态的副作用。
合理利用原型模式，可以显著提升代码复用性和性能，但需结合项目需求权衡是否引入复杂性。
:::

## 实现原型模式

* **原型链继承**：每个 JavaScript 对象都有一个 `[[Prototype]]`（可通过 `__proto__` 或 `Object.getPrototypeOf()` 访问），指向其原型对象。
* **共享属性和方法**：所有实例共享原型对象上的属性和方法，减少重复定义。
* **动态修改**：修改原型对象的属性和方法，会立即反映到所有实例上。

```ts
// 原型对象定义
const carPrototype = {
  wheels: 4,
  drive() {
    console.log('Driving...')
  },
}

// 通过 Object.create() 创建新对象（基于原型）
const myCar = Object.create(carPrototype)
myCar.color = 'red'

console.log(myCar.wheels) // 4（继承自原型）
myCar.drive() // "Driving..."
```

## 优点

* **高效内存利用**

  原型上的方法和属性被所有实例共享，避免重复创建相同功能的方法，节省内存。

* **动态性和灵活性**

  运行时可以动态修改原型，所有实例自动继承变更。

* **避免重复代码**

  通过复用原型，减少冗余代码（例如构造函数中重复绑定方法）。

* **天然支持 JavaScript 继承**

  与 JavaScript 的原型链机制无缝结合，是语言原生特性的直接应用。

## 缺点

* **共享状态的风险**

  如果原型属性是引用类型（如数组、对象），所有实例会共享同一份数据。

* **原型链复杂性**

  深层次的原型链可能导致属性查找性能下降（需逐级向上搜索）。

  多重继承或复杂原型链可能使代码难以维护。

* **覆盖问题**

  实例可以覆盖原型属性，可能导致意外行为：

  ```ts
  const c = Object.create(carPrototype)
  c.wheels = 3 // 覆盖原型属性
  console.log(c.wheels) // 3（实例属性优先于原型）
  ```

## 适用场景

* **需要创建大量相似对象**

  例如游戏中的 NPC 敌人、粒子系统等高频创建的场景，复用原型节省内存。

* **动态扩展对象功能**

  在运行时为所有实例添加/修改功能（如日志功能、监控逻辑）。

* **替代类继承**

  当类继承导致复杂层次结构时，原型模式更轻量灵活。

* **与 `Object.create()` 结合使用**

  明确指定原型对象，避免构造函数和 new 关键字的限制。

## 最佳实践

* **避免共享引用类型属性**：将引用类型属性定义在构造函数中，而非原型。
* **浅拷贝/深拷贝**：需要完全独立对象时，使用 `Object.assign()` 或深拷贝工具。
* **ES6 Class 语法糖**：底层仍基于原型，但提供更清晰的抽象。

---

---
url: /czxBlog/design-pattern/proxy/index.md
---
# 代理模式
## 什么是代理模式？

\==Proxy(代理)模式== 是一种结构型设计模式。

通过创建一个代理对象来控制对另一个对象的访问。
在 JavaScript 中，ES6 的 `Proxy` 对象是代理模式的典型实现，允许你拦截并自定义对象的基本操作（如属性读取、赋值、函数调用等）。

## 实现代理模式

JavaScript 通过 `Proxy` 构造函数实现代理模式，其核心是定义一个 handler 对象，在 handler 对象中，
我们可以根据交互类型定义特定行为。
尽管可以向 Proxy 处理程序添加许多方法，但最常见的两种方法是 `get` 和 `set`

```ts
const target = { name: 'Alice' }

const handler = {
  get(target, prop) {
    console.log(`读取属性 ${prop}`)
    return target[prop] || '属性不存在'
  },
  set(target, prop, value) {
    if (prop === 'age' && value < 0) {
      throw new Error('年龄不能为负数')
    }
    target[prop] = value
    return true // 表示设置成功
  }
}

const proxy = new Proxy(target, handler)

console.log(proxy.name) // 输出: 读取属性 name → Alice
proxy.age = 25 // 正常设置
proxy.age = -5 // 抛出错误: 年龄不能为负数
```

JavaScript提供了一个名为 `Reflect` 的内置对象，它让我们在使用代理时能更方便地操作目标对象。

此前，我们尝试通过在代理中直接使用方括号取值或赋值来修改和访问目标对象的属性。
现在，我们使用 `Reflect` 对象来实现。`Reflect` 对象上的方法与 `handler` 对象上的方法具有相同的名称。

```ts
const handler = {
  get(target, prop) {
    console.log(`读取属性 ${prop}`)
    return Reflect.get(target, prop) || '属性不存在'
  },
  set(target, prop, value) {
    if (prop === 'age' && value < 0) {
      throw new Error('年龄不能为负数')
    }
    Reflect.set(target, prop, value)
    return true // 表示设置成功
  }
}
```

## 优点

* **控制访问**：限制或增强对目标对象的操作（如权限验证、数据校验）。
* **职责分离**：代理对象与目标对象各司其职，符合单一职责原则。
* **延迟初始化（虚拟代理）**：仅在需要时创建开销大的对象。
* **缓存优化**：减少重复计算或网络请求。
* **透明性**：客户端无需感知代理存在，目标对象接口不变。

## 缺点

* **性能开销**：代理的拦截操作会增加调用栈深度，高频操作中可能影响性能。
* **复杂度**：复杂代理逻辑可能使代码难以维护。
* **调试困难**：错误堆栈可能指向代理而非原始对象。

---

---
url: /czxBlog/design-pattern/publish-subscribe/index.md
---
# 发布/订阅模式
\==发布/订阅模式== 是观察者模式的一种变体。

::: info ==发布/订阅模式== 在 JavaScript 中非常常见，比如：

* 浏览器的 [事件监听系统](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget)
* Node.js 中的 [EventEmitter 模块](https://nodejs.org/api/events.html#events_class_eventemitter)
* 自定义事件 [CustomEvent](https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent)
* [WebSocket 消息推送](hhttps://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API)

:::

## 什么是发布/订阅模式？

\==Publish/Subscribe (发布/订阅)模式==，是一种行为型设计模式，用于实现对象间的解耦和事件通知机制。

```mermaid
flowchart TD
  A[Publisher]
  B[Topic/Event Channel]
  C[Subscriber]
  A --> |"Publish topic (event)"| B
  C --> |Subscribe| B
  C --> |Fire Event | B
```

发布/订阅模式使用了一个 主题/事件通道，这个通道介于希望接收到通知（订阅者）的对象和激活时间的对象（发布者）之间。
改时间系统允许代码定义应用程序的特定事件，这些事件可以传递自定义参数，自定义参数包含订阅者所需的值。
其目的是避免订阅者和发布者之间产生依赖关系。

## 实现 发布/订阅模式

在 JavaScript 中，我们可以通过实现一个简单的事件系统，来实现发布/订阅模式。

```ts
class Event {
  constructor() {
    this.listeners = []
  }

  // 订阅
  on(listener) {
    this.listeners.push(listener)
  }

  // 取消订阅
  off(listener) {
    this.listeners = this.listeners.filter(l => l !== listener)
  }

  // 发布
  emit(data) {
    this.listeners.forEach(listener => listener(data))
  }
}
```

在这个简单的事件系统中，订阅者通过 `on()` 方法订阅它们感兴趣的事件，发布者通过 `emit()` 方法发布事件，
订阅者可以通过 `off()` 方法取消订阅。

```ts
const event = new Event()

event.on('click', () => console.log('clicked'))

event.emit('click')
```

## 优点

* **解耦性强**

  发布者和订阅者无直接依赖，发布者不需要知道谁订阅了事件，订阅者也不需要知道事件是谁触发的。

* **可扩展性高**

  动态增减订阅者：通过 `on()` 和 `off()` 方法灵活管理订阅关系。

* **支持广播通信**

  一对多消息传递：一个事件可被多个订阅者同时响应。

* **异步处理能力**

  非阻塞通信：事件发布后，订阅者可异步处理任务。

* **集中化管理**

  事件中心统一调度：所有事件通过中间层（如 EventEmitter）管理，便于监控和调试。

## 缺点

* **难以跟踪事件流**

  隐式调用链：订阅者和发布者没有显式关联，这可能导致调试困难。

* **性能开销**

  大量事件分发：高频事件（如鼠标移动）可能引发性能问题。

* **事件命名冲突**

  全局事件名重复：多人协作时，可能因事件名相同导致意外覆盖。

* **过度使用导致逻辑分散**

  逻辑碎片化：过度依赖事件通信会让业务逻辑分散到多个订阅者中，破坏代码内聚性。

## 适用场景

| **适用场景**                                 | **不适用场景**                              |
| -------------------------------------------- | ------------------------------------------- |
| 跨层级/模块通信（如微前端、跨组件通信）      | 简单父子组件通信（优先用 Props/Events）     |
| 需要广播或一对多通信（如实时通知、日志广播） | 高频、高性能敏感操作（如游戏循环）          |
| 动态插件系统或可扩展架构                     | 强依赖顺序的逻辑（需明确调用链）            |
| 异步任务协调（如文件上传完成后的多步骤处理） | 需要严格类型检查的场景（需结合 TypeScript） |

## 最佳实践

* **严格管理订阅生命周期**
* **使用命名空间或类型约束**：避免事件名冲突
* **控制事件粒度**：避免过度细化或粗粒度的事件设计
* **结合其他模式**：如与观察者模式、状态模式混合使用
* **性能监控**：对高频事件进行性能分析，必要时优化或替换方案

---

---
url: /czxBlog/design-pattern/singleton/index.md
---
# 单例模式
\==Singleton(单例模式)== 是前端领域中最被熟知的模式之一。

## 什么是单例模式？

\==单例模式== 限制了 **类** 的实例化次数只能一次。

从经典意义上来说，单例模式，在该实例不存在时，可以通过一个方法创建一个类来实现创建类的新示例；
如果实例已经存在，它会简单返回该对象的引用。

* **单例** 不同于静态类（或对象），因为可以推迟它的初始化。
* **单例** 可以实现为全局共享的实例，因此它特别适合管理应用中的全局状态。

## 实现单例模式

在 JavaScript 中，实现单例模式的方法有很多, 比如，
实现一个 `Counter` 单例，拥有如下方法：

* `getInstance()`：返回当前实例。
* `getCount()`：返回当前计数器的值。
* `increment()`：增加计数器的值。
* `decrement()`：减少计数器的值。

::: code-tabs#singleton

@tab namespace

```ts
const Counter = (function () {
  let instance // 保存实例

  function init() {
    // 私有变量
    let count = 0
    // 返回公共方法
    return {
      getCount() {
        return count
      },
      increment() {
        count++
      },
      decrement() {
        count--
      },
    }
  }

  return {
    getInstance() {
      // 仅在第一次调用时创建实例
      if (!instance) {
        instance = init()
      }
      return instance
    }
  }
})()

const counter = Counter.getInstance()
```

@tab class

```ts
class Counter {
  private static instance

  private count = 0

  static getInstance() {
    if (!Counter.instance) {
      Counter.instance = new Counter()
    }
    return Counter.instance
  }

  getCount() {
    return this.count
  }

  increment() {
    this.count++
  }

  decrement() {
    this.count--
  }
}

const counter = Counter.getInstance()
```

:::

在上述的实现中，我们通过调用 `Counter.getInstance()` 方法来获取 `Counter` 的实例，
而不是直接创建一个 `Counter` 的实例，这样确保了 `Counter` 只会被实例化一次。

同时，我们也看到， `Counter` 被延迟到了 `getInstance()` 方法被调用时才进行实例化。

**为什么这样做？**

一方面，通过延迟实例化，可以使得**直到我们需要使用实例前，不会产生额外的资源和内存开销**。

另一方面，我们可以有机会在 `getInstance()` 方法中，添加一些额外的逻辑。试想一个场景，我们需要
根据一些外部环境信息，来决定 如何实例化 `Counter`，以适配不同环境的需求。

::: code-tabs#singleton

@tab namespace

```ts
const Counter = (function () {
  let instance // 保存实例

  function baseInit() {
    // do something
    return {}
  }

  function fooInit() {
    return {
      ...baseInit(),
      // do something
    }
  }

  function barInit() {
    return {
      ...baseInit(),
      // do something
    }
  }

  return {
    getInstance() {
      if (!instance) {
        // some conditions
        if (isEnvFoo()) {
          instance = fooInit()
        }
        else {
          instance = barInit()
        }
      }
      return instance
    }
  }
})()

const counter = Counter.getInstance()
```

@tab class

```ts
class Counter {
  private static instance
  static getInstance() {
    if (!Counter.instance) {
      // some conditions
      if (isEnvFoo()) {
        Counter.instance = new FooCounter()
      }
      else {
        Counter.instance = new BarCounter()
      }
    }
    return Counter.instance
  }
  // do something
}

class FooCounter extends Counter {
  // do something
}

class BarCounter extends Counter {
  // do something
}

const counter = Counter.getInstance()
```

:::

在这里，`getInstance()` 变得有些像 **Factory(工厂)**，当访问它时，我们不需要更新代码中的每个访问节点。

## 权衡利弊

\==Singleton(单例)== 很有使用价值。但是，当我们发现在项目中需要它时，则表示我们可能需要重新评估我们的设计。
因为 **Singleton(单例)** 被认为是一个`anti-pattern` （反模式）。

**单例** 的存在往往表明系统中的模块要么是系统紧密耦合的，要么是其逻辑过于分散在代码库的多个部分。
由于一系列的问题：从隐藏的依赖到创建多个实例的难度、底层依赖的难度等等，**单例** 的测试会更加困难。

### 使用常规对象

事实上，在 `ESM` 的 模块化系统中，可以直接使用常规对象，然后通过 `export` 将它暴露出去。

```ts
let count = 0

const counter = {
  getCount() {
    return count
  },
  increment() {
    count++
  },
  decrement() {
    count--
  },
}

export { counter }
```

由于 对象是按引用传递的，因此从 `ESM` 的其他模块中导入的是 `counter` 对象的同一个引用，
任意地改变 `counter` 对象的值，都会对其他模块产生影响。

### 测试

测试依赖单例模式的代码可能会变得棘手。
由于我们无法每次都创建新实例，所有测试都依赖于对前一个测试全局实例的修改。
在这种情况下，测试顺序至关重要，一个小小的改动就可能导致整个测试套件失败。
测试完成后，我们需要重置整个实例以清除测试所做的修改。

### 全局访问

**Singleton(单例)** 通常意味着我们可以在整个应用中访问它，因此可能需要将它放到全局变量中。

但通常来说，全局变量通常被认为是一个糟糕的做法，因为它会导致全局命名空间的污染，可能会导致很多意外的行为。

::: info
在 `ES2015` 中，创建全局变量并不常见，新的 `let` 和 `const` 声明块级作用域，这些变量只会在块级作用域中可见，
从而避免意外的全局变量污染。而模块化开发，使得创建的变量在模块级作用域，通过 `export` 导入，其它模块通过 `import` 访问。
:::

然而，单例模式的常见用途是在整个应用程序中维护某种全局状态。让代码库的多个部分依赖同一个可变对象，可能会导致不可预期的行为。

通常，代码库中的某些部分会修改全局状态中的值，而其他部分则负责使用这些数据。此处的执行顺序至关重要：我们不希望在没有数据可供使用（尚未存在）时，意外地先消费数据！随着应用程序规模扩大，当数十个组件相互依赖时，理解使用全局状态时的数据流会变得极其复杂。

---

---
url: /czxBlog/design-pattern/strategy/index.md
---
# 策略模式
::: tip
策略模式在 JavaScript 中通过函数和对象的灵活性，简洁地实现了算法的动态替换。
它特别适用于需要消除条件分支、支持扩展的场景，但需权衡策略管理的复杂度。
合理使用该模式，可显著提升代码的可维护性和可读性。
:::

## 什么是策略模式？

\==Strategy(策略)模式== 是一种行为设计模式。

它允许定义一系列算法，并将每个算法封装成独立的对象，使得它们可以相互替换。
该模式的核心思想是将算法的使用与实现分离，让客户端动态选择算法，避免代码中冗长的条件判断，提高灵活性和可维护性。

## 实现策略模式

在 JavaScript 中，策略模式通常通过对象或函数实现。以下是两种典型实现方式：

### 对象字面量封装策略

将不同策略封装为对象的方法，通过键名动态调用。

```ts
const strategies = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  multiply: (a, b) => a * b,
}

function calculate(type, a, b) {
  return strategies[type](a, b)
}

console.log(calculate('add', 5, 3)) // 8
```

### 类结合策略对象

通过上下文类管理策略，支持动态切换策略。

```ts
class PaymentContext {
  constructor(strategy) {
    this.strategy = strategy
  }

  executePayment(amount) {
    return this.strategy(amount)
  }
}

// 定义策略函数
const creditCardStrategy = amount => `支付 ${amount} 元（信用卡）`
const wechatPayStrategy = amount => `支付 ${amount} 元（微信支付）`

// 使用示例
const context = new PaymentContext(creditCardStrategy)
console.log(context.executePayment(100)) // 支付 100 元（信用卡）

context.strategy = wechatPayStrategy
console.log(context.executePayment(200)) // 支付 200 元（微信支付）
```

## 优点

* **避免条件分支**：消除大量 `if-else` 或 `switch-case` 语句。
* **开闭原则**：新增策略无需修改现有代码，只需扩展新策略。
* **高内聚低耦合**：每个策略独立封装，职责明确，易于复用和测试。
* **动态切换**：运行时灵活替换算法逻辑。

## 缺点

* **策略数量爆炸**：策略过多会增加对象或类的数量。
* **客户端需知策略细节**：使用者需要理解不同策略的差异。
* **性能开销**：简单场景可能因对象化策略引入额外开销。

## 适用场景

* **算法需动态切换**：如支付方式、数据验证规则、排序算法等。
* **替代复杂条件判断**：多个分支逻辑相似但实现不同。
* **隐藏算法细节**：隔离复杂逻辑，对外提供统一接口。
* **组合行为**：多个策略可组合使用（如复合表单验证）。

---

---
url: /czxBlog/design-pattern/visitor/index.md
---
# 访问者模式
## 什么是访问者模式？

\==Visitor（访问者）模式== 是一种行为型设计模式。

它允许在不修改现有对象结构的前提下，为对象结构中的元素添加新的操作。

核心思想是将数据操作与数据结构分离，通过“访问者”对象实现对不同元素的操作扩展。

访问者模式主要由以下部分组成：

### Visitor（访问者）

声明访问具体元素的方法（visitElementA, visitElementB）。

### ConcreteVisitor（具体访问者）

实现访问者接口，定义对元素的具体操作逻辑。

### Element（元素）

定义 accept(visitor) 方法，接收访问者对象。

### ConcreteElement（具体元素）

实现 accept() 方法，调用访问者的对应方法。

### ObjectStructure（对象结构）

维护元素集合，提供遍历接口供访问者操作。

## 实现访问者模式

```js
// 1. 定义元素接口
class Shape {
  accept(visitor) {
    throw new Error('Method \'accept()\' must be implemented.')
  }
}

// 2. 具体元素：圆形
class Circle extends Shape {
  constructor(radius) {
    super()
    this.radius = radius
  }

  accept(visitor) {
    visitor.visitCircle(this) // 将自身传递给访问者
  }
}

// 3. 具体元素：矩形
class Rectangle extends Shape {
  constructor(width, height) {
    super()
    this.width = width
    this.height = height
  }

  accept(visitor) {
    visitor.visitRectangle(this)
  }
}

// 4. 访问者接口
class Visitor {
  visitCircle(circle) {}
  visitRectangle(rectangle) {}
}

// 5. 具体访问者：面积计算器
class AreaCalculator extends Visitor {
  visitCircle(circle) {
    const area = Math.PI * circle.radius ** 2
    console.log(`Circle area: ${area.toFixed(2)}`)
  }

  visitRectangle(rectangle) {
    const area = rectangle.width * rectangle.height
    console.log(`Rectangle area: ${area}`)
  }
}

// 6. 具体访问者：周长计算器
class PerimeterCalculator extends Visitor {
  visitCircle(circle) {
    const perimeter = 2 * Math.PI * circle.radius
    console.log(`Circle perimeter: ${perimeter.toFixed(2)}`)
  }

  visitRectangle(rectangle) {
    const perimeter = 2 * (rectangle.width + rectangle.height)
    console.log(`Rectangle perimeter: ${perimeter}`)
  }
}

// 7. 对象结构（管理元素集合）
class Drawing {
  constructor() {
    this.shapes = []
  }

  add(shape) {
    this.shapes.push(shape)
  }

  accept(visitor) {
    this.shapes.forEach(shape => shape.accept(visitor))
  }
}

// 客户端代码
const drawing = new Drawing()
drawing.add(new Circle(5))
drawing.add(new Rectangle(4, 6))

const areaCalculator = new AreaCalculator()
const perimeterCalculator = new PerimeterCalculator()

console.log('--- Area Calculation ---')
drawing.accept(areaCalculator)

console.log('\n--- Perimeter Calculation ---')
drawing.accept(perimeterCalculator)
```

```console
--- Area Calculation ---
Circle area: 78.54
Rectangle area: 24

--- Perimeter Calculation ---
Circle perimeter: 31.42
Rectangle perimeter: 20
```

## 优点

* **开闭原则**：新增操作只需添加访问者，无需修改元素类。
* **单一职责**：将相关操作集中到访问者中，分离数据结构与算法。
* **扩展性好**：可轻松添加新操作（如新增 VolumeCalculator）。
* **状态累积**：访问者可在遍历过程中收集数据（如计算总面积）。

## 缺点

* **破坏封装**：元素需暴露内部状态供访问者操作（如 circle.radius）。
* **增加新元素困难**：新增元素类型需修改所有访问者（违反开闭原则）。
* 不适合元素类频繁变化的场景。
* 可能引入循环依赖（元素与访问者相互依赖）。

## 适用场景

* 对象结构稳定，但需频繁添加新操作。
* 需要对复杂结构（如 AST、DOM 树）执行多种独立操作。
* 避免污染元素类代码（如分离业务逻辑与数据模型）。
* 跨多个类执行统一操作（如报表生成、导出功能）。

## 典型应用案例

* **抽象语法树（AST）处理**：编译器中的类型检查、代码优化。
* **文档处理**：导出 HTML/PDF、拼写检查。
* **UI 组件树**：渲染、布局计算。
* **游戏开发**：角色属性计算、碰撞检测。

---

---
url: /czxBlog/design-pattern/what-is-pattern/index.md
---
# 什么是模式？
## 什么是模式？

模式是一种解决方案，可用于解决软件设计中遇到的常见问题。

::: important 我们每天都在使用 ==模式=={.caution} ！
:::

## 为什么学习模式？

模式主要有三大优点：

* **模式是已验证的解决方案**

  它们为解决软件开发中遇到的问题提供可靠的方法。
  使用已验证的解决方案，这些解决方案体现了开发人员的经验及见解。

* **模式很容易被复用**

  模式通常是一种立即可用的解决方案，可以对其进行修改以满足个人需求。
  该特性是的这些模式的功能非常强大。

* **模式富有表达力**

  看到模式时，通常就表示有一个设置好的结构和表达解决方案的词汇，已帮助我们非常轻松的表达出所实现的解决方案。

::: tip 小提示

模式的作用仅仅是为我们提供一个解决问题的方案。
模式无法解决所有的问题，也无法取代优秀软件设计师的工作，但模式能够为这些工作提供支持。

:::

设计模式的其它优点：

* 复用模式有助于防止在应用程序开发过程中小问题引发大问题。
* 模式可以提供通用的解决方案，并且其记录方式不需要与某个特定问题挂钩。
* 某些模式确实能够通过避免代码复用来减少代码的总体资源占用量。
* 模式添加到开发人员的词汇中，会使沟通更快速。

## 编写设计模式

编写优秀的设计模式是一项具有挑战性的任务。
模式不仅需要为最终用户提供大量的参考资源，还需要能够证明自己为何是必要的。

* **模式的实用性有多少？**

  确保模式描述的事能够解决重复出现的问题的已经验证的解决方案。

* **牢记最佳实践**

  做出的设计决策应该基于通过对最佳实践的理解而获得的原则。

* **设计模式对于用户来说应该是透明的**

  设计模式对于任何类型的用户体验都应是完全透明的。
  它们主要是为使用它们的开发人员提供服务，而不应强制改变用户的行为。

* **要记住独创性在模式设计中不是重点**

  编写模式时，我们不需要是已有解决方案的最初发现者，也不必担心我们的设计有一小部分与其他模式有重叠，
  如果我们的方法很强大，有广泛的适用性，那么它就有可能被认定为是一个有效的模式。

* **模式需要一批有说服力的示例**

  好的模式描述需要伴随着一系列同样强有力的示例，以演示所编写模式的成功应用。

## 反模式

如果我们认为一种模式代表一种最佳实践，那么一种反模式就代表我们已经学到的教训。

反模式是：

* 描述一种针对某个特定问题的不良解决方案，该方案会导致糟糕的情况发生；
* 描述如何摆脱前述的糟糕情况以及如何创造好的解决方案。

::: tip 反模式是一种值得记录的不良设计。
:::

## 设计模式类别

### 创建型设计模式

创建型设计模式专注于处理对象创建机制，以适合给定情况的方式来创建对象。

创建对象的基本方法可能导致项目复杂性增加，而这些模式旨在通过控制创建过程来解决这种问题。

创建型设计模式包括：

* **Constructor** - 构造器
* **Factory** - 工厂
* **Abstract** - 抽象
* **Prototype** - 原型
* **Singleton** - 单例
* **Builder** - 生成器

### 结构型设计模式

结构型模式与对象组合有关，通常可以用于找出在不同对象之间建立关系的简单方法。

这种模式有助于确保在系统某一部分发生变化时，系统的整个结构不需要同时改变。
同时对于不适合因某个特定目的而改变的系统部分，这种模式也能够帮助它们完成重组。

结构型设计模式包括：

* **Decorator** - 装饰器
* **Facade** - 外观
* **Flyweight** - 享元
* **Adapter** - 适配器
* **Proxy** - 代理

### 行为型设计模式

行为模式专注于改善或简化系统中不同对象之间的通信。

行为模式包括：

* **Iterator** - 迭代器
* **Mediator** - 中介者
* **Observer** - 观察者
* **Visitor** - 访问者

---

---
url: /czxBlog/ebooks/index.md
---
# 书籍推荐
## HTML

* 推荐 **`《Head First HTML与CSS（第2版）》`** - 初学者入门

* 推荐 **`《HTML5+JavaScript动画基础》`** - 动画基础入门

* 过时 **`《HTML5权威指南》`** - 初学者入门

* 过时 **`《HTML5与CSS3权威指南》`** - 初学者入门

* 过时 **`《HTML5程序设计》`** - 初学者入门

* 过时 **`《HTML5揭秘》`** - 入门

## CSS

* 推荐 **`《深入解析 CSS》`** - CSS 入门进阶

* 推荐 **`《CSS 揭秘》`** - CSS 进阶

* 推荐 **`《CSS 世界》`** - 包含很多实用技巧和奇淫巧技，但缺少整体性，通读一遍后二次阅读可以挑认为有价值的部分看，对提升CSS水平有很好的帮助

* 过时 **`《精彩绝伦的CSS》`** - 初学者入门

## Javascript

* 必读 **`《JavaScript权威指南（第7版）》`** - 入门经典

* 必读 **`《JavaScript高级程序设计（第4版）》`** - 必读经典

* 推荐 **`《JavaScript语言精粹》`** - 入门进阶

* 推荐 **`《高性能JavaScript》`** - 入门进阶

* 推荐 **`《你不知道的JavaScript》`** - 入门进阶

* 推荐 **`《JavaScript DOM编程艺术 （第2版）》`** - 入门进阶

* 推荐 **`《javascript设计模式》`** - 进阶

* 推荐 **`《JavaScript设计模式与开发实践》`** - 进阶

* [Javascript Guidebook](https://tsejx.github.io/javascript-guidebook/) - Javascript 知识图谱

## Typescript

* [TypeScript 使用手册](https://github.com/zhongsp/TypeScript) - TypeScript 使用手册（中文版）翻译。
* [TypeScript Deep Dive](https://github.com/jkchao/typescript-book-chinese) - TypeScript Deep Dive 中文版

## 算法

* 推荐 **`《算法（第4版）》`**
* 推荐 **`《算法导论》`**
* [awesome-coding-js](https://github.com/ConardLi/awesome-coding-js) - 用JavaScript实现的算法和数据结构

## Go

* 推荐 [Go语言圣经（中文版）](https://golang-china.github.io/gopl-zh/) - 入门
* 推荐 [Go语言高级编程](https://chai2010.cn/advanced-go-programming-book/) - 进阶

## 计算机网络

* 推荐 **`《HTTP权威指南》`** - 工具书
* 推荐 **`《图解HTTP》`** - 入门

---

---
url: /czxBlog/fe-oss/index.md
---
# 前端开源库指南

---

---
url: /czxBlog/fe-oss/ajv/index.md
---
# ajv
&#x20;

## 概述

[**Ajv** 官方文档](https://ajv.js.org){.read-more}

\==Ajv（Another JSON Schema Validator）== 是一个高性能的 Node.js JSON Schema 验证库，支持 **JSON Schema 草案（Draft-06/07/2019-09）** 和 **JSON Type Definition（JTD）**。
它以编译模式将 Schema 转换为高效的 JavaScript 验证函数，显著提升验证速度。

## 安装

::: npm-to

```sh
npm install ajv ajv-formats ajv-i18n  # 核心库及常用插件
```

:::

## 使用

### 基础验证

```ts
const Ajv = require('ajv')
const ajv = new Ajv({ allErrors: true }) // 返回所有错误
ajv.addFormat('email', /^[^\s@]+@[^\s@]+\.[^\s@]+$/) // 自定义格式

const schema = {
  type: 'object',
  properties: {
    name: { type: 'string', minLength: 3 },
    age: { type: 'integer', minimum: 18 },
    email: { type: 'string', format: 'email' }
  },
  required: ['name', 'age']
}
const data = { name: 'Alice', age: 20, email: 'alice@example.com' }
const valid = ajv.validate(schema, data)
if (!valid)
  console.log(ajv.errors)
```

### 扩展验证

```ts
import Ajv from 'ajv'
import addFormats from 'ajv-formats'

const ajv = new Ajv()
// 添加内置格式验证
addFormats(ajv)

// 自定义格式验证
ajv.addFormat('identifier', /^a-z\$_[a-zA-Z$_0-9]*$/)
```

### 预编译

```ts
import fs from 'node:fs'
import path from 'node:path'
import Ajv from 'ajv'
import standaloneCode from 'ajv/dist/standalone'

const schemaFoo = {
  $id: '#/definitions/Foo',
  $schema: 'http://json-schema.org/draft-07/schema#',
  type: 'object',
  properties: {
    foo: { $ref: '#/definitions/Bar' }
  }
}
const schemaBar = {
  $id: '#/definitions/Bar',
  $schema: 'http://json-schema.org/draft-07/schema#',
  type: 'object',
  properties: {
    bar: { type: 'string' },
  },
  required: ['bar']
}

// For ESM, the export name needs to be a valid export name, it can not be `export const #/definitions/Foo = ...;` so we
// need to provide a mapping between a valid name and the $id field. Below will generate
// `export const Foo = ...;export const Bar = ...;`
// This mapping would not have been needed if the `$ids` was just `Bar` and `Foo` instead of `#/definitions/Foo`
// and `#/definitions/Bar` respectfully
const ajv = new Ajv({ schemas: [schemaFoo, schemaBar], code: { source: true, esm: true } })
let moduleCode = standaloneCode(ajv, {
  Foo: '#/definitions/Foo',
  Bar: '#/definitions/Bar'
})

// Now you can write the module code to file
fs.writeFileSync(path.join(__dirname, './validate-esm.mjs'), moduleCode)
```

```ts
import { Bar, Foo } from './validate-esm.mjs'

const fooPass = {
  foo: {
    bar: 'something'
  }
}

const fooFail = {
  foo: {
    // bar: "something" // bar: "something" <= empty properties
  }
}

let validateFoo = Foo
if (!validateFoo(fooPass))
  console.log('ERRORS 1:', validateFoo.errors) // Never reaches here because valid

if (!validateFoo(fooFail))
  console.log('ERRORS 2:', validateFoo.errors) // Errors array gets logged
```

## 使用场景

* API 请求验证

  在 Koa/Express 中间件中校验请求体：

  ```ts
  app.post('/user', (ctx) => {
    if (!validate(ctx.request.body))
      ctx.throw(400, { errors: validate.errors })
  })
  ```

* 配置文件校验

  确保 JSON/YAML 配置文件符合预期结构。

* 表单数据处理

  结合前端框架验证表单字段（需配合浏览器打包）。

---

---
url: /czxBlog/fe-oss/ansis/index.md
---
# ansis
&#x20; &#x20;

## 概述

适用于终端、CI 环境及基于 Chromium 浏览器的ANSI色彩库。

Ansis 注重小巧体积与高速性能，同时提供丰富功能并妥善处理各类边界情况。

## 推荐

相对于 [picocolors](./picocolors.md)，ansis 的功能更加全面，而且支持 链式调用，这在一些日志格式化输出时非常有用。

## 安装

::: npm-to tabs="npm,pnpm,yarn,deno,bun"

```sh
npm install ansis
```

:::

## 使用

```ts
import ansis, { bold, fg, hex, red, rgb } from 'ansis'

console.log(ansis.bold('file.txt'))
console.log(red`Error: ${bold.cyan(file)} not found!`)
console.log(bold.bgRed`ERROR`) // 链式调用，组合文本格式
console.log(fg(208)`Orange`)
console.log(rgb(224, 17, 95)`Ruby`)
console.log(hex('#FF75D1').bold.underline('Pink'))

console.log(ansis.strip(red('Text'))) // 输出纯文本，不包含ANSI代码
```

![ansis](https://github.com/webdiscus/ansis/raw/master/docs/img/ansis-demo.png)

---

---
url: /czxBlog/fe-oss/axios/index.md
---
# axios
&#x20;

## 概述

\==Axios== 是一个基于 Promise 的异步 HTTP 客户端库，专为浏览器和 Node.js 设计。

::: tip Axios 以简洁的 API 设计、健壮的错误处理和多环境支持，成为现代 Web 开发中异步通信的标杆。
:::

### 特性

* 从浏览器创建 XMLHttpRequests
* 从 node.js 创建 http 请求
* 支持 Promise API
* 拦截请求和响应
* 转换请求和响应数据
* 取消请求
* 超时处理
* 查询参数序列化支持嵌套项处理
* 自动将请求体序列化为：
  * JSON (`application/json`)
  * Multipart / FormData (`multipart/form-data`)
  * URL encoded form (`application/x-www-form-urlencoded`)
* 将 HTML Form 转换成 JSON 进行请求
* 自动转换 JSON 数据
* 获取浏览器和 node.js 的请求进度，并提供额外的信息（速度、剩余时间）
  为 node.js 设置带宽限制
* 兼容符合规范的 `FormData` 和 `Blob`（包括 node.js）
* 客户端支持防御 `XSRF`

## 安装

::: npm-to

```sh
npm install axios
```

:::

从 CDN 加载:

```html
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
```

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
```

## 使用

### 基础示例

GET 请求

```ts
axios.get('/user', {
  params: { id: 123 } // 参数自动转为 ?id=123
}).then(({ data }) => {
  console.log(data)
})
```

POST 请求

```ts
axios.post('/login', {
  username: 'admin',
  password: 'securePassword' // 自动序列化为 JSON
})
```

### 拦截器

```ts
// 添加请求拦截器
axios.interceptors.request.use((config) => {
  // 在发送请求之前做些什么
  return config
}, (error) => {
  // 对请求错误做些什么
  return Promise.reject(error)
})

// 添加响应拦截器
axios.interceptors.response.use((response) => {
  // 2xx 范围内的状态码都会触发该函数。
  // 对响应数据做点什么
  return response
}, (error) => {
  // 超出 2xx 范围的状态码都会触发该函数。
  // 对响应错误做点什么
  return Promise.reject(error)
})
```

### 取消请求

```ts
const controller = new AbortController()

axios.get('/foo/bar', {
  signal: controller.signal
}).then((response) => {
  // ...
})
// 取消请求
controller.abort()
```

## 使用场景

* 各种类型的前端应用均适用
* Node.js 服务端通信

---

---
url: /czxBlog/fe-oss/better-sqlite3/index.md
---
# better-sqlite3
## 概述

[**better-sqlite3** 官方文档](https://github.com/WiseLibs/better-sqlite3/blob/HEAD/docs/api.md){.read-more}

\==better-sqlite3== 是 Node.js 中一个高性能、同步操作的 SQLite3 数据库驱动库，
以其卓越的执行效率和简洁的 API 设计成为轻量级应用本地存储的首选

针对 Node.js 中原生 `sqlite3` 库的异步回调复杂性及性能瓶颈，`better-sqlite3` 通过 `C++` 扩展直接调用 `SQLite3 API`，规避了 JavaScript 异步模型带来的上下文切换开销，实现了同步API下的更高并发性能。

### 优势

* **性能**：基准测试显示，其查询速度可达原生 `sqlite3` 的 **11–24 倍**（如单行查询快 11.7 倍，事务写入快 15.6 倍）
* **同步**：同步 API 避免回调地狱，更适合 Koa 等中间件模型，提升代码可读性

## 安装

::: npm-to

```sh
npm install better-sqlite3
```

:::

## 使用

```ts
import db from 'better-sqlite3'

// 建表
db.exec(`CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)`)
// 插入数据
const insert = db.prepare('INSERT INTO users (name) VALUES (?)')
insert.run('Bob')
// 查询
const row = db.prepare('SELECT * FROM users WHERE id = ?').get(1)
console.log(row.name) // 输出: Bob
```

### 预编译语句

```ts
const stmt = db.prepare('INSERT INTO users (name, email) VALUES (?, ?)')
stmt.run('Alice', 'alice@example.com') // 复用编译结果，防 SQL 注入
```

### 事务

```ts
const trans = db.transaction((users) => {
  for (const user of users) {
    db.prepare('INSERT ...').run(user)
  }
})
trans(users) // 自动提交或回滚
```

## 适用场景

* 轻量级应用（Electron 桌面应用、IoT 设备）
* 高读低写业务（如配置管理、日志存储）
* 需加密的本地数据（通过扩展 better-sqlite3-multiple-ciphers 支持 AES 等算法）

---

---
url: /czxBlog/fe-oss/cac/index.md
---
# cac
## 概述

[**cac** 官方文档](https://github.com/egoist/cac){.read-more}

\==cac== 是一个轻量级 Node.js 库，用于快速构建命令行工具（CLI）。
它提供 简化命令解析、参数处理和子命令管理，同时保持 API 简洁易用。
支持 TypeScript 原生类型推断。

![cac](https://user-images.githubusercontent.com/8784712/28623641-373450f4-7249-11e7-854d-1b076dab274d.png)

## 特性

1. **链式 API 设计**：支持流畅的链式调用（如 `.command().option().action()`），提升代码可读性。
2. **智能参数解析**：
   * 用 `<必选参数>` 和 `[可选参数]` 声明参数，支持展开参数（如 `[...files]`）。
   * 自动生成 `--help` 文档，包含命令描述和示例。
3. **异步操作支持**：`action()` 回调支持 `async/await`，方便处理异步任务。
4. **事件驱动**：继承 `EventEmitter`，可通过 `on()` 监听命令执行事件。
5. **嵌套命令与选项**：支持多级子命令和全局/局部选项，适合复杂 CLI 场景。

## 安装

::: npm-to

```bash
npm install cac
```

:::

## 使用示例

### 基础用法

```ts
import cac from 'cac'

const cli = cac('my-cli')

// 注册全局选项
cli.option('--config <path>', '配置文件路径', { default: './config.json' })

// 定义命令
cli
  .command('build <entry>', '构建项目')
  .option('--minify', '压缩输出文件') // 命令专属选项
  .action((entry, options) => {
    console.log(`构建入口：${entry}`)
    if (options.minify)
      console.log('启用压缩')
  })

// 默认命令（无命令名时触发）
cli.command('').action(() => cli.outputHelp())

cli.parse()
```

### 子命令与异步操作

```ts
cli
  .command('deploy <env>', '部署到环境')
  .option('--force', '强制覆盖')
  .action(async (env, options) => {
    console.log(`部署到 ${env}`)
    if (options.force) {
      await simulateDeployment() // 模拟异步部署
      console.log('部署完成！')
    }
  })

async function simulateDeployment() {
  return new Promise(resolve => setTimeout(resolve, 1000))
}
```

### 错误处理与帮助文档

```ts
cli
  .command('rm <dir>', '删除目录')
  .example('rm dist --recursive') // 自定义示例
  .action((dir, options) => {
    if (!options.recursive)
      throw new Error('需使用 --recursive 标志')
    console.log(`删除目录：${dir}`)
  })

// 捕获未知命令
cli.on('command:not-found', (name) => {
  console.error(`未知命令：${name}`)
  cli.outputHelp()
})
```

## 使用场景

* **脚手架工具**：结合 `inquirer.js` 实现交互式问答（如项目初始化）：

  ```ts
  import inquirer from 'inquirer'
  cli.command('init').action(async () => {
    const answers = await inquirer.prompt([{ type: 'input', name: 'project' }])
    console.log(`创建项目：${answers.project}`)
  })
  ```

* **构建脚本**：定义 `build`、`watch` 等命令，集成 Rollup/Vite 等工具。

* **自动化工具**：如批量文件处理（`lint [...files]`）或部署流程（`deploy production`）。

---

---
url: /czxBlog/fe-oss/chalk/index.md
---
# chalk
::: center
![chalk](https://github.com/chalk/chalk/raw/main/media/logo.svg)
:::

&#x20;

## 概述

终端字符串样式设置正确。

**Chalk** 的体积更大，但这有其原因。

它提供了更友好的 API、完善的类型文档、支持数百万种颜色，并涵盖了小型替代方案无法处理的边界情况。
**Chalk** 成熟可靠，是为持久运行而构建的。

`Chalk` 被超过 **12 万个** 项目依赖，在你不知道如何选择时，使用它是不会错的。

## 安装

::: npm-to

```sh
npm install chalk
```

:::

## 使用

```ts
import chalk from 'chalk'

const log = console.log

// Combine styled and normal strings
log(`${chalk.blue('Hello')} World${chalk.red('!')}`)

// Compose multiple styles using the chainable API
log(chalk.blue.bgRed.bold('Hello world!'))

// Pass in multiple arguments
log(chalk.blue('Hello', 'World!', 'Foo', 'bar', 'biz', 'baz'))

// Nest styles
log(chalk.red('Hello', `${chalk.underline.bgBlue('world')}!`))

// Nest styles of the same type even (color, underline, background)
log(chalk.green(
  `I am a green line ${
    chalk.blue.underline.bold('with a blue substring')
  } that becomes green again!`
))

// ES2015 template literal
log(`
CPU: ${chalk.red('90%')}
RAM: ${chalk.green('40%')}
DISK: ${chalk.yellow('70%')}
`)

// Use RGB colors in terminal emulators that support it.
log(chalk.rgb(123, 45, 67).underline('Underlined reddish color'))
log(chalk.hex('#DEADED').bold('Bold gray!'))
```

![chalk](https://github.com/chalk/chalk/raw/main/media/screenshot.png)

## 文本颜色

* `black`
* `red`
* `green`
* `yellow`
* `blue`
* `magenta`
* `cyan`
* `white`
* `blackBright` (alias: `gray`, `grey`)
* `redBright`
* `greenBright`
* `yellowBright`
* `blueBright`
* `magentaBright`
* `cyanBright`
* `whiteBright`

## 背景颜色

* `bgBlack`
* `bgRed`
* `bgGreen`
* `bgYellow`
* `bgBlue`
* `bgMagenta`
* `bgCyan`
* `bgWhite`
* `bgBlackBright` (alias: `bgGray`, `bgGrey`)
* `bgRedBright`
* `bgGreenBright`
* `bgYellowBright`
* `bgBlueBright`
* `bgMagentaBright`
* `bgCyanBright`
* `bgWhiteBright`

## 文本修饰

* `reset` - 重置当前样式。
* `bold` - 将文本设置为粗体。
* `dim` - 降低文本不透明度（变暗）。
* `italic` - 将文本设置为斜体。*（支持不广泛）*
* `underline` - 在文本下方添加水平线（下划线）。*（支持不广泛）*
* `overline` - 在文本上方添加水平线（上划线）。*（支持不广泛）*
* `inverse` - 反转背景色与前景色。
* `hidden` - 打印文本但使其不可见（隐藏）。
* `strikethrough` - 在文本中央添加水平线（删除线）。*（支持不广泛）*
* `visible` - 仅当Chalk颜色级别大于零时显示文本。适用于纯装饰性内容。

## 256色与彩色支持

Chalk在兼容的终端应用中支持256色及[真彩色](https://github.com/termstandard/colors)（1600万色）。

色彩会从1600万种RGB值向下采样为终端模拟器支持的ANSI色彩格式（或通过指定Chalk选项如`{level: n}`实现）。例如，当Chalk配置为运行在级别1（基础色彩支持）时，会将RGB值#FF0000（红色）下采样为31（ANSI红色转义码）。

使用示例：

* `chalk.hex('#DEADED').underline('你好，世界！')`
* `chalk.rgb(15, 100, 204).inverse('你好！')`

背景色版本需添加`bg`前缀并首字母大写（例如前景色用`hex`，背景色则用`bgHex`）。

* `chalk.bgHex('#DEADED').underline('你好，世界！')`
* `chalk.bgRgb(15, 100, 204).inverse('你好！')`

可用色彩模型包括：

* [`rgb`](https://en.wikipedia.org/wiki/RGB_color_model) - 示例：`chalk.rgb(255, 136, 0).bold('橙色！')`
* [`hex`](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) - 示例：`chalk.hex('#FF8800').bold('橙色！')`
* [`ansi256`](https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit) - 示例：`chalk.bgAnsi256(194)('蜜露色，大致如此')`

---

---
url: /czxBlog/fe-oss/chokidar/index.md
---
# chokidar
::: note 注释

优秀的好用的 文件监听 相关开源项目, 就目前而言只有 `chokidar` 是我用过最好用的。

如果你有其它不错的文件监听开源项目推荐，欢迎评论留言。
:::

## 概述

[**chokidar** 官方文档](https://github.com/paulmillr/chokidar){.read-more}

跨平台的简洁高效文件监控库。

### 原因

选择 Chokidar 而非原生 `fs.watch/fs.watchFile` 的诸多优势：

* 事件触发机制更可靠
  * macOS系统能准确上报文件名
  * 杜绝重复事件通知
  * 将变更分类为新增/修改/删除，而非无意义的"重命名"提示
* 支持原子写入操作（通过atomic选项）
  * 某些文件编辑器会采用此方式
* 支持分块写入检测（通过awaitWriteFinish选项）
  * 大文件通常采用分块写入方式
* 支持文件/目录过滤
* 完整支持符号链接
* 始终提供递归监控功能（原生事件仅部分支持）
* 可自定义递归监控深度

Chokidar 依赖于 Node.js 核心的 `fs` 模块，但在使用 `fs.watch` 和 `fs.watchFile` 进行监听时，会对接收的事件进行标准化处理，
通常通过获取文件状态和目录内容来验证事件真实性。
默认采用基于 `fs.watch` 的实现方案，该方案避免了轮询机制，能有效降低 CPU 占用率。
请注意，chokidar 会递归地为指定路径范围内的所有内容初始化监听器，因此需谨慎设置监听范围，
避免因监控过多不必要内容而浪费系统资源。在某些情况下会改用 `fs.watchFile` 方案，该方案采用轮询机制，会消耗更多系统资源。

::: important `chokidar` 现在最新版本是 **v4** , 它与旧的版本，在使用上的差异比较大，本文所有的示例都是基于 **v4** 的版本。
:::

## 安装

::: npm-to

```sh
npm install chokidar
```

:::

## 使用

```ts
import { watch } from 'chokidar'
```

### 监听单个文件

```ts
const watcher = watch('./foo.txt')

// 文件的任何变更都会触发
watcher.on('all', (event, path) => {
  console.log(event, path)
})

// 关闭监听
watcher.close()
```

### 监听多个文件

```ts
const watcher = watch(['./foo.txt', './bar.txt'])

// 文件修改
watcher.on('change', (path) => {
  console.log(path)
})

// 向监听器添加新的监听文件
watcher.add('./baz.txt')
watcher.add(['./foz.txt', './bab.txt'])

// 从监听器中移除监听文件
watcher.unwatch('./foo.txt')
```

### 监听文件夹

```ts
// 监听 foo 目录下的所有文件，递归地监听子文件夹
const watcher = watch('/foo/')

// 新增文件
watcher.on('add', path => console.log(path))
// 删除文件
watcher.on('unlink', path => console.log(path))
// 文件修改
watcher.on('change', path => console.log(path))

// 监听多个文件夹
watch(['/foo', '/bar'])
```

需要注意的是，监听文件夹会递归的监听子文件夹，如果文件夹下的文件很多，子目录深度过深可能会导致性能问题。
因此，通常需要配合 `ignored` 参数来限制监听范围，避免递归监听不必要的文件夹。

`ignored` : `string | RegExp | (string | RegExp)[] | (path, stats) => boolean`

**注意，不支持 glob 模式匹配！**

```ts
// 监听 foo 目录下的所有 `.js` 文件
const watcher = watch('/foo/', {
  // 忽略所有非 `.js` 文件
  ignored: (path, stats) => Boolean(stats?.isFile()) && !path.endsWith('.js'),
  ignoreInitial: true
})
```

### 当前工作目录

`cwd` : `string`

```ts
// 监听 foo 目录下的所有文件
const watcher = watch('.', {
  cwd: path.join(process.cwd(), 'foo'),
  ignoreInitial: true,
  // path 参数是绝对路径
  ignored: (path, stats) => Boolean(stats?.isFile())
})

watcher.on('add', (path) => {
  console.log(path) // path 是相对于 `cwd` 的路径
})
```

---

---
url: /czxBlog/fe-oss/clack-prompts/index.md
---
# @clack/prompts
## 概述

`@clack/prompts` 是一个轻量级、美观且用户友好的命令行交互工具库。
它提供了现代化的 CLI 提示组件，支持 TypeScript 类型安全，具有动画效果和直观的交互体验，适用于创建脚手架工具、配置向导等 CLI 应用。

## 特性

* **类型安全**：完整的 TypeScript 支持，提供精准的类型推断
* **丰富的组件**：支持文本输入、选择器、确认框、多选等交互元素
* **现代化 UI**：动态加载状态、彩色高亮、动画过渡效果
* **取消处理**：内置 `Esc`/`Ctrl+C` 取消操作的处理逻辑
* **输入验证**：内置验证器，支持自定义验证规则
* **主题定制**：允许自定义颜色和样式
* **无障碍支持**：优化键盘导航体验

![cac](https://github.com/bombshell-dev/clack/raw/main/.github/assets/clack-demo.gif)

## 安装

::: npm-to

```bash
npm install @clack/prompts
```

:::

## 使用

### 基础示例

```ts
import {
  cancel,
  confirm,
  isCancel,
  select,
  text
} from '@clack/prompts'

// 处理取消操作的通用函数
function handleCancel(value: unknown) {
  if (isCancel(value)) {
    cancel('Operation cancelled.')
    process.exit(0)
  }
}

(async () => {
  // 文本输入
  const name = await text({
    message: 'What is your name?',
    placeholder: 'Anonymous',
    validate: (value) => {
      if (value.trim().length === 0)
        return 'Name is required!'
    }
  })
  handleCancel(name)

  // 选择器
  const framework = await select({
    message: 'Choose a framework',
    options: [
      { value: 'react', label: 'React' },
      { value: 'vue', label: 'Vue.js', hint: 'recommended' },
      { value: 'svelte', label: 'Svelte' },
    ]
  })
  handleCancel(framework)

  // 确认框
  const installDeps = await confirm({
    message: 'Install dependencies?'
  })
  handleCancel(installDeps)

  console.log({
    name,
    framework,
    installDeps
  })
})()
```

### 多选组件

```ts
import { multiselect } from '@clack/prompts'

const tools = await multiselect({
  message: 'Select tools:',
  options: [
    { value: 'eslint', label: 'ESLint' },
    { value: 'prettier', label: 'Prettier', selected: true },
    { value: 'typescript', label: 'TypeScript' },
  ],
  required: true
})
handleCancel(tools)
```

### 密码输入

```ts
import { password } from '@clack/prompts'

const secret = await password({
  message: 'Enter API key:',
  mask: '*'
})
handleCancel(secret)
```

### 自定义主题

```ts
import { setTheme, text } from '@clack/prompts'

setTheme({
  color: {
    primary: '#8B5CF6', // 紫色
    error: '#EF4444' // 红色
  },
  symbols: {
    pointer: '👉'
  }
})

const themeDemo = await text({
  message: 'Custom themed input'
})
```

## 使用场景

* **脚手架工具**

  创建项目初始化工具（如 `create-react-app`），交互式配置项目选项

* **CLI 配置向导**

  引导用户完成复杂工具的配置过程（如数据库连接设置）

* **自动化脚本**

  在部署脚本中确认关键操作（如生产环境部署确认）

---

---
url: /czxBlog/fe-oss/commander/index.md
---
# commander
## 概述

[**commander** 官方文档](https://github.com/tj/commander.js){.read-more}

`commander` 是一个轻量级、功能强大的 Node.js 命令行接口（CLI）开发工具库。

它简化了命令行参数解析、命令定义和帮助文档生成的过程，被广泛应用于构建专业的命令行工具（如 Vue CLI、React Native CLI 等）。

## 特性

* **声明式命令定义**：通过链式 API 直观定义命令、子命令和选项
* **自动生成帮助文档**：基于定义的命令结构自动生成 `--help` 说明
* **灵活的选项解析**：支持短选项（`-v`）、长选项（`--verbose`）、必填/可选参数和默认值
* **智能参数验证**：内置类型检查（字符串、数字、布尔值等）和自定义验证逻辑
* **命令分层结构**：支持多级子命令（如 `git remote add`）
* **交互式提示**：可与 `inquirer.js` 等库集成实现用户交互
* **自动化错误处理**：自动捕获并格式化参数错误
* **插件生态系统**：支持通过插件扩展功能（如 `commander-inquirer`）

## 安装

::: npm-to

```sh
npm install commander
```

:::

## 使用

### 基础示例

```ts
import { Command } from 'commander'
const program = new Command()

program
  .name('file-util')
  .description('文件操作工具')
  .version('1.0.0')

program.command('split')
  .description('拆分文件')
  .argument('<file>', '要拆分的文件')
  .option('-s, --size <bytes>', '分块大小', '1024')
  .action((file, options) => {
    console.log(`拆分文件: ${file}, 分块大小: ${options.size}字节`)
  })

program.parse(process.argv)
```

### 选项配置

```ts
program
  .option('-d, --debug', '启用调试模式', false)
  .option('-c, --count <number>', '重复次数', Number.parseInt, 1)
  .option('-l, --list <items>', '项目列表', val => val.split(','))
  .option('--no-color', '禁用颜色输出')
```

### 高级功能

**自定义验证**：

```ts
program
  .argument('<port>', '端口号', (val) => {
    const port = Number.parseInt(val)
    if (Number.isNaN(port))
      throw new Error('无效端口')
    return port
  })
```

**异步操作**：

```ts
program
  .command('download')
  .action(async () => {
    await fetchData()
    console.log('下载完成!')
  })
```

## 使用场景

* **开发脚手架工具**

  快速创建项目模板（如 `create-react-app` 风格工具）

  ```bash
  my-cli create <project-name> --template vue
  ```

* **构建运维脚本**

  封装服务器部署、日志分析等操作

  ```sh
  deploy-tool --env production --rollback-on-error
  ```

* **创建交互式 CLI 应用**

  结合 `inquirer` 实现问卷式配置生成

  ```bash
  config-generator init
  ```

---

---
url: /czxBlog/fe-oss/consola/index.md
---
# consola
&#x20;

## 概述

::: center
优雅的控制台包装器

![consola](https://github.com/unjs/consola/assets/904724/0e511ee6-2543-43ab-9eda-152f07134d94)
:::

`Consola` 是一个由 `Nuxt.js` 团队开发的现代化、高性能的 Node.js 日志管理库，专为简化开发和生产环境中的日志记录而设计。
它结合了美观的输出格式、灵活的配置和轻量级架构，成为 Node.js 生态中流行的日志解决方案。

## 使用场景

* 开发环境下的日志输出
* 构建部署时的日志输出
* 在 CI/CD 环境下的日志输出
* 命令行工具的日志输出

如果你的应用服务需要日志输出库，推荐使用 [pino](./pino.md) 作为日志输出库，
因为它更适合高性能的日志记录，同时还支持多种输出渠道，如文件、控制台、远程日志服务等。

## 安装

:::npm-to

```sh
npm install consola
```

:::

## 使用

```ts
import consola from 'consola'

// 不同级别日志
consola.info('启动服务')
consola.success('操作完成！')
consola.error(new Error('文件未找到'))

// 带标签的日志
const dbLogger = consola.withTag('Database')
dbLogger.debug('连接池初始化')
```

---

---
url: /czxBlog/fe-oss/cosmiconfig/index.md
---
# cosmiconfig
## 概述

\==cosmiconfig== 是一个专为 Node.js 生态设计的智能化配置解析库，旨在解决 JavaScript 工具链中碎片化的配置文件管理问题。
它通过统一、灵活的加载机制，支持包括 JSON、YAML、JS 模块等在内的多种格式，显著简化了开发者对配置文件的查找、解析与集成流程。

::: tip `eslint` / `stylelint` / `prettier` / `webpack` 等知名开源项目，均使用 `cosmiconfig` 进行配置文件解析
:::

## 配置文件查找过程

默认情况下，cosmiconfig 会检查当前目录中是否存在以下配置：

1. `package.json` 文件中的特定属性
2. 无扩展名的 JSON/YAML 格式 "rc文件"
3. 扩展名为 `.json` / `.yaml` / `.yml` / `.js` / `.ts` / `.mjs` / `.cjs` 的 "rc文件"
4. 上述两种文件在 `.config` 子目录中的存在形式
5. `.config.js` / `.config.ts` / `.config.mjs` / `.config.cjs` 格式的配置文件

## 安装

::: npm-to

```sh
npm install cosmiconfig
```

:::

## 使用

### 基本用法

```ts
import cosmiconfig from 'cosmiconfig'

const explorer = cosmiconfig('myapp')

explorer.search().then((result) => {
  console.log(result.config) // 配置内容
})
```

在这个例子中，`cosmiconfig` 按以下顺序查找配置文件：

```txt
package.json 中的 `myapp` 字段
.myapprc
.myapprc.json
.myapprc.{yaml,yml}
.myapprc.{js,ts,mjs,cjs}
.config/.myapprc
.config/.myapprc.json
.config/.myapprc.{yaml,yml}
.config/.myapprc.{js,ts,mjs,cjs}
myapp.config.{js,ts,mjs,cjs}
```

### 自定义搜索路径

```ts
import cosmiconfig from 'cosmiconfig'

const explorer = cosmiconfig('myapp', {
  searchPlaces: ['.myapprc', 'config/myapp.json'], // 自定义搜索路径
})

explorer.search().then((result) => {
  console.log(result.config) // 配置内容
})
```

### 自定义加载器

```ts
const cosmiconfig = require('cosmiconfig')
const explorer = cosmiconfig('myapp', {
  searchPlaces: ['myapp.toml'], // 自定义搜索路径
  loaders: { '.toml': customTOMLParser } // 扩展自定义格式解析
})

// 异步搜索当前目录及祖先目录
explorer.search().then((result) => {
  if (result)
    console.log('配置内容:', result.config)
})
```

---

---
url: /czxBlog/fe-oss/dotenv/index.md
---
# dotenv
## 概述

\==dotenv== 是 Node.js 生态中广泛使用的环境变量管理工具，旨在通过 .env 文件安全、灵活地管理配置信息。

## 安装

::: npm-to

```sh
npm install dotenv
```

:::

## 使用

`dotenv` 读取项目根目录下的 `.env` 文件，并将其加载到 `process.env` 对象中。

```sh title=".env"
API_KEY=abcdefg
DB_HOST=localhost
```

在代码中调用：

```ts title="index.ts"
import dotenv from 'dotenv'

dotenv.config()
```

### 自定义路径

```ts title="index.ts"
import dotenv from 'dotenv'

dotenv.config({ path: '.env.production' })
```

### 加载多个文件

```ts title="index.ts"
import dotenv from 'dotenv'

// 加载 .env.local 和 .env
// 默认优先加载 `.env.local` 中的值，`.env` 中的同名变量不会生效
// 此时的优先级顺序是数组从左到右
dotenv.config({ path: ['.env.local', '.env'] })

// 设置 `override` 为 `true` 时，会覆盖已存在的环境变量
// 此时的优先级顺序是数组从右到左
dotenv.config({ path: ['.env.local', '.env'], override: true })
```

## 最佳实践

* 使用 `.env.local` 存储本地配置，并将其添加到 `.gitignore` 中
* 根据不同的环境加载不同的配置文件 `.env.development` / `.env.production` 等，根据情况决定是否添加至 `.gitignore`

```ts
import dotenv from 'dotenv'

dotenv.config({ path: ['.env.local', `.env.${process.env.NODE_ENV}`] })
```

---

---
url: /czxBlog/fe-oss/eruda/index.md
---
# eruda
## 概述

[**eruda** 官方文档](https://eruda.liriliri.io/zh/docs/){.read-more}

与 [vconsole](./vconsole.md) 类似，在页面中注入控制面板，适合在移动设备调试网页时使用。

![eruda](https://camo.githubusercontent.com/d0f6d8eb7aa3c04da21dde1b137049ad3439a7ca17bac6628aa4166a42551dba/68747470733a2f2f65727564612e6c6972696c6972692e696f2f73637265656e73686f742e6a7067)

## 场景

在移动端设备中调试网页是一件比较麻烦的事情，因为缺少了浏览器的调试面板，我们很难直观的看到代码执行发生了
什么错误。

eruda 旨在解决这个问题，它在页面中注入了一个面板，模拟了浏览器的调试面板，让你可以直观的看到网页的执行情况。
比如 元素、网络请求、日志输出等等。

## 安装

::: npm-to

```bash
npm install eruda
```

:::

## 使用

```html
<script src="node_modules/eruda/eruda.js"></script>
<script>eruda.init();</script>
```

或者使用动态引入：

```ts
if (import.meta.env.MODE === 'development') {
  import('eruda').then(eruda => eruda.default.init())
}
```

## 预览

::: center

<https://eruda.liriliri.io/>

![preview](https://eruda.liriliri.io/qrcode.png)
:::

## 对比

与 [vconsole](./vconsole.md) 相同，都是在页面中注入控制面板，支持在移动设备调试网页。

eruda 还可以通过插件添加更多的功能，比如添加 `vue` 调试面板，当有个性的需求时，eruda 是个更好的选择。

---

---
url: /czxBlog/fe-oss/fast-glob/index.md
---
# fast-glob
## 概述

[**fast-glob** 官方文档](https://github.com/mrmlnc/fast-glob){.read-more}

这是一个非常快速高效的Node.js glob 库。

## 安装

:::npm-to

```sh
npm install fast-glob
```

:::

## 使用

```ts
import { glob, globStream, globSync } from 'fast-glob'
```

```ts
// 异步模式
const entries = await glob(['.editorconfig', '**/index.js'], { dot: true })

// 同步模式
const entries = globSync(['.editorconfig', '**/index.js'], { dot: true })

// 流模式
const stream = globStream(['.editorconfig', '**/index.js'], { dot: true })

for await (const entry of stream) {
  // .editorconfig
  // services/index.js
}
```

---

---
url: /czxBlog/fe-oss/fdir/index.md
---
# fdir
## 概述

NodeJS 最快的目录遍历与通配符匹配工具

:::important 在需要高性能场景下读取大目录文件时，使用 `fdir` 是一个不错的选择。
最快速度：在NodeJS领域，尚无任何同类工具能在速度上与fdir匹敌。它能轻松在不到1秒内遍历包含100万个文件的目录。
:::

## 安装

:::npm-to

```sh
npm install fdir
```

:::

## 使用

[**fdir** 官方文档](https://github.com/thecodrr/fdir/blob/HEAD/documentation.md){.read-more}

```ts
import { fdir } from 'fdir'
```

```ts
import { fdir as Fdir } from 'fdir'

const crawler = new Fdir()
const files = crawler.crawl('/path/to/dir').sync()
```

---

---
url: /czxBlog/fe-oss/fs-glob/index.md
---
# fs.glob
&#x20;

## 概述

`NodeJS` 在 22.0.0 版本新增的试验性 API。

根据模式，查找匹配的文件和目录。

## 使用方法

### 回调模式

```ts
import { glob } from 'node:fs'

glob('**/*.js', (err, matches) => {
  if (err)
    throw err
  console.log(matches) // 文件或目录 路径列表
})
```

### 同步阻塞查找

```ts
import { globSync } from 'node:fs'

const matches = globSync('**/*.js')

console.log(matches) // 文件或目录 路径列表
```

### 异步查找

```ts
import { glob } from 'node:fs/promises'

for await (const entry of glob('**/*.js'))
  console.log(entry)
```

## API

### `fs.glob(pattern[, options], callback)`

* `pattern`: `string | string[]` 匹配模式
* `options`: `object` 选项
  * `cwd`: `string` 当前工作目录。默认值：process.cwd()
  * `exclude`: `Function | string[]` 用于过滤文件/目录或要排除的 glob 模式列表的函数。如果提供了函数，则返回 `true` 以排除该项目，返回 false 以包含它。默认值：undefined。
  * `withFileTypes`: `boolean` 如果 glob 应将路径返回为 `Dirents`，则为 `true`，否则为 `false`。默认值：false。
* `callback`: `(err, matches) => void` 回调函数

```ts
import { glob } from 'node:fs'

glob('**/*.js', (err, matches) => {
  if (err)
    throw err
  console.log(matches)
})
```

### `fs.globSync(pattern[, options])`

* `pattern`: `string | string[]` 匹配模式
* `options`: `object` 选项
  * `cwd`: `string` 当前工作目录。默认值：process.cwd()
  * `exclude`: `Function | string[]` 用于过滤文件/目录或要排除的 glob 模式列表的函数。如果提供了函数，则返回 `true` 以排除该项目，返回 false 以包含它。默认值：undefined。
  * `withFileTypes`: `boolean` 如果 glob 应将路径返回为 `Dirents`，则为 `true`，否则为 `false`。默认值：false。

```ts
import { globSync } from 'node:fs'

const matches = globSync('**/*.js')

console.log(matches)
```

### `fs.promises.glob(pattern[, options])`

* `pattern`: `string | string[]` 匹配模式
* `options`: `object` 选项
  * `cwd`: `string` 当前工作目录。默认值：process.cwd()
  * `exclude`: `Function | string[]` 用于过滤文件/目录或要排除的 glob 模式列表的函数。如果提供了函数，则返回 `true` 以排除该项目，返回 false 以包含它。默认值：undefined。
  * `withFileTypes`: `boolean` 如果 glob 应将路径返回为 `Dirents`，则为 `true`，否则为 `false`。默认值：false。

```ts
import { glob } from 'node:fs/promises'

for await (const entry of glob('**/*.js'))
  console.log(entry)
```

---

---
url: /czxBlog/fe-oss/globby/index.md
---
# globby
## 概述

[**globby** 官方文档](https://github.com/sindresorhus/globby){.read-more}

基于 [fast-glob](./fast-glob.md)，但添加了许多有用的功能。

## 特性

* Promise API
* 多种模式支持
* 否定模式：`['foo*', '!foobar']`
* 自动展开目录：`foo → foo/**/*`
* 兼容 `.gitignore` 及同类忽略配置文件
* 支持 `URL` 作为 `cwd`

## 安装

:::npm-to

```sh
npm install globby
```

:::

## 使用

```ts
import { globby, globbyStream, globbySync } from 'globby'
```

```ts
// 异步模式
const paths = await globby(['*', '!cake'])

console.log(paths)
// => ['unicorn', 'rainbow']
```

```ts
// 同步模式
const paths = globbySync(['*', '!cake'])

console.log(paths)
// => ['unicorn', 'rainbow']
```

```ts
// 流模式
import { globbyStream } from 'globby'

for await (const path of globbyStream('*.tmp')) {
  console.log(path)
}
```

---

---
url: /czxBlog/fe-oss/got/index.md
---
# got
## 概述

Got 是一个轻量级、功能丰富且基于 Promise 的 Node.js HTTP 客户端库，旨在简化 HTTP 请求的处理过程。

与 Node.js 原生 http 模块或其他流行库（如 axios）相比，Got 提供了更简洁的 API、自动重试机制、流式支持和高度的可定制性。

### 特性

* **自动重试**：在网络波动或服务不可用时自动重试请求，提升鲁棒性。
* **Promise 原生支持**：完美适配 async/await 语法，避免回调地狱。
* **流式处理**：通过 got.stream 支持大文件下载或实时数据流处理。
* **高度可定制**：可修改请求头、超时时间、查询参数等，并支持钩子（hooks）扩展。
* **内置 JSON 处理**：自动解析响应为 JSON 对象，简化数据消费流程。

## 安装

::: npm-to

```sh
npm install got
```

:::

## 使用

### 基础示例

GET 请求

```ts
import got from 'got'

// 获取 JSON 数据
const response = await got('https://jsonplaceholder.typicode.com/posts/1')
console.log(JSON.parse(response.body))
```

POST 请求

```ts
const response = await got.post('https://api.example.com/login', {
  json: { username: 'foo', password: 'bar' },
  responseType: 'json' // 自动解析响应为 JSON
})
console.log(response.body.token)
```

### 自定义请求配置

```ts
await got('https://api.example.com/data', {
  headers: { 'User-Agent': 'MyApp/1.0' },
  searchParams: { page: 2 }, // 添加查询参数 ?page=2
  timeout: { request: 5000 } // 5 秒超时
})
```

### 流式下载文件

```ts
import fs from 'node:fs'
import got from 'got'

const downloadStream = got.stream('https://example.com/large-file.zip')
const fileWriter = fs.createWriteStream('file.zip')
downloadStream.pipe(fileWriter)

fileWriter.on('finish', () => console.log('下载完成！'))
```

## 适用场景

* 高频 API 调用

  适合需频繁调用外部 API 的服务（如微服务架构）。自动重试和超时管理保障了请求的可靠性

* 数据爬取与流处理

  流式支持使其高效处理大规模数据下载（如爬虫场景），避免内存溢出

* 服务器端通信

  在 BFF（Backend for Frontend）层中，Got 可聚合多个下游服务的数据，并通过统一的错误处理简化逻辑

---

---
url: /czxBlog/fe-oss/inquirer/index.md
---
# @inquirer/prompts
## 概述

\==@inquirer/prompts== 是一个用于 Node.js 的交互式命令行界面（CLI）库，旨在简化用户输入收集过程。
它支持多种问题类型（如输入框、选择列表、确认框等），并通过 Promise 或回调返回结构化答案，极大提升了命令行工具的交互体验

## 特性

* 问题类型

  支持 input（文本输入）、confirm（是/否）、list（单选列表）、checkbox（多选）、password（密码隐藏输入）等 12 种交互类型

* 异步验证与过滤

  通过 `validate` 函数实时校验输入合法性，`filter` 函数格式化答案

* 条件式提问

  使用 `when` 属性根据前置答案动态跳过问题，实现逻辑分支

* 跨平台兼容

  支持 Windows（CMD/PowerShell）、macOS（Terminal/iTerm）和 Linux（GNOME/Konsole）等终端

## 安装

::: npm-to

```sh
npm install @inquirer/prompts
```

:::

## 示例

### 基础用法

```ts
import { input } from '@inquirer/prompts'

const answer = await input({ message: 'Enter your name' })
```

### 以对象形式获取

```ts
import { confirm, input } from '@inquirer/prompts'

const answers = {
  firstName: await input({ message: 'What\'s your first name?' }),
  allowEmail: await confirm({ message: 'Do you allow us to send you email?' }),
}

console.log(answers.firstName)
```

### 条件式提问

```ts
import { confirm, input } from '@inquirer/prompts'

const allowEmail = await confirm({ message: 'Do you allow us to send you email?' })

let email
if (allowEmail) {
  email = await input({ message: 'What is your email address' })
}
```

### 超时返回默认值

```ts
import { input } from '@inquirer/prompts'

const answer = await input(
  { message: 'Enter a value (timing out in 5 seconds)' },
  { signal: AbortSignal.timeout(5000) },
).catch((error) => {
  if (error.name === 'AbortPromptError') {
    return 'Default value'
  }

  throw error
})
```

## 使用场景

* 脚手架工具
* 命令行配置向导
* 自动化脚本

---

---
url: /czxBlog/fe-oss/intro/index.md
---
# 前端开源库指南
## 概述

本指南罗列一系列在前端开发过程中经常使用到的开源库，这些库应用在前端领域的方方面面。

当你需要开发某项功能，但是不知道该使用哪些开源库时，可以先看下这些开源库，有没有适合你的需求。

---

---
url: /czxBlog/fe-oss/joi/index.md
---
# joi
&#x20;

## 概述

[**Joi** 官方文档](https://joi.dev){.read-more}

\==Joi== 由 **Hapi.js** 团队开发，是一个强大的 JavaScript 数据验证库，专注于为 Node.js 和浏览器环境提供声明式的对象模式描述与验证能力。

## 特性

* 声明式 Schema 定义

  Joi 通过链式 API 定义数据模式（Schema），以简洁的语法描述数据结构与规则。例如：

  ```ts
  const schema = Joi.object({
    username: Joi.string().alphanum().min(3).max(30).required(),
    email: Joi.string().email().required(),
    password: Joi.string().regex(/^[a-zA-Z0-9]{3,30}$/),
    birthdate: Joi.date().min('1900-01-01').max('now'),
    address: Joi.object({
      street: Joi.string().required(),
      city: Joi.string().required()
    })
  })
  ```

  * **类型支持**：覆盖 `string`, `number`, `boolean`, `date`, `array`, `object`, `binary` 等基础与复合类型
  * **链式规则**：如 `.min()`, `.max()`, `.regex()`, `.email()`, `.required()` 等，可组合使用

* 嵌套结构与复杂验证

  * 支持多级对象嵌套（如 `address.city`）
  * 条件验证：通过 `Joi.when()` 实现动态规则（如当性别为男性时要求填写 `maleSpecificField`）

    ```ts
    const schema = Joi.object({
      sex: Joi.number().valid(0, 1),
      name2: Joi.when('sex', { is: 1, then: Joi.string().required() })
    })
    ```

* 字段依赖与互斥

  * `.with('fieldA', 'fieldB')`：若 `fieldA` 存在，则 `fieldB` 必填。
  * `.without('fieldA', 'fieldB')`：`fieldA` 和 `fieldB` 不能同时存在

* 数据清洗与转换

  * 自动格式化数据（如字符串转日期、数字转字符串）
  * 移除非法字段（`strip()`）或设置默认值（`.default('value')`）

* 错误处理

  * 返回详细错误信息（包括错误字段、类型及原因），支持自定义错误消息（`.error(new Error('自定义消息'))`）
  * 控制错误报告策略：`abortEarly: false` 可收集所有错误而非在首次失败时终止

## 安装

::: npm-to

```sh
npm install joi
```

:::

## 使用

```ts
import joi from 'joi'

// 定义 Schema
const schema = Joi.object({
  username: Joi.string().min(3).required(),
  age: Joi.number().integer().min(18).default(20),
  hobbies: Joi.array().items(Joi.string()).min(1)
})

// 验证数据
const data = { username: 'Tom', age: 25 }
const { error, value } = schema.validate(data, { abortEarly: false })

if (error) {
  console.error(error.details) // 输出所有错误详情
}
else {
  console.log(value) // 输出清洗后数据（包含默认值）
}
```

## 使用场景

* API 请求验证
* 配置文件校验
* 表单与用户输入
* 数据库模型验证

---

---
url: /czxBlog/fe-oss/keyv/index.md
---
# keyv
## 概述

\==keyv== 通过存储适配器为多种后端提供了一个统一的键值存储接口。
它支持基于TTL（生存时间）的过期机制，因此非常适合用作缓存或持久化的键值存储系统。

## 安装

::: npm-to

```sh
npm install keyv
```

:::

各种适配器支持：

::: npm-to

```sh
npm install @keyv/redis
npm install @keyv/valkey
npm install @keyv/mongo
npm install @keyv/sqlite
npm install @keyv/postgres
npm install @keyv/mysql
npm install @keyv/etcd
npm install @keyv/memcache
```

:::

## 使用

```ts
import Keyv from 'keyv'

const keyv = new Keyv()
```

```ts
// Redis
import KeyvRedis from '@keyv/redis'
import Keyv from 'keyv'

const keyvRedis = new KeyvRedis('redis://user:pass@localhost:6379')
const keyv = new Keyv({ store: keyvRedis })
```

```ts
// sqlite
import KeyvSqlite from '@keyv/sqlite'
import Keyv from 'keyv'

const keyvSqlite = new KeyvSqlite('sqlite://path/to/database.sqlite')
const keyv = new Keyv({ store: keyvSqlite, ttl: 5000 })
```

### 命名空间隔离

```ts
import KeyvRedis from '@keyv/redis'
import Keyv from 'keyv'

const users = new Keyv(new KeyvRedis('redis://user:pass@localhost:6379'), { namespace: 'users' })
const cache = new Keyv(new KeyvRedis('redis://user:pass@localhost:6379'), { namespace: 'cache' })
```

### Method

```ts
const Keyv = require('keyv')
const keyv = new Keyv() // 默认使用内存存储

// 写入数据（含 TTL）
await keyv.set('config', { theme: 'dark', lang: 'zh' }, 5000)

// 读取数据
const config = await keyv.get('config')
console.log(config) // { theme: 'dark', lang: 'zh' }

// 删除数据
await keyv.delete('config')

// 清空当前命名空间数据
await keyv.clear()
```

## 适用场景

* API 响应缓存

  缓存外部接口，减少重复请求，提升响应速度。

* 会话状态管理（Session）

  结合 Redis 适配器实现多服务实例共享会话数据6。

* 分布式任务队列

  存储任务状态，通过 Redis 保证多节点一致性。

* 配置参数存储

  使用 SQLite 适配器持久化应用配置，支持动态更新。

---

---
url: /czxBlog/fe-oss/level/index.md
---
# level
&#x20;

## 概述

[**level** 官方文档](https://github.com/Level/abstract-level){.read-more}

LevelDB 是由 Google 开发的高性能键值存储引擎，而 level 是其在 Node.js 环境中的开源实现，通过 JavaScript 封装提供轻量级 NoSQL 数据库解决方案。

## 安装

::: npm-to

```sh
npm install level
```

:::

## 使用

```ts
import { Level } from 'level'

// 创建数据库
const db = new Level('example', { valueEncoding: 'json' })

// 设置值
await db.put('a', 1)

// 批量操作
await db.batch([{ type: 'put', key: 'b', value: 2 }])

// 获取值
const value = await db.get('a')

// 遍历键大于'a'的条目
for await (const [key, value] of db.iterator({ gt: 'a' })) {
  console.log(value) // 2
}
```

## 适用场景

* **高频写入**：日志收集、实时监控数据（LSM-Tree 写优化）
* **嵌入式存储**：本地化数据缓存

---

---
url: /czxBlog/fe-oss/lowdb/index.md
---
# lowdb
&#x20;&#x20;

## 概述

lowdb 是一个轻量级的本地 JSON 数据库。

利用 JSON 文件作为持久化存储介质，通过 JavaScript 原生 API 操作数据，无需依赖外部数据库服务。

## 安装

::: npm-to

```sh
npm install lowdb
```

:::

## 使用

```ts
import { JSONFilePreset } from 'lowdb/node'

// 读取或创建 db.json
const defaultData = { posts: [] }
const db = await JSONFilePreset('db.json', defaultData)

// 更新 db.json
await db.update(({ posts }) => posts.push('hello world'))

// 也可以稍后显式调用 db.write()
// 将数据写入 db.json
db.data.posts.push('hello world')
await db.write()
```

### Lodash

通过 `Lodash` 实现链式调用

```ts
import lodash from 'lodash'
import { Low } from 'lowdb'
import { JSONFile } from 'lowdb/node'

interface Post {
  id: number
  title: string
}

interface Data {
  posts: Post[]
}

// Extend Low class with a new `chain` field
class LowWithLodash<T> extends Low<T> {
  chain: lodash.ExpChain<this['data']> = lodash.chain(this).get('data')
}

const defaultData: Data = {
  posts: [],
}
const adapter = new JSONFile<Data>('db.json', defaultData)

const db = new LowWithLodash(adapter)
await db.read()

// 使用 db.chain 而非 db.data 来访问 lodash API
const post = db.chain.get('posts').find({ id: 1 }).value() // 重要提示：必须调用value()以执行链式操作
```

## 适用场景

* **小型工具/CLI**：配置文件、临时数据存储
* **Electron 桌面应用**：本地数据持久化（如用户设置）

## 缺点

* **性能瓶颈**：数据量 >10MB 时，全量读写导致延迟显著上升。
* **并发能力弱**：无锁机制，不适用高并发场景。
* **功能简化**：缺乏事务、索引、关联查询等高级数据库特性。

---

---
url: /czxBlog/fe-oss/lru-cache/index.md
---
# lru-cache
## 概述

一个高性能、功能丰富的 **Least Recently Used (LRU) 缓存** 实现库，专为 Node.js 环境设计。

**LRU (最近最少使用)**：当缓存达到设定的容量上限时，它会自动淘汰那些最近最少被访问的项，为新数据腾出空间。
这是管理有限内存资源的有效策略。

## 特性

* **LRU 缓存**：

  * 存储键值对 (`key` -> `value`)。
  * 当添加新项导致缓存大小超过 `max` 或 `maxSize` 限制时，自动淘汰最近最少使用的项。
  * 高效的 `get` (获取)、`set` (设置/更新)、`delete` (删除)、`has` (检查存在) 操作。

* **容量限制**：

  * `max`: 设置缓存允许存储的最大 条目数量。最常用的限制方式。

  * `maxSize`: 设置缓存允许使用的 最大总大小（字节数或其他单位）。需要配合 `sizeCalculation` 函数使用。

  * `sizeCalculation`: 一个函数，用于计算每个缓存项的大小（除了其键所占的内存）。
    例如，可以用来计算存储对象或字符串的实际内存占用。这对于精确控制内存使用至关重要。

* **条目过期 (TTL - Time To Live)**：

  * `ttl`: 设置全局默认的条目存活时间（毫秒）。超过此时间未访问的条目会被视为过期。

  * `ttlAutopurge`: 是否在读取 (`get`) 时自动删除已过期的条目 (默认 `true`)。

  * `allowStale`: 允许在读取 (`get`) 时返回已过期但尚未被淘汰的条目 (默认 `false`)。

  * `updateAgeOnGet`: 在读取 (`get`) 时是否重置条目的“年龄”，将其视为新访问，从而延长它在缓存中的生存时间 (默认 `false`)。如果为 `true`，频繁访问的条目几乎不会过期。

  * `noDeleteOnStaleGet`: 当 `allowStale` 为 `true` 时，读取过期条目是否不触发异步后台删除 (默认 `false`，即会触发删除)。

  * `ttlResolution`: 过期检查的时间间隔精度（毫秒）。为了性能，内部不会实时检查每个条目，而是按此间隔批量检查 (默认 `0 ms`，表示尽可能精确，但实际受事件循环影响)。

  * **在 `set` 时指定 TTL**: 可以单独为每个 `set` 操作设置该条目的特定 TTL，覆盖全局 `ttl`。

* **获取与更新**：

  * `fetchMethod`: 当尝试 `get` 一个不存在（或允许过期且已过期）的键时，可以用这个函数去异步获取数据。
    它会防止对同一个键的重复并发请求（类似 Single Flight），只发出一个请求并将结果返回给所有等待者。
    极大简化了 **“缓存未命中则加载”** 的模式。`async (key, staleValue, { options, signal, context }) => {}`。
  * `noDeleteOnFetchRejection`: 如果 `fetchMethod` 拒绝 (`reject`)，是否不删除该键（默认 `false`，即会删除占位符）。
  * `allowStaleOnFetchRejection`: 如果 `fetchMethod` 拒绝 (`reject`) 且 `allowStale` 为 `true`，
    是否返回过期的旧值（如果有） (默认 `false`)。

## 安装

::: npm-to

```sh
npm install lru-cache
```

:::

## 使用

```ts
import { LRUCache } from 'lru-cache'

const cache = new LRUCache({
  max: 500, // 最大缓存条数

  // maxSize 和 sizeCalculation 配合使用
  maxSize: 5000, // 最大缓存大小
  sizeCalculation: (value, key) => value.length, // 计算每个缓存项的大小

  ttl: 1000 * 60 * 5, // 存活时间，单位毫秒

  allowStale: false, // 在从缓存中移除之前返回过期项？

  updateAgeOnGet: false,
  updateAgeOnHas: false,

  /// 用于cache.fetch()的异步方法，实现
  // 类似stale-while-revalidate（后台更新缓存）的行为模式
  fetchMethod: async (
    key,
    staleValue,
    { options, signal, context }
  ) => {},
})

// 设置值
cache.set('key', 'value')
// 获取值
cache.get('key') // "value"
// 检查是否存在
cache.has('key') // true
// 删除
cache.delete('key')

// 非字符串键名完全支持
// 但需注意必须是同一个对象，而非
// 仅结构等效的JSON对象
let someObject = { a: 1 }
cache.set(someObject, 'a value')

cache.clear() // 清空缓存
```

## 性能

* **高度优化**： 使用纯 JavaScript 实现，针对 V8 引擎做了优化。
* **零依赖**： 不依赖任何其他 npm 包，体积小，安全性高，安装快速。
* **O(1) 操作**： get, set, delete, has 等核心操作的时间复杂度都是常数级，非常高效。

## 适用场景

* **数据库查询缓存**： 缓存频繁查询的数据库结果。
* **API 响应缓存**： 缓存外部 API 调用的结果。
* **计算/渲染结果缓存**： 缓存耗时的计算结果、模板渲染结果。
* **会话存储 (Session Storage)**： 在内存中存储用户会话信息（注意持久化和分布式问题）。
* **速率限制**： 存储请求计数。
* 任何需要内存中快速键值存储且有容量限制和淘汰策略的地方。

---

---
url: /czxBlog/fe-oss/memfs/index.md
---
# memfs
&#x20;

## 概述

`memfs` 是一个在 Node.js 和浏览器环境中模拟内存文件系统的开源库，它完整实现了 Node.js 原生 fs 模块的 API，但所有操作均在内存中完成，无需物理磁盘交互。

## 特性

1. **完整文件系统模拟**
   * 支持基础操作：文件/目录的创建（`writeFileSync`）、读取（`readFileSync`）、删除（`unlink`）、重命名（`rename`）等。
   * 路径兼容性：无缝处理 Windows 和 Unix 风格的路径格式（如 `/data/file.txt` 或 `C:\data\file.txt`）。
   * 数据存储机制：使用 JavaScript 对象树结构管理文件数据，响应速度极快，但需注意内存占用量。

2. **Node.js API 兼容性**
   * 与 `fs` 模块接口一致，可直接替换现有代码中的文件操作模块，无需重写逻辑。
   * 同时提供同步（如 `writeFileSync`）和异步（如 `fs.promises.writeFile`）方法。

3. **跨环境支持**
   * **Node.js 环境**：通过 npm 安装即可使用。
   * **浏览器环境**：支持 Origin Private File System (OPFS)，允许在浏览器中操作“虚拟文件”，并可持久化到本地存储。

4. **高级扩展能力**
   * **unionfs**：合并多个文件系统实例（如 memfs + 物理磁盘），构建分层存储结构。
   * **crudfs/casfs**：实现 CRUD 风格抽象和内容寻址存储，适合版本控制、增量备份等场景。

## 安装

::: npm-to

```sh
npm install memfs
```

:::

## 使用

```ts
const { fs, vol } = require('memfs')

// 写入文件
fs.writeFileSync('/demo.txt', 'Hello memfs!')

// 读取文件
console.log(fs.readFileSync('/demo.txt', 'utf8')) // 输出: Hello memfs!

// 初始化预置文件结构
vol.fromJSON({
  '/config/settings.json': '{"theme": "dark"}',
  '/data/logs.txt': 'Log entry...'
}, '/virtual-root')
```

## 应用场景

1. **单元测试（避免污染真实磁盘）**

   ```ts
   import { fs, vol } from 'memfs'

   vol.fromJSON({ '/test/file.txt': 'mock data' })

   // 测试函数：检查文件是否存在
   test('check file existence', () => {
     expect(fs.existsSync('/test/file.txt')).toBe(true)
   })
   vol.reset() // 清理状态
   ```

2. **前端工具链优化**
   * 用于 Webpack 等构建工具，将编译产物暂存内存，避免磁盘 I/O 瓶颈，提速构建过程。

3. **临时数据沙盒**

   ```ts
   // 安全处理用户上传的临时文件
   fs.writeFileSync('/tmp/user-upload.jpg', buffer)
   processImage('/tmp/user-upload.jpg')
   // 进程退出后自动清除，无残留
   ```

## 生态系统与集成

1. **与测试框架结合**

   * **Jest/Vitest**：通过 `vi.mock` 替换 `fs` 模块，精准控制测试环境：

     ```ts
     vi.mock('fs', () => ({ default: memfs.fs }))
     vi.mock('fs/promises', () => memfs.fs.promises)
     ```

2. **扩展工具链**
   * **unionfs**：合并物理磁盘与内存文件系统，实现混合存储策略。
   * **fs-monkey**：动态劫持 Node.js 原生 `fs` 调用，重定向到 memfs（慎用于生产环境）。

## 注意事项

1. **内存管理**
   * 避免操作超大文件（如 GB 级），防止内存溢出（OOM）。
   * 使用 `vol.reset()` 及时清理测试残留数据。

2. **测试覆盖率提升技巧**

   * 使用 `vol.toJSON()` 导出内存文件结构，验证复杂操作结果：

     ```js
     expect(vol.toJSON()).toEqual({ '/result.json': '{"status": "success"}' })
     ```

3. **生产环境适用性**
   * 适用于**短期数据处理**（如请求级临时文件），但**不可替代持久化存储**。

---

---
url: /czxBlog/fe-oss/micromatch/index.md
---
# micromatch
## 概述

针对 **JavaScript/Node.js** 的 glob 匹配工具。作为 minimatch 和 multimatch 的更快速替代方案。

## 场景

* 检查当前文件的路径是否符合特定模式
* 当需要从一个文件列表中 过滤/排除 出符合特定模式的文件集合

## 安装

:::npm-to

```sh
npm install micromatch
```

:::

## 使用

```ts
import micromatch from 'micromatch'

// 返回匹配的列表
console.log(micromatch(['foo', 'bar', 'baz', 'qux'], ['f*', 'b*'])) // => ['foo', 'bar', 'baz']
console.log(micromatch(['foo', 'bar', 'baz', 'qux'], ['*', '!b*'])) // => ['foo', 'qux']

// 检查是否匹配
console.log(micromatch.isMatch('foo', 'f*')) // => true
console.log(micromatch.isMatch('foo', ['b*', 'f*'])) // => true

// 根据模式返回一个匹配函数
const isMatch = mm.matcher('*.!(*a)')
console.log(isMatch('a.a')) // => false
console.log(isMatch('a.b')) // => true
```

---

---
url: /czxBlog/fe-oss/minimatch/index.md
---
# minimatch
## 概述

一个极简的匹配工具。

这是 **npm** 内部使用的匹配库。

其工作原理是将 glob 表达式转换为 JavaScript 正则表达式对象。

## 场景

* 检查当前文件的路径是否符合特定模式
* 当需要从一个文件列表中 过滤/排除 出符合特定模式的文件集合

## 安装

:::npm-to

```sh
npm install minimatch
```

:::

## 使用

## 基础用法

```ts
import { minimatch } from 'minimatch'

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
```

## 从文件列表中过滤

`minimatch.filter(pattern)` 返回一个用于测试其输入参数的函数，适合与 `Array.filter` 一起使用

```ts
import { minimatch } from 'minimatch'

const filtered = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
```

---

---
url: /czxBlog/fe-oss/minimist/index.md
---
# minimist
## 概述

**minimist** 是一个轻量级的 Node.js 命令行参数解析库。

它专注于将 `process.argv` 中的原始参数转换为结构化对象，支持短选项（如 `-a`）、长选项（如 `--debug`）、类型自动转换（布尔值、数字）、别名配置等特性。

## 特性

* **灵活的选项解析**

  * **短选项/长选项**：支持 `-a 1` 和 `--option=value` 格式。
  * **无值选项自动转布尔值**：例如 `--debug` 解析为 `{ debug: true }`。
  * **带值选项**：如 `--port 8080` 解析为 `{ port: 8080 }`。

* **类型控制**

  * **`boolean` 选项**：强制参数为布尔类型（如 `{ boolean: ['verbose'] }`），避免歧义。
  * **`string` 选项**：强制参数为字符串（如 `{ string: ['file'] }`），空值转为空字符串 `""`。
  * **数字自动转换**：若值为数字字符串（如 `--port "8080"`），自动转为数字类型。

* **高级配置**

  * **别名（`alias`）**：例如 `{ alias: { h: 'help' } }`，使 `-h` 和 `--help` 等效。
  * **默认值（`default`）**：为未提供参数设置默认值。
  * **特殊符号 `--`**：`--` 后的参数存入 `_` 数组（如 `node app.js -- file1` → `{ _: ['file1'] }`）。

* **轻量高效**
  无外部依赖，代码精简，适合嵌入小型工具或学习源码设计。

## 安装

通过 npm 安装：

::: npm-to

```sh
npm install minimist
```

:::

## 使用

### 基础解析

```ts
const args = minimist(process.argv.slice(2))
console.log(args)
```

运行命令及输出：

```bash
$ node app.js --name=foo -x 1 --verbose
{ _: [], name: 'foo', x: 1, verbose: true }
```

### 类型强制与别名

```ts
const args = minimist(process.argv.slice(2), {
  boolean: ['debug'], // 强制 debug 为布尔值
  string: ['config'], // 强制 config 为字符串
  alias: { d: 'debug' }, // -d 等价于 --debug
  default: { debug: false } // 默认值
})
```

```bash
$ node app.js -d --config=path/to/file
{ _: [], debug: true, config: 'path/to/file', d: true }
```

### 处理歧义场景

当参数可能被误解析为值时，通过 `boolean` 或 `string` 明确类型：

```sh
node app.js -r value
```

* **默认**：`{ r: 'value' }`
* **`{ boolean: ['r'] }`**：`{ r: true, _: ['value'] }`。

## 使用场景

* **CLI 工具开发**
  * 快速解析用户输入，如 Vue CLI 用其校验参数数量：

    ```ts
    if (minimist(process.argv.slice(3))._.length > 1) {
      console.log('提示：仅首个参数被用作应用名称')
    }
    ```

* **自动化脚本**

  * 在 Gulp 等构建工具中处理自定义参数（如 `gulp build --env=prod`）。

* **轻量级配置管理**

  * 替代复杂配置库，适用于一次性脚本或简单应用。

---

---
url: /czxBlog/fe-oss/node-fs/index.md
---
# node:fs
## 概述

对文件进行操作，包括读取、写入、删除、重命名等操作。

`node:fs` 模块从 `v20` ，其表现已足够覆盖大多数文件操作的需求，无需再依赖其他的文件系统模块。

[**node:fs** 官方文档](https://nodejs.org/docs/latest/api/fs.html){.read-more}

## 其它可代替方案

* [fs-extra](https://github.com/jprichardson/node-fs-extra)
* [graceful-fs](https://github.com/isaacs/node-graceful-fs)

## 读取文件

### 同步阻塞读取

```ts
import { readFileSync } from 'node:fs'

const data = readFileSync('path/to/file', 'utf8')
```

### 异步读取

```ts
import { readFile } from 'node:fs/promises'

const data = await readFile('path/to/file', 'utf8')
```

### 读取目录下所有文件

```ts
import { readdir, readFile } from 'node:fs/promises'

// `recursive: true` 递归读取
const files = await readdir('path/to/directory', { recursive: true })

const data = {}
for (const file of files) {
  data[file] = await readFile(file, 'utf8')
}
```

## 写入文件

### 同步阻塞写入

```ts
import { writeFileSync } from 'node:fs'

writeFileSync('path/to/file', 'hello world', 'utf8')
```

### 异步写入

```ts
import { writeFile } from 'node:fs/promises'

await writeFile('path/to/file', 'hello world', 'utf8')
```

### 写入检查

```ts
import { mkdir, writeFile } from 'node:fs/promises'
import path from 'node:path'

// 确保目录存在
// recursive: true 递归创建
await mkdir(path.dirname('path/to/file'), { recursive: true })
await writeFile('path/to/file', 'hello world', 'utf8')
```

## 检查文件是否存在

```ts
import { existsSync } from 'node:fs'

if (existsSync('path/to/file')) {
  // do something
}
```

:::warning 注意
在对文件进行读写时，并不需要使用 `existsSync` 检查文件是否存在，而应该直接读写，通过 `try-catch` 捕获错误。

读写前检查文件是否存在通常被认为是一种 ==反模式=={.danger} 。
:::

## 删除文件

```ts
import { unlink } from 'node:fs/promises'

await unlink('path/to/file')
```

## 删除目录

```ts
import { rm } from 'node:fs/promises'

// `recursive: true` 递归删除
await rm('path/to/directory', { recursive: true })
```

## 复制文件

```ts
import { copyFile } from 'node:fs/promises'

await copyFile('source/file', 'destination/file')
```

## 复制目录

```ts
import { cp } from 'node:fs/promises'

// `recursive: true` 递归复制
await cp('source/directory', 'destination/directory', { recursive: true })
```

---

---
url: /czxBlog/fe-oss/node-glob/index.md
---
# glob
## 概述

[**glob** 官方文档](https://github.com/isaacs/node-glob){.read-more}

使用 shell 的模式来匹配文件。

这是 JavaScript 中最正确且第二快的 glob 实现。

![glob](https://github.com/isaacs/node-glob/raw/main/logo/glob.png)

## 安装

:::npm-to

```sh
npm install glob
```

:::

## 使用

```ts
import { glob, Glob, globStream, globStreamSync, globSync } from 'glob'
```

```ts
// 所有js文件，但不要查看node_modules
const jsfiles = await glob('**/*.js', { ignore: 'node_modules/**' })

// 支持多种模式
const images = await glob(['css/*.{png,jpeg}', 'public/*.{png,jpeg}'])

// 使用同步模式
const imagesAlt = globSync('{css,public}/*.{png,jpeg}')

// 使用流模式
const filesStream = globStream(['**/*.dat', 'logs/**/*.log'])

const g = new Glob('**/foo', {})
// glob 对象是异步迭代器，也可以执行 globIterate() 或
// g.iterate()，效果相同
for await (const file of g) {
  console.log('found a foo file:', file)
}
```

```ts
// 自定义忽略规则可以这样设置，例如通过以下方式：
// 这将忽略所有markdown文件以及名为'docs'的文件夹
const customIgnoreResults = await glob('**', {
  ignore: {
    ignored: p => /\.md$/.test(p.name),
    childrenIgnored: p => p.isNamed('docs'),
  },
})
```

---

---
url: /czxBlog/fe-oss/ofetch/index.md
---
# ofetch
&#x20;&#x20;

## 概述

ofetch 是由 UnJS 团队开发的增强版 Fetch API 库，基于 TypeScript 实现，兼容 Node.js、浏览器和 Web Workers 环境。
它在原生 fetch 的基础上引入了 **智能响应处理**、**错误自动抛出**、**请求拦截** 等特性，同时保留了轻量级（约 4KB）和类型安全的优势。

### 特性

* 智能响应解析：自动处理 JSON、文本、二进制等响应类型，无需手动调用 .json() 等方法
* 全局拦截器：支持 onRequest、onResponse 和 onError 拦截器，用于统一添加请求头、处理错误或日志
* 自动错误处理：非 2xx 响应状态码自动抛出错误，并附带结构化错误信息（如 error.data 和 error.status）
* TypeScript 原生支持：提供完整的类型定义，支持请求/响应类型推断
* 多环境兼容：在 Node.js 中基于 node-fetch-native 实现，浏览器端复用原生 Fetch API

## 安装

::: npm-to

```sh
npm install ofetch
```

:::

## 使用

### 基础示例

```ts
import { ofetch } from 'ofetch'

// 自动解析 JSON 响应
const data = await ofetch('https://api.example.com/users')

// 处理二进制数据（如图片）
const imageBlob = await ofetch('/api/avatar', {
  responseType: 'blob'
})
```

### 全局配置与拦截器

```ts
const customFetch = ofetch.create({
  baseURL: 'https://api.example.com',
  headers: { Authorization: 'Bearer TOKEN' },
  timeout: 5000, // 5 秒超时
  retry: 2, // 自动重试次数
  onRequest({ options }) {
    // 请求前添加逻辑
    options.headers.set('X-Request-Source', 'browser')
  }
})
```

### 错误处理

```ts
try {
  await ofetch('https://api.example.com/invalid')
}
catch (error) {
  console.error(`Status: ${error.status}`) // 输出状态码（如 404）
  console.error(`Data: ${error.data}`) // 输出错误响应体
}
```

## 使用场景

* Nuxt.js 应用：

  ofetch 是 Nuxt 的默认 HTTP 客户端（通过 $fetch）。可通过插件注入全局配置：

  ```ts
  // plugins/fetch.js
  export default defineNuxtPlugin(() => {
    const { apiToken } = useRuntimeConfig().public
    globalThis.$fetch = ofetch.create({
      headers: { Authorization: `Bearer ${apiToken}` }
    })
  })
  ```

* 全栈 JavaScript 项目：

  在 Node.js 后端服务中替代 axios 或 node-fetch，实现前后端请求逻辑统一

* 轻量级前端应用：

  对包体积敏感的项目，ofetch 的轻量化优势明显

---

---
url: /czxBlog/fe-oss/ora/index.md
---
# ora
## 概述

:::center

优雅的终端加载 spinner

![ora spinner](https://github.com/sindresorhus/ora/raw/main/screenshot.svg)
:::

当你的任务需要进行长时间的等待其完成时，给出一个 loading spinner 就很有用了。

## 安装

::: npm-to

```sh
npm install ora
```

:::

## 使用

```ts
import ora from 'ora'

// 创建一个 spinner，注意需要调用 start() 才会显示
const spinner = ora('Loading unicorns').start()

// 可以在任何时候更改 spinner 的状态
setTimeout(() => {
  spinner.color = 'yellow'
  spinner.text = 'Loading rainbows'
}, 1000)

// 当你的长任务完成时
// 如果 成功
spinner.succeed()
// 如果 失败
spinner.fail('fail')
// 中断并输出信息
spinner.info('info')
// 中断并输出警告
spinner.warn('warn')
// 直接中断
spinner.stop()

// 清理 spinner
spinner.clear()
```

::: center
![ora](https://github.com/sindresorhus/ora/raw/main/screenshot-2.gif){style="max-width:320px"}
:::

---

---
url: /czxBlog/fe-oss/path-to-regexp/index.md
---
# path-to-regexp
## 概述

[**path-to-regexp** 官方文档](https://github.com/pillarjs/path-to-regexp){.read-more}

将路径字符串，如 `/user/:name`，转换为正则表达式。

此模块是 `Express` 的基础依赖，可以用于 Node.js 中的路由匹配等场景。

## 安装

::: npm-to

```sh
npm install path-to-regexp
```

:::

## 路径规则

::: warning `v6` 和 `v8`
最新的 `v8` 版本和 旧版本 `v6` 在路径规则上差异较大，废弃了很多参数规则。

此处仅介绍 `v8` 的路径规则
:::

### 参数

在 `/user/:name` 中， `:name` 表示为一个参数，它可以匹配 `/user/mark` 这样的路径。
被匹配的参数可以通过 `params` 获取到，解析为 `{ params: { name: 'mark' } }`

`/:foo/:bar` 表示两个参数，可以匹配 `/foo/bar` 这样的路径，解析为 `{ params: { foo: 'foo', bar: 'bar' } }`

### 通配符

通配符参数可匹配跨多个段的一个或多个字符。其定义方式与常规参数相同，但需以星号（\*foo）作为前缀。

比如 `/*splat` 可以匹配 `/foo/bar` 这样的路径，解析为 `{ params: { splat: ['foo', 'bar'] } }`

通常情况下，通配符参数应该在最后，因为匹配结果的优先级是从左到右的。

### 可选部分

大括号可用于定义路径中可选的部分。

**可选部分不只指参数可选，路径中的任何部分都可以被定义为可选。**

比如 `/user{/:id}/delete` 可以匹配 `/user/delete` 和 `/user/123/delete` 这样的路径:

* `/user/delete` 解析为 `{ params: {} }`
* `/user/123/delete` 解析为 `{ params: { id: '123' } }`

## 使用

```ts
import { compile, match, parse, pathToRegexp, stringify } from 'path-to-regexp'
```

### 路径匹配

```ts
// 创建匹配函数
const matchFn = match('/user/:id')

matchFn('/user/123') // { path: '/user/:id', params: { id: '123' }

matchFn('/u/abc') // 不匹配则返回 false
```

### 路径正则表达式

```ts
const { regexp, keys } = pathToRegexp('/user/:id')

const result = regexp.exec('/user/123') // // ['/user/123', '123']
// 执行正则表达式，匹配参数顺序保存在 keys 中
console.log(keys) // [{ type: 'param', name: 'id' }]
```

### compiler

`compiler(path)` 是反向的 `pathToRegexp`，可以将 路径规则 + 参数 转换为路径字符串

```ts
const toPath = compile('/user/:id')

toPath({ id: 'name' }) // => "/user/name"
```

---

---
url: /czxBlog/fe-oss/pathe/index.md
---
# pathe
## 概述

由于历史原因，Windows系统沿袭了MS-DOS的传统，采用反斜杠作为路径分隔符，而非macOS、Linux等Posix操作系统使用的正斜杠。
如今 Windows 系统已同时支持正斜杠与反斜杠的路径表示。
Node.js 内置的 `path` 模块在默认操作时会根据运行的操作系统采用不同处理方式——当运行于Windows系统时，该模块会默认采用Windows风格的路径处理逻辑，这导致了Windows与POSIX系统间的代码行为差异。

与流行的 [upath](./upath.md) 相比，pathe 在提供与 Node.js 完全兼容的API导出的同时，实现了所有操作结果的路径标准化。该库采用现代ESM/TypeScript 编写，且不依赖 Node.js 运行时环境！

本包可作为 Node.js 原生 `path` 模块的无缝替代方案，始终将路径标准化为正斜杠 `/` 格式，并确保在包括 Node.js 在内的各类环境中稳定运行。

::: tip `pathe` 可直接作为 `node:path` 的直接替代方案
:::

## 安装

::: npm-to

```sh
npm install pathe
```

:::

## 使用

```ts
// ESM / Typescript
import { matchesGlob, resolve } from 'pathe'
```

## API

与 `node:path` API 完全兼容。

[**`node:path` API 文档**](https://nodejs.org/api/path.html){.read-more}

---

---
url: /czxBlog/fe-oss/picocolors/index.md
---
# picocolors
&#x20;

## 概述

`picocolors` 号称是 ==最小最快的 ANSI 终端色彩输出格式化库== 。

它可以帮助我们在控制台中进行日志格式化输出时，对文本进行彩色高亮。

## 安装

::: npm-to

```sh
npm install picocolors
```

:::

## 使用

在项目中导入 `picocolors`

```ts
import pc from 'picocolors'
```

然后使用它:

```ts
console.log(`I see a ${pc.red('red door')} and I want it painted ${pc.black('black')}`)
```

## 文本颜色

`black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`, `white`, `gray`

::: flex center

```ts
console.log(pc.black('black'))
console.log(pc.red('red'))
console.log(pc.green('green'))
console.log(pc.yellow('yellow'))
console.log(pc.blue('blue'))
console.log(pc.magenta('magenta'))
console.log(pc.cyan('cyan'))
console.log(pc.white('white'))
console.log(pc.gray('gray'))
```

![picocolors text colors](./assets/picocolors-1.png){.flex-img style="width:90px"}
:::

`blackBright`, `redBright`, `greenBright`, `yellowBright`, `blueBright`, `magentaBright`, `cyanBright`, `whiteBright`

::: flex center

```ts
console.log(pc.blackBright('black'))
console.log(pc.redBright('red'))
console.log(pc.greenBright('green'))
console.log(pc.yellowBright('yellow'))
console.log(pc.blueBright('blue'))
console.log(pc.magentaBright('magenta'))
console.log(pc.cyanBright('cyan'))
console.log(pc.whiteBright('white'))
```

![picocolors text colors](./assets/picocolors-2.png){.flex-img style="width:90px"}
:::

## 背景颜色

`bgBlack`, `bgRed`, `bgGreen`, `bgYellow`, `bgBlue`, `bgMagenta`, `bgCyan`, `bgWhite`

::: flex center

```ts
console.log(pc.bgBlack('black'))
console.log(pc.bgRed('red'))
console.log(pc.bgGreen('green'))
console.log(pc.bgYellow('yellow'))
console.log(pc.bgBlue('blue'))
console.log(pc.bgMagenta('magenta'))
console.log(pc.bgCyan('cyan'))
console.log(pc.bgWhite('white'))
```

![picocolors bg colors](./assets/picocolors-3.png){.flex-img style="width:90px"}
:::

`bgBlackBright`, `bgRedBright`, `bgGreenBright`, `bgYellowBright`, `bgBlueBright`, `bgMagentaBright`, `bgCyanBright`, `bgWhiteBright`

::: flex center

```ts
console.log(pc.bgBlackBright('black'))
console.log(pc.bgRedBright('red'))
console.log(pc.bgGreenBright('green'))
console.log(pc.bgYellowBright('yellow'))
console.log(pc.bgBlueBright('blue'))
console.log(pc.bgMagentaBright('magenta'))
console.log(pc.bgCyanBright('cyan'))
console.log(pc.bgWhiteBright('white'))
```

![picocolors bg colors](./assets/picocolors-4.png){.flex-img style="width:90px"}
:::

## 文本修饰

`dim`, `bold`, `hidden`, `italic`, `underline`, `strikethrough`, `reset`, `inverse`

::: flex center

```ts
console.log(pc.dim('dim'))
console.log(pc.bold('bold'))
console.log(pc.hidden('hidden'))
console.log(pc.italic('italic'))
console.log(pc.underline('underline'))
console.log(pc.strikethrough('strikethrough'))
console.log(pc.reset('reset'))
console.log(pc.inverse('inverse'))
```

![picocolors bg colors](./assets/picocolors-5.png){.flex-img style="width:110px"}
:::

## 组合使用

::: flex center

```ts
console.log(pc.red(pc.bold('red')))
console.log(pc.bgRed(pc.bold('red')))
console.log(pc.cyan(pc.underline('cyan')))
```

![picocolors bg colors](./assets/picocolors-6.png){.flex-img style="width:110px"}
:::

---

---
url: /czxBlog/fe-oss/picomatch/index.md
---
# picomatch
## 概述

一款基于 JavaScript 编写的极速且精准的全局模式匹配工具。

无第三方依赖，完整支持标准及扩展的Bash通配功能，包括花括号扩展、扩展通配符、POSIX字符集以及正则表达式。

## 场景

* 检查当前文件的路径是否符合特定模式
* 当需要从一个文件列表中 过滤/排除 出符合特定模式的文件集合

## 安装

:::npm-to

```sh
npm install picomatch
```

:::

## 使用

```ts
import pm from 'picomatch'

const isMatch = pm('*.js')

console.log(isMatch('abcd')) // => false
console.log(isMatch('a.js')) // => true
console.log(isMatch('a.md')) // => false
console.log(isMatch('a/b.js')) // => false
```

---

---
url: /czxBlog/fe-oss/pino/index.md
---
# pino
&#x20;

## 概述

非常低开销的 Node.js 日志库。

[**pino** 官方文档](https://getpino.io/#/){.read-more}

## 使用场景

如果你正在进行、或有如下的需求的：

* 正在开发 Node.js 服务，比如 基于 `fastify` / `express` / `koa` 等框架。
* 需要在 Node.js 服务中进行日志记录，对输出格式有要求。
* 需要将日志输出到文件，或者输出到其他的远程日志服务中。
* 对日志输出有非常高的性能要求。
* 需要根据不同的模块区分日志，或者进行不同的日志级别的控制。

## 安装

:::npm-to

```sh
npm install pino
```

:::

## 使用

### 基础使用

```ts
import pino from 'pino'

const logger = pino()

logger.info('Hello, world!')
```

```console title="日志输出"
{"level":30,"time":1720260263252,"pid":76688,"hostname":"username-xxx.local","message":"Hello, world!"}
```

### 子模块日志

```ts
import pino from 'pino'

const logger = pino()

const childLogger = logger.child({ module: 'auth' })

childLogger.info('Hello, world!')
```

```console title="日志输出"
{"level":30,"time":1720260347150,"pid":76859,"hostname":"username-xxx.local","module":"auth","msg":"Hello, world!"}
```

### 输出到文件

```ts
// destination param may be in first position when no options:
const fileLogger = require('pino')(pino.destination('/log/path'))

// use the stderr file handle to log to stderr:
const opts = { name: 'my-logger' }
const stderrLogger = require('pino')(opts, pino.destination(2))

// automatic wrapping in pino.destination
const fileLogger = require('pino')('/log/path')

// Asynchronous logging
const fileLogger = pino(pino.destination({ dest: '/log/path', sync: false }))
```

## 美化输出

::: warning 建议只在开发模式下使用
:::

:::npm-to

```sh
npm install pino-pretty
```

:::

```ts
import pino from 'pino'

const logger = pino({
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true
    }
  }
})

logger.info('Hello, world!')
```

```console title="日志输出"
[22:33:41.351] INFO (77187): Hello World
```

## 框架集成

### fastify

Fastify 默认集成了Pino日志工具，只需将 Fastify 的 `logger` 选项设为 `true` ，
并通过 `request.log` 或 `reply.log` 记录与每个请求对应的日志信息：

```ts
const fastify = require('fastify')({
  logger: true
})

fastify.get('/', async (request, reply) => {
  request.log.info('something')
  return { hello: 'world' }
})

fastify.listen({ port: 3000 }, (err) => {
  if (err) {
    fastify.log.error(err)
    process.exit(1)
  }
})
```

### express

:::npm-to

```sh
npm install pino-http
```

:::

```ts
const app = require('express')()
const pino = require('pino-http')()

app.use(pino)

app.get('/', (req, res) => {
  req.log.info('something')
  res.send('hello world')
})

app.listen(3000)
```

### koa

:::npm-to

```sh
npm install koa-pino-logger
```

:::

```ts
const Koa = require('koa')
const app = new Koa()
const pino = require('koa-pino-logger')()

app.use(pino)

app.use((ctx) => {
  ctx.log.info('something else')
  ctx.body = 'hello world'
})

app.listen(3000)
```

### h3

:::npm-to

```sh
npm install pino-http
```

:::

```ts
import { createApp, createRouter, eventHandler, fromNodeMiddleware } from 'h3'
import pino from 'pino-http'

export const app = createApp()

const router = createRouter()
app.use(router)
app.use(fromNodeMiddleware(pino()))

app.use(eventHandler((event) => {
  event.node.req.log.info('something')
  return 'hello world'
}))

router.get(
  '/',
  eventHandler((event) => {
    return { path: event.path, message: 'Hello World!' }
  }),
)
```

### Nestjs

:::npm-to

```sh
npm install nestjs-pino
```

:::

```ts
import { Controller, Get, Module } from '@nestjs/common'
import { NestFactory } from '@nestjs/core'
import { Logger, LoggerModule } from 'nestjs-pino'

@Controller()
export class AppController {
  constructor(private readonly logger: Logger) {}

  @Get()
  getHello() {
    this.logger.log('something')
    return `Hello world`
  }
}

@Module({
  controllers: [AppController],
  imports: [LoggerModule.forRoot()]
})
class MyModule {}

async function bootstrap() {
  const app = await NestFactory.create(MyModule)
  await app.listen(3000)
}
bootstrap()
```

---

---
url: /czxBlog/fe-oss/quick-lru/index.md
---
# quick-lru
&#x20;

## 概述

一个轻量级、高性能的 \*\*最近最少使用（LRU）\*\*缓存库，专为 Node.js 和现代浏览器设计。
通过灵活的内存管理和高效的数据淘汰策略，广泛应用于需要优化资源占用的场景。

## 安装

::: npm-to

```sh
npm install quick-lru
```

:::

## 使用

```ts
import QuickLRU from 'quick-lru'

// 初始化缓存（最大100条，条目存活10秒）
const lru = new QuickLRU({ maxSize: 100, maxAge: 10000 })

// 写入数据
lru.set('user1', { name: 'Alice' })

// 读取数据
lru.get('user1') // => { name: 'Alice' }

// 查看数据，不更新访问时间
lru.peek('user1') // => { name: 'Alice' }

// 检查是否存在
lru.has('user1') // => true

// 删除数据
lru.delete('user1')

// 清空缓存
lru.clear()
```

## 适用场景

* 中小型应用，小规模的缓存，需要优化内存占用
* **数据库查询缓存**：减少重复查询，如缓存用户信息2。
* **API 响应缓存**：存储第三方 API 结果，降低调用频率（需注意数据时效性）
* **前端资源缓存**：预加载图片或计算密集型操作结果

---

---
url: /czxBlog/fe-oss/superagent/index.md
---
# superagent
&#x20;

## 概述

Superagent 是一个轻量级、渐进式的JavaScript HTTP客户端库，适用于Node.js和浏览器环境。它由TJ Holowaychuk创建，以链式语法设计为核心，提供灵活、可读性强的API，大幅简化HTTP请求处理流程。

### 特性

* 跨平台支持：在Node.js（基于HTTP模块）和浏览器（基于XMLHttpRequest）中保持一致的API设计
* 轻量与高性能：无冗余依赖，压缩后仅约6KB，支持Promise、async/await和回调函数等多种异步模式
* 插件生态：可通过中间件扩展功能（如缓存控制、请求重试）
* 自动化数据处理：内置对JSON、表单数据、文件上传（multipart/form-data）的序列化与解析，支持自定义内容类型

## 安装

::: npm-to

```sh
npm install superagent
```

:::

## 使用

### 基础示例

GET 请求

```ts
import superagent from 'superagent'

// 链式写法
superagent
  .get('https://api.example.com/data')
  .query({ page: 2, limit: 10 }) // 生成URL: ?page=2&limit=10
  .set('User-Agent', 'MyApp/1.0')
  .then(res => console.log(res.body))
  .catch(err => console.error(err))
```

POST 请求

```ts
superagent
  .post('https://api.example.com/users')
  .send({ name: 'Alice', age: 30 }) // 自动序列化为JSON
  .set('Content-Type', 'application/json')
  .end((err, res) => {
    if (err)
      throw err
    console.log(res.status, res.body)
  })
```

### 表单提交

```ts
superagent
  .post('/login')
  .type('form') // 设置Content-Type为application/x-www-form-urlencoded
  .send({ user: 'admin', password: 'secret' }) // 编码为: user=admin&password=secret
  .then(res => console.log(res.text))
```

### 文件上传

```ts
import fs from 'node:fs'

superagent
  .post('/upload')
  .attach('file', fs.readFileSync('./image.png'), 'image.png')
  .then(res => console.log(res.body))
```

### 流式处理

```ts
const request = superagent.post('/api')
fs.createReadStream('largefile.zip').pipe(request)
```

### 错误处理和超时

```ts
superagent
  .get('/api')
  .timeout(5000) // 5秒超时
  .then((res) => { /* ... */ })
  .catch((err) => {
    if (err.timeout)
      console.error('请求超时')
    else console.error('服务器错误')
  })
```

## 使用场景

* 爬虫开发：

  * 模拟浏览器请求头（如User-Agent、Referer）绕过反爬机制，爬取动态网页内容。
  * 链式查询参数拼接与响应解析（HTML/JSON）简化数据提取

* 前后端API交互

* 微服务通信：服务间轻量级HTTP调用，支持文件流传输降低内存占用

---

---
url: /czxBlog/fe-oss/tiny-glob/index.md
---
# tiny-glob
## 概述

[**tiny-glob** 官方文档](https://github.com/terkelg/tiny-glob){.read-more}

微型且极速的文件与文件夹匹配库，支持使用通配符模式。

**比 [glob](./glob.md) 快约 350%！** **比 [fast-glob](./fast-glob.md) 快约 230%！**

## 安装

:::npm-to

```sh
npm install tiny-glob
```

:::

## 使用

```ts
import glob from 'tiny-glob'

let files = await glob('src/*/*.{js,md}')
```

---

---
url: /czxBlog/fe-oss/tinyglobby/index.md
---
# tinyglobby
## 概述

[**tinyglobby** 官方文档](https://github.com/SuperchupuDev/tinyglobby){.read-more}

一个快速且极简的替代方案，旨在与 `globby` 和 `fast-glob` 保持相同行为。

## 安装

:::npm-to

```sh
npm install tinyglobby
```

:::

## 使用

```ts
import { glob, globSync } from 'tinyglobby'

await glob(['files/*.ts', '!**/*.d.ts'], { cwd: 'src' })
globSync(['src/**/*.ts'], { ignore: ['**/*.d.ts'] })
```

---

---
url: /czxBlog/fe-oss/unconfig/index.md
---
# unconfig
## 概述

\==unconfig== 是一个轻量级、高度灵活的 Node.js 开源工具库，专注于简化配置文件读取的过程。
它由 Vue 和 Vite 核心团队成员 Anthony Fu 开发，旨在解决工具库和框架中多格式配置文件的兼容性问题。

**unconfig 默认支持 `ts`, `mjs`, `js`, `json`**

## 安装

::: npm-to

```sh
npm install unconfig
```

:::

## 使用

```ts
import { loadConfig } from 'unconfig'

const { config, sources } = await loadConfig({
  sources: [
    // const `my.config.xx` 加载
    {
      files: 'my.config',
      // 默认扩展
      extensions: ['ts', 'mts', 'cts', 'js', 'mjs', 'cjs', 'json', ''],
    },
    // 如果在上述配置文件中未找到，则加载`package.json`中的`my`字段
    {
      files: 'package.json',
      extensions: [],
      rewrite(config) {
        return config?.my
      },
    },
    // 从 `vite.config` 加载内联配置
    {
      files: 'vite.config',
      async rewrite(config) {
        const resolved = await (typeof config === 'function' ? config() : config)
        return resolved?.my
      },
    },
    // ...
  ],
  // 如果为false，则仅加载第一个匹配项
  // 如果为true，将加载所有匹配项并进行深度合并
  merge: false,
})
```

---

---
url: /czxBlog/fe-oss/undici/index.md
---
# undici
## 概述

[**undici** 官方文档](https://undici.nodejs.org/){.read-more}

\==undici== 是由 Node.js 官方团队开发的高性能 HTTP/1.1 客户端库。

它旨在解决 Node.js 原生 HTTP 模块的设计瓶颈，通过底层优化实现显著的性能提升，并支持 HTTP/2 和代理等高级特性

::: tip Node.js 自 v18 版本起内置了基于 `undici` 实现的 `fetch()` 功能。
:::

## 安装

::: npm-to

```sh
npm install undici
```

:::

## 使用

### 基础请求

使用 `fetch`:

```ts
import { fetch } from 'undici'

const response = await fetch('http://localhost:3000/api', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ account: 'test', password: '123456' })
})
const data = await response.json()
```

使用 `request`:

```ts
import { request } from 'undici'

const { statusCode, body } = await request('http://localhost:3000/api')
for await (const chunk of body) {
  console.log(chunk.toString()) // 流式处理响应
}
```

### 连接复用

创建持久化客户端实例，提升重复请求效率：

```ts
import { Client } from 'undici'

const client = new Client('http://localhost:3000')
const { body } = await client.request({ path: '/api', method: 'GET' })
body.on('data', console.log) // 事件监听数据流
```

### 代理转发

```ts
import { createServer } from 'node:http'
import { Client } from 'undici'

const client = new Client('http://upstream-server')
createServer((req, res) => {
  client.stream({ path: req.url, opaque: res }, ({ opaque }) => opaque)
}).listen(3010)
```

### 文件下载

```ts
import fs from 'node:fs'
import { stream } from 'undici'

const out = fs.createWriteStream('./image.jpg')
stream('https://example.com/image.jpg', { opaque: out }, ({ opaque }) => opaque)
```

### 全局代理配置

```ts
import { ProxyAgent, setGlobalDispatcher } from 'undici'

// HTTP 代理
setGlobalDispatcher(new ProxyAgent({ uri: 'http://127.0.0.1:7890' }))

// SOCKS5 代理
setGlobalDispatcher(new ProxyAgent({ uri: 'socks5://127.0.0.1:1080' }))

// 此后所有 fetch 请求均通过代理
fetch('https://httpbin.org/ip').then(res => res.json()).then(console.log)
```

### 请求中断

```ts
import AbortController from 'abort-controller'
import { request } from 'undici'

const controller = new AbortController()
request('http://localhost:3000', { signal: controller.signal })
  .catch(err => console.error(err.name)) // 捕获 RequestAbortedError

controller.abort() // 主动中断
```

## 使用场景

* **高性能后端服务**

  * **API 网关/微服务**：高并发下保持低延迟，连接池复用降低资源消耗
  * **实时数据处理**：流式响应支持即时处理大文件或持续数据流（如日志分析）

* **爬虫与数据抓取**

  * **批量请求优化**：管道化（Pipeline）模式显著提升网页抓取效率

* **代理与中间件**

  * **全局代理**：通过 ProxyAgent 统一管理出口流量，无需修改业务代码

* **资源受限环境**

  * **低内存占用**：适合 IoT 设备或嵌入式系统

---

---
url: /czxBlog/fe-oss/upath/index.md
---
# upath
::: warning 该库上次更新为 `2020-11-07`
:::

## 概述

[**upath** 文档](https://github.com/anodynos/upath){.read-more}

一个可无缝替代/代理 Node.js `path` 模块的工具，具备以下特性：

* 将所有字符串参数和返回结果中的Windows反斜杠 `\` 替换为 Unix 斜杠 `/` 。

* 新增文件扩展名处理函数：
  * addExt - 添加扩展名
  * trimExt - 修剪扩展名
  * removeExt - 移除扩展名
  * changeExt - 更改扩展名
  * defaultExt - 设置默认扩展名

* 扩展标准化功能：
  * normalizeSafe - 保留有意义的起始`./`路径标记
  * normalizeTrim - 在normalizeSafe基础上额外去除冗余的末尾`/`

* 提供辅助函数toUnix：简单实现 `\` 到 `/` 的转换并合并重复斜杠

## 安装

::: npm-to

```sh
npm install upath
```

:::

## 使用

```ts
import upath from 'upath'

upath.normalize('path/to/file')
upath.join('path', 'to', 'file')
```

## API

与 `node:path` API 完全兼容。

[**`node:path` API 文档**](https://nodejs.org/api/path.html){.read-more}

---

---
url: /czxBlog/fe-oss/validator/index.md
---
# validator
&#x20;

## 概述

[**validator** 官方文档](https://github.com/validatorjs/validator.js){.read-more}

`validator` 是一个功能强大的 JavaScript 字符串验证库和过滤工具，专为 Node.js 和浏览器环境设计。
它提供了超过 100 种验证器和清理器（sanitizers），用于处理表单数据、API输入等字符串验证场景。

::: important 此库仅验证并清理字符串。
:::

## 安装

::: npm-to

```sh
npm install validator
```

:::

## 使用

```ts
import { isEmail, /* ... */ } from 'validator'
```

### 基础示例

```ts
// 验证邮箱
isEmail('test@example.com'); // true

// 清理邮箱格式
normalizeEmail('TEST@GMAIL.COM'); // 输出：'test@gmail.com'
```

## 表单验证

```ts
function validateUser(data) {
  const errors = [];
  if (isEmpty(data.username)) errors.push('用户名不能为空');
  if (!isEmail(data.email)) errors.push('邮箱无效');
  return errors.length ? { errors } : data;
}
```

## 使用场景

* **后端验证**：在 Node.js 中校验API请求参数。
* **前端表单**：结合 React/Vue 实时验证用户输入。
* **数据清洗**：过滤用户输入的 XSS 风险字符（如 `escape()`）。
* **自动化测试**：验证数据格式是否符合预期。

---

---
url: /czxBlog/fe-oss/vconsole/index.md
---
# vconsole
&#x20;

## 概述

一个轻量、可拓展、针对手机网页的前端开发者调试面板。

vConsole 是框架无关的，可以在 Vue、React 或其他任何框架中使用。

现在 vConsole 是微信小程序的官方调试工具。

## 场景

在移动端设备中调试网页是一件比较麻烦的事情，因为缺少了浏览器的调试面板，我们很难直观的看到代码执行发生了
什么错误。

vConsole 旨在解决这个问题，它在页面中注入了一个面板，模拟了浏览器的调试面板，让你可以直观的看到网页的执行情况。
比如 元素、网络请求、日志输出等等。

## 安装

::: npm-to

```sh
npm install vconsole
```

:::

## 使用

```ts
import VConsole from 'vconsole'

const vConsole = new VConsole()
// 或者使用配置参数来初始化，详情见文档
const vConsole = new VConsole({ theme: 'dark' })

// 接下来即可照常使用 `console` 等方法
console.log('Hello world')

// 结束调试后，可移除掉
vConsole.destroy()
```

## 从 CDN 加载

```html
<script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script>
<script>
  // VConsole 默认会挂载到 `window.VConsole` 上
  var vConsole = new window.VConsole();
</script>
```

可用的 CDN：

* <https://unpkg.com/vconsole@latest/dist/vconsole.min.js>
* <https://cdn.jsdelivr.net/npm/vconsole@latest/dist/vconsole.min.js>

## 手机预览

:::center
<http://wechatfe.github.io/vconsole/demo.html>

![qrcode](https://github.com/Tencent/vConsole/raw/dev/doc/screenshot/qrcode.png)
:::

## 效果图

日志输出：

![vconsole 1](https://github.com/Tencent/vConsole/raw/dev/doc/screenshot/overview_light.jpg)

![vconsole 2](https://github.com/Tencent/vConsole/raw/dev/doc/screenshot/plugin_log_types.jpg)

网络请求：

![vconsole 3](https://github.com/Tencent/vConsole/raw/dev/doc/screenshot/plugin_network.jpg)

元素：

![vconsole 4](https://github.com/Tencent/vConsole/raw/dev/doc/screenshot/plugin_element.jpg)

---

---
url: /czxBlog/fe-oss/yargs-parser/index.md
---
# yargs-parser
&#x20;&#x20;

## 概述

\==yargs-parser== 是一个轻量级、高性能的 Node.js 命令行参数解析库，专注于将原始命令行输入（如 `process.argv`）转换为结构化的 JavaScript 对象。作为流行框架 `yargs` 的核心解析引擎，它提供了高度可定制的解析能力，适合直接集成或作为底层工具使用。

## 特性

* **参数结构化解析**

  将命令行输入（如 `--name=foo -abc 100`）解析为键值对对象，支持：

  * **布尔标志**：`-a` 解析为 `{ a: true }`
  * **键值参数**：`--file config.txt` 解析为 `{ file: "config.txt" }`
  * **数组与嵌套对象**：`--file a.txt --file b.txt` 生成数组 `{ file: ["a.txt", "b.txt"] }`；
    `--db.host localhost` 生成嵌套对象 { `db: { host: "localhost" }` }
  * **位置参数**：未标记的参数保存在 `_` 属性中（如 `node app.js run` → `{ _: ["run"] }`）

* **解析配置**

  * **类型自动转换**：启用 `parse-numbers` 后，`--port 8080` 自动转为数字（而非字符串）
  * **别名系统**：`alias: { n: "name" }` 使 `-n foo` 等效于 `--name foo`
  * **默认值**：`default: { env: "dev" }` 确保未提供参数时使用默认值
  * **驼峰转换**：`camel-case-expansion` 配置将 `--my-option` 转为 `myOption`

## 安装

::: npm-to

```sh
npm install yargs-parser
```

:::

## 使用

```ts title="example.js"
import parse from 'yargs-parser'

const argv = parse(process.argv.slice(2))
console.log(argv)
```

```sh
node example.js --foo=33 --bar hello
{ _: [], foo: 33, bar: 'hello' }
```

## 适用场景

* CLI 工具开发

---

---
url: /czxBlog/fe-oss/yargs/index.md
---
&#x20;

## 概述

[**yargs** 官方文档](https://github.com/yargs/yargs){.read-more}

\==yargs== 是 Node.js 生态中广泛使用的命令行参数解析库，专注于简化 CLI 工具的开发。

## 特性

* 参数解析与类型转换

  自动解析命令行参数，支持字符串、数字、布尔值、数组等类型转换。

* 命令与子命令系统

  支持多级嵌套命令（如 `cli serve start`），每个命令可独立配置参数和逻辑。

  ```ts
  yargs.command('serve [port]', '启动服务', (yargs) => {
    yargs.positional('port', { default: 5000 })
  }, (argv) => { /* 业务逻辑 */ })
  ```

* 自动化文档生成

  * 基于参数描述（`describe`）和用法示例（`usage`）自动生成帮助菜单（`--help`）。
  * 支持添加脚注（`epilog`）和示例（`example`）

## 安装

::: npm-to

```sh
npm install yargs
```

:::

## 使用

```ts
#!/usr/bin/env node

import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'
const argv = yargs(hideBin(process.argv)).parse()

if (argv.ships > 3 && argv.distance < 53.5) {
  console.log('Plunder more riffiwobbles!')
}
else {
  console.log('Retreat from the xupptumblers!')
}
```

```sh
$ ./plunder.js --ships=4 --distance=22
Plunder more riffiwobbles!

$ ./plunder.js --ships 12 --distance 98.7
Retreat from the xupptumblers!
```

### 示例

```ts
#!/usr/bin/env node

import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'

yargs(hideBin(process.argv)) // hideBin 是 process.argv.slice(2) 的简写形式
  // 添加命令
  .command('serve [port]', 'start the server', (yargs) => {
    return yargs
      .positional('port', {
        describe: 'port to bind on',
        default: 5000
      })
  }, (argv) => {
    if (argv.verbose)
      console.info(`start server on :${argv.port}`)
    serve(argv.port)
  })
  .option('verbose', {
    alias: 'v',
    type: 'boolean',
    description: 'Run with verbose logging'
  })
  .parse()
```

## 适用场景

* 脚手架工具
* 运维自动化脚本
* 交互式 CLI 工具
* 配置动态注入

---

---
url: /czxBlog/fe-oss/zod/index.md
---
# zod
&#x20;&#x20;

::: important 相比于 `ajv` / `joi` ，更推荐使用 `zod`
:::

## 概述

[**Zod** 官方文档](https://zod.dev){.read-more}

Zod 是一个以 **TypeScript 优先** 的运行时数据验证库，专为 Node.js 和浏览器环境设计。
它通过声明式模式（Schema）实现数据校验，并自动推断静态 TypeScript 类型，解决了类型声明与运行时验证的重复问题。

## 特性

* **TypeScript 优先**

  Zod 的核心优势在于将 **模式定义与类型推断无缝结合**。
  开发者只需定义一次验证规则，即可自动生成对应的 TypeScript 类型，无需手动维护类型声明。

  ```ts
  const UserSchema = z.object({
    username: z.string(),
    age: z.number().min(0)
  })
  type User = z.infer<typeof UserSchema> // 自动推断为 { username: string; age: number }
  ```

* **轻量与零依赖**

  * 核心库体积仅 **8 KB**（gzip 后约 2 KB），无第三方依赖。
  * 支持 Node.js、浏览器（含 IE11）及 Deno 环境

* **不可变性与链式 API**

  Zod 的 API 设计遵循 **函数式编程** 原则，所有方法（如 **.optional()**、**.array()**）均返回新实例，支持链式调用：

  ```ts
  const PasswordSchema = z.string().min(8).max(32).nonempty()
  ```

## 安装

::: npm-to

```sh
npm install zod
```

:::

## 使用

### 基本用法

```ts
import * as z from 'zod/v4'

const User = z.object({
  name: z.string(),
})

// some untrusted data...
const input = { /* stuff */ }

// the parsed result is validated and type safe!
const data = User.parse(input)

// so you can use it with confidence :)
console.log(data.name)
```

### 处理错误

```ts
try {
  Player.parse({ username: 42, xp: '100' })
}
catch (error) {
  if (error instanceof z.ZodError) {
    error.issues
    /* [
      {
        expected: 'string',
        code: 'invalid_type',
        path: [ 'username' ],
        message: 'Invalid input: expected string'
      },
      {
        expected: 'number',
        code: 'invalid_type',
        path: [ 'xp' ],
        message: 'Invalid input: expected number'
      }
    ] */
  }
}
```

```ts
const result = Player.safeParse({ username: 42, xp: '100' })
if (!result.success) {
  result.error // ZodError instance
}
else {
  result.data // { username: string; xp: number }
}
```

### 类型推断

```ts
const Player = z.object({
  username: z.string(),
  xp: z.number()
})

// extract the inferred type
type Player = z.infer<typeof Player>

// use it in your code
const player: Player = { username: 'billie', xp: 100 }
```

```ts
const mySchema = z.string().transform(val => val.length)

type MySchemaIn = z.input<typeof mySchema>
// => string

type MySchemaOut = z.output<typeof mySchema> // equivalent to z.infer<typeof mySchema>
// number
```

## 使用场景

* API 请求验证
* 表单集成
* 配置文件校验

---

---
url: /czxBlog/interview-question/index.md
---
# 面试题解析
### 说明

本笔记主要用于整理、记录可能会遇到的前端面试题。

::: tip
如果这篇笔记对你有帮助，或者有遇到不错的面试题，可以与我分享，不胜感激！

如果你发现本笔记中有哪些错误，欢迎指出，我将虚心受教！
:::

---

---
url: /czxBlog/interview-question/1416a8f5/index.md
---
# 浅拷贝和深拷贝
::: tip 提问

1. 什么是 浅/深拷贝？
2. 如何实现？

:::

## 浅拷贝

浅拷贝是 创建一个新的对象，这个对象有着原始对象属性值的一份精确拷贝。

如果属性是基本类型，拷贝的就是基本类型的值。

如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

## 深拷贝

从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。

## 浅拷贝的实现方式

* `Object.assign()`
* 展开运算符 `...`
* `Array.prototype.concat()`
* `Array.prototype.slice()`
* 第三方库，如 `lodash.clone()`

## 深拷贝的实现方式

* `JSON.parse(JSON.stringify(plainObj)))`:
  该方法仅能处理原始对象的属性不包括 函数和正则的对象。

* 第三方库，如 `lodash.deepClone()`

* 对原始对象进行 递归克隆，根据属性值的数据类型进行递归拷贝。

## 手写深拷贝实现

```js
function checkType(target) {
  return Object.prototype.toString.call(target).slice(8, -1)
}

function deepClone(target) {
  let result
  const type = checkType(target)
  if (type === 'Object') {
    result = {}
  }
  else if (type === 'Array') {
    result = []
  }
  else {
    return target
  }
  for (const key in target) {
    const value = target[key]
    const type = checkType(value)
    if (type === 'Array' || type === 'Object') {
      result[key] = deepClone(value, map)
    }
    else {
      result[key] = value
    }
  }
  return result
}
```

但是上述代码存在以下问题：

* 未解决循环引用问题
* 如果对象的属性是 Symbol 类型， for...in 不会获取到
* 拷贝对象的原型可能发生改变

所以需要进行如下改造：

```js
function deepClone(obj) {
  // 使用 WeakMap<target, result> 数据结构保存对象的引用
  // 使用WeakMap的好处是及时被垃圾回收
  const map = new WeakMap()
  function check(val) {
    return Object.prototype.toString.call(val).slice(8, -1)
  }
  function clone(target) {
    let result
    const type = check(target)
    if (type === 'Object') {
      // 从目标的构造函数上的原型创建一个新的对象
      result = Object.create(target.constructor.prototype)
    }
    else if (type === 'Array') {
      result = []
    }
    else {
      return target
    }
    // 判断是否有循环引用
    if (map.has(target)) {
      return map.get(target)
    }
    else {
      map.set(target, result)
    }
    // 获取目标对象所有的属性，包括 Symbol类型
    ;[...Object.keys(target), ...Object.getOwnPropertySymbols(target)].forEach((key) => {
      const value = target[key]
      const type = check(value)
      if (type === 'Object' || type === 'Array') {
        result[key] = clone(value)
      }
      else {
        result[key] = value
      }
    })
    return result
  }
  return clone(obj)
}
```

---

---
url: /czxBlog/interview-question/1917jrv3/index.md
---
# UDP协议
::: tip 提问

1. UDP

:::

## UDP协议

UDP 是一个无连接，不可靠的床数层协议。它只提供了传输层需要实现的最低限度的功能。
除了复用/分解功能和少量的差错检测外，几乎没有对IP增加其他东西。

UDP协议适用于对实时性要求高的应用场景。

### 特性

* 通信双方没有握手的过程，不需要建立连接，不需要在端系统中保存链接的状态。

* 不保证数据的可靠交付。

* 发送速率没有限制。

  没有拥塞控制和流量控制的机制。

* 支持 一对一，一对多，多对一的交互通信

* 首部只有8个字节

---

---
url: /czxBlog/interview-question/1cx7kiuy/index.md
---
# keep-alive
::: tip 提问
keep-alive 组件有什么作用？
:::

`keep-alive` 组件包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

主要用于保留组件状态或避免重新渲染。

---

---
url: /czxBlog/interview-question/1ryrldbc/index.md
---
# 组件通信方式
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问
vue2 有多少种组件通信方式？
:::

## 组件通信方式

在 vue中，组件通信的类型，大致可以分为以下几种：

* 父子组件间通信
* 兄弟组件间通信
* 隔代组件间通信

### 1. props/$emit

父组件通过 `props` 将数据传给子组件， 子组件通过 `$emit` 将数据更新通知给父组件。

适用场景：

* 父子组件间通信

### 2. Event Bus

通过 事件总线，通过事件派发将数据更新通知给添加了对应的事件监听的组件。

如，使用一个 空的 Vue实例，通过 `vm.$on` 注册事件监听，通过 `vm.$emit` 触发事件;
或者 自定义实现一个 `EventEmitter`

适用场景：

* 父子组件间通信
* 兄弟组件间通信
* 隔代组件间通信

### 3. provide/inject

通过 在一个祖先组件上 使用 `provide` 为其所有后代组件注入依赖， 在其所有后代组件中，都可以使用 `inject` 来获取到对应的数据。

但 `provide/inject` 的绑定并不是可响应的，可以通过 `Vue.observer` 来优化并提供响应对象

`provide/inject` 需要配合使用。

适用场景：

* 父子组件间通信
* 隔代组件间通信

### 4. $attr / $listener

`$attr` 包含了父作用域中所有不被 props 识别的特性绑定，这些特性可以通过 `v-bind="$attr"` 传入内部组件，
通常配合组件的 `inheritAttrs` 选项一起使用

`$listener` 包含了父作用域中的 `v-on`的事件侦听器（不包含 `.native` 修饰的）。
它可以通过 `v-on="$listener"` 传入内部组件

适用场景：

* 父子组件间通信
* 隔代组件间通信 （多级嵌套的场景）

### 5. $parent / $children / ref

* `ref`: 如果是普通DOM元素上使用，引用指向DOM元素，如果是用在子组件，则引用指向子组件实例
* `parent/$children` 访问父/子 实例

这种方式可以直接拿到 父/子 实例，即可以对 `父/子` 进行任意操作。

（虽然可以用于通信，除非父子组件明确是强耦合的，否则不建议使用)

适用场景：

* 父子组件间通信

### 6. Vuex

Vuex 实现了单向数据流，通过在 全局维护一个 根状态来存放数据。
组件可以通过 `getters` 获取状态数据， 通过 `dispatch` 调用 `action` 触发 `mutation` 更新状态数据。
可以将状态根据某种维度划分为各个模块

适用场景：

* 父子组件间通信
* 兄弟组件间间通信
* 隔代组件间通信

---

---
url: /czxBlog/interview-question/2aywn2ah/index.md
---
# http缓存
请 [查看此文档](/article/c3ez957l/)

---

---
url: /czxBlog/interview-question/2o905emj/index.md
---
# vue2和vue3的区别
::: tip 提问
vue2和vue3的区别
:::

## 区别

* 响应式原理

  vue2 通过 `Object.defineProperties()` 实现数据劫持，结合 发布/订阅模式，将数据变更通知给Watcher，实现响应式。
  vue3 通过 `Proxy` 做数据劫持，实现响应式对象，同时也保留了 `getter/setter` 实现 `ref()`。

* 使用 工厂函数 `createApp()` 代替 构造函数 `new Vue()` 创建应用实例

* 使用 `app.config.globalProperties` 代替 `Vue.prototype` 用于添加全局属性

* 移除了 `Vue.extend`

* `v-model` 使用 `modelValue/emit` 代替了 `value/input` 的实现

* `key` 现在不需要添加在 `v-if` `v-else` `v-else-if` 上，Vue会自己生成，且可以添加在 `<template>` 上。

* `v-if` 的优先级总是高于`v-for` （vue2是反过来的）

* 移除了 `filter` 过滤器

* 自定义指令使用了全新的生命周期

* 移除了 `$children`

* 将 `$listener` 合并到了 `$attrs` 中, `$attrs` 也包含了 `class` 和 `style`

* 使用 `beforeUnmount` 和 `unmounted` 代替 `beforeDestroy` 和 `destroyed`

* 新增了 `setup()` 以及 组合式API

* 新增内置组件 `<Teleport>` 和 `<Suspense>`

---

---
url: /czxBlog/interview-question/2whxs493/index.md
---
# DOCTYPE
::: tip 提问

1. 什么是DOCTYPE？
2. DOCTYPE的作用是什么？
3. 标准模式和兼容模式
4. HTML5 `<!DOCTYPE HTML>`
5. 什么是 DTD？
   :::

## 什么是DOCTYPE

`DOCTYPE` 是 文档类型， 用于声明当前文档使用哪种文档模式进行解析和渲染。

## DOCTYPE的作用是什么？

`<!DOCTYPE>` 声明一般位于文档的第一行，它的作用是告知浏览器以哪种模式进行解析文档。
一般指定之后，会使用标准模式进行文档解析，否则就以兼容模式进行解析。

## 标准模式和兼容模式

* 标准模式 是指 浏览器以该浏览器支持的最高标准进行文档解析和渲染，包括JS引擎。
* 兼容模式 是指 文档以宽松的向后兼容的方式渲染，模拟老式浏览器的行为以防止站点无法工作。

## HTML5的DOCTYPE声明

HTML5的 不需要对 DTD 进行引用。但是需要 DOCTYPE 来规范浏览器的行为。
所以HTML的DOCTYPE 声明为

```html
<!doctype html>
```

## 什么是 DTD？

DTD 全称： `Document Type Definition (文档类型定义)`，是一组机器可读的规则。

DTD 定义了 XML 或者 HTML 的特定版本中所有允许元素和它们的属性和层级关系的定义。
解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。

---

---
url: /czxBlog/interview-question/3eodsvo4/index.md
---
# 节流与防抖
::: tip 提问

1. 什么是 节流与防抖？
2. 如何实现 节流与防抖？

:::

## 节流与防抖

* 函数防抖： 在事件被触发的 N秒后再执行回调，如果在这N秒内事件又被触发，则重新计时。

* 函数节流：在一个规定的单位时间内，只能有一次触发事件的回调函数执行，如果在单位时间内事件被触发多次，只有一次生效。

## 实现

### 函数防抖

```js
function debounce(fn, wait) {
  let timer = null
  return function (...args) {
    let ctx = this

    if (timer) {
      clearTimeout(timer)
      timer = null
    }
    timer = setTimeout(() => {
      fn.apply(ctx, args)
    }, wait)
  }
}
```

### 函数节流

```js
function throttle(fn, delay) {
  let preTime = Date.now()
  return function (...args) {
    let ctx = this
    let nowTime = Date.now()
    if (nowTime - preTime >= delay) {
      preTime = Date.now()
      return fn.apply(ctx, args)
    }
  }
}
```

---

---
url: /czxBlog/interview-question/3hdch7z2/index.md
---
# git-hook
::: tip 提问

1. 有用过 git hooks吗？
2. 有哪些 git hooks？
3. 如何在前端项目中使用 git hooks？

:::

## git-hook

git-hook 是 git 提供的，能够在git的某些动作发生时触发的钩子，这些钩子可以通过脚本进行自定义。

默认所有的 hook 都在 当前项目根目录的 `.git/hooks` 目录下。

git 提供了 包括客户端的、服务端的各种钩子。常用的有如下：

* pre-commit 在执行 git commit 前 执行
* commit-msg 在执行 git commit 前 执行，晚于 pre-commit, 可以对 commit msg 进行校验
* pre-merge-commit 在执行 git merge 前执行
* pre-rebase-commit 在执行 git rebase 前执行
* pre-push 在执行 git push 前执行

## 在前端项目中使用

在前端项目中可以 安装 `husky`库，以及 `lint-staged` 库，来进行适合于 前端开发人员配置的 git hook配置。

---

---
url: /czxBlog/interview-question/3y2a3ptn/index.md
---
# v-model
[![vue@3](https://img.shields.io/badge/vue-%403-brightgreen)](https://staging-cn.vuejs.org/)

::: tip 提问
v-model 的原理
:::

## v-model

`v-model` 本质是一个语法糖，可以看成是 input + value 的语法糖。

可以通过 model属性的 prop 和 event 属性来进行自定义。

默认的 `v-model` ，会根据标签的不同生成不同的事件和和属性。

* `input[type="text"]` 和 `textarea` 元素 使用 value 属性 和 input 事件
* `checkbox` 和 `radio` 元素 使用 check 属性 和 change 事件
* `select` 元素 使用 value 属性 和 change 事件

```vue
<script>
export default {
  props: ['modelValue'],
  emits: ['update:modelValue'],
}
</script>

<!-- 等价于 -->
<template>
  <input v-model="value" type="text">
</template>

<template>
  <input type="text" :value="modelValue" @input="$emit('update:modelValue', $event.target.value)" />
</template>
```

---

---
url: /czxBlog/interview-question/45rxs5yv/index.md
---
# v-if和v-for优先级
::: tip 提问

1. vue3 中 `v-if` 和 `v-for` 哪个优先级高？
2. 两个同时使用时，该如何优化？

:::

## 优先级

当 `v-if` 和 `v-for` 同时使用时， `v-if` 的优先级总是 高于 `v-for`。

这是 vue3 和 vue2 的其中一个重要的区别点。

在 vue3 中，最好不要同时使用 `v-if` 和 `v-for`。

## 优化

同时使用时，由于优先级的原因，总是先执行判断，确认条件为 true是，才进行渲染和执行循环。

如果需要对 列表中的每一项做条件判断：

* 在 `v-if` 所在的列表项外部包裹 一个 `<template>`， 在 `template` 上定义 `v-for` 和 `key`
* 提前使用 computed 属性 过滤掉不需要的列表项，避免在模板渲染中不必要的判断和渲染

---

---
url: /czxBlog/interview-question/5l8aw7ss/index.md
---
# 快速排序
::: tip 提问

1. 快速排序
2. 实现

:::

## 快速排序

通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

### 描述

* 从数列中挑出一个元素，称为 “基准”（pivot）；
* 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
* 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

## 实现

```js
function quickSort(arr, left, right) {
  if (!Array.isArray(arr) || arr.length <= 1 || left > right)
    return arr
  const len = arr.length
  left = typeof left === 'number' ? left : 0
  right = typeof right === 'number' ? right : len - 1
  const index = partition(arr, left, right)
  quickSort(arr, left, index - 1)
  quickSort(arr, index + 1, right)
  return arr
}

function partition(arr, left, right) {
  const pivot = arr[left]
  while (left < right) {
    while (arr[right] >= pivot && left < right) {
      right--
    }
    arr[left] = arr[right]
    while (arr[left] < pivot && left < right) {
      left++
    }
    arr[right] = arr[left]
  }
  arr[left] = pivot
  return left
}
```

---

---
url: /czxBlog/interview-question/5q9qyu3q/index.md
---
# 指令
[![vue@3](https://img.shields.io/badge/vue-%403-brightgreen)](https://staging-cn.vuejs.org/)

::: tip 提问

1. 什么是指令？
2. 如何自定义指令？

:::

## 指令

指令是用于 封装对于底层DOM元素的操作。

## 自定义指令

使用 `app.directive` 注册全局指令， 或者 组件实例的 `directives` 注册局部指令。

::: warning 提示
自定义指令的钩子， vue3 和 vue2 是完全不同的。
:::

指令提供了七个钩子函数：

* `created` 在绑定元素的 attribute 前
* `beforeMount` 在元素被插入到 DOM 前调用
* `mounted` 在绑定元素的父组件 及他自己的所有子节点都挂载完成后调用
* `beforeUpdate` 绑定元素的父组件更新前调用
* `updated` 在绑定元素的父组件 及他自己的所有子节点都更新后调用
* `beforeUnmount` 绑定元素的父组件卸载前调用
* `unmounted` 绑定元素的父组件卸载后调用

---

---
url: /czxBlog/interview-question/5vkp8w1l/index.md
---
# 垃圾回收机制
::: tip 提问

1. 简单介绍一下 垃圾回收
2. 介绍一些标记清除法
3. V8引擎的垃圾回收机制

:::

## 垃圾回收

垃圾回收是一种自动内存管理机制。

当计算机上的动态内存不再需要时，就应该予以释放，让出内存。
（程勋是运行在内存里的，当声明一个变量，定义一个函数时，都会占用内存。内存的容量是有限的，对于不再使用的变量、函数等，
应该予以释放。）

垃圾回收方法：

1. 引用计数法 （低版本IE采用的方法）
2. 标记-清除法 （现代浏览器使用的方法）

## 标记清除法

标记清除法会 在 垃圾回收期、定期的从 全局对象window开始，找所有从这个对象开始引用的对象，再找这些对象引用的对象，
对这些活着的对象进行标记，这是标记阶段。

在清除阶段，清除那些没有被标记的对象。

## V8引擎的垃圾回收机制

V8的垃圾回收策略基于分代回收机制，该机制又基于 世代假说。该假说有两个特点：

* 大部分新生代倾向于早死；
* 不死的对象，会活得更久。

基于这个理论，现代垃圾回收算法根据对象的存活时间将内存进行了分代，并对不同分代的内存采用不同的高效算法进行垃圾回收。

* 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。
* 老生代：对象的存活时间较长。经历过一次或多次垃圾回收的对象。

新生代被分为`From` 和 `To` 两个空间。 `To`一般是闲置的。当`From` 空间满了的时候，就会执行`Scavenge`算法进行
垃圾回收。当执行垃圾回收算法的时候应用逻辑就会停止，等垃圾回收结束后再继续执行。这个算法分为三步：

1. 检查`From` 空间的存活对象，如果对象存活则判断对象对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。
   如果不满足条件则移动`To`空间。
2. 如果对象不存活，则释放对象的空间。
3. 最后将`From`空间和`To`空间校色进行交换。

新生代对象晋升老生代有两个条件：

1. 判断对象是否已经经过一次 `Scavenge`回收。若经历过，则将对象从`From`空间复制到老生代中；
   若没有经历，则复制到 `To`空间；
2. `To`空间的内存使用占比是否超过限制。当对象从`From`空间复制到`To`空间时，若`To`空间使用超过 25%，
   则对象直接晋升到老生代中。设置25%的原因主要是因为算法结束后，两个空间结束后会交换位置，
   如果`To`空间的内存太小，会影响后续的内存分配。

老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉哪些没有标记的对象。
由于标记清除后会造成很多内存碎片，不便于后面的内存分配。所以为了解决内存碎片的问题引入了标记压缩法。

由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，
但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。
为了解决这个问题，V8引入了增量标记的方法，将一次停顿进行的过程分为了多步，
每次执行完一小步就让运行逻辑执行一会，就这样交替运行。

---

---
url: /czxBlog/interview-question/5yfvcq8k/index.md
---
# CSS浮动
::: tip 提问

* 什么是 CSS 浮动？
* 浮动元素会带来哪些影响？
* 如何清除浮动？ 各自的优点？

:::

## 什么是 CSS 浮动（float）

一开始 引入 float 属性是为了让 开发人员实现简单的布局，在一列文本中浮动的图像，文字环绕在它的左边或者右边。

但 开发人员意识到，任何东西都可以浮动，而不仅仅是图像，所以浮动的使用范围扩大了。

在早期，浮动可以用来实现整个网站的页面布局， 因为浮动使得元素可以横向并列。

## 浮动元素带来哪些影响？

* 包裹性，自适应性；

  * 如果浮动元素父元素宽度为300px，浮动元素不声明宽度，浮动元素子元素是一个200px的图片，则此时浮动元素的宽度表现为包裹，
    宽度就是子元素图片的宽度200px；

  * 如果浮动元素子元素还包括大串文本内容，父元素不足以一行放下所有文本内容，则此时浮动元素则自适应父元素的宽度，宽度为父元素宽度。

* 块级化并格式化上下文

  * 当一个元素的float属性值不为node，则其display计算值就是block或者table。
  * 同时，该浮动元素也会产生一个格式化上下文

* 破坏文档

  浮动元素会让其父元素的高度塌陷。在大多数场景下，这个特性会影响到 正常的布局。

* 没有任何margin合并

## 清除浮动

### clear属性

clear 属性的官方解释是： 元素盒子的边不能和前面的浮动元素相邻。

用法：

```
clear: none | left | right | both;
```

使用：

* 在浮动元素后面插入空白块级元素，并声明 clear属性

  ```html
  <style>
    .float {
      float: left;
    }
    .clear {
      clear: both;
    }
  </style>
  <div>
    <div class="float">float</div>
    <div class="clear"></div>
  </div>
  ```

* 使用伪类元素，并声明clear属性

  ```html
  <style>
    .float {
      float: left;
    }
    .clear::after {
      content: '';
      display: block;
      clear: both;
    }
  </style>
  <div class="clear">
    <div class="float">float</div>
  </div>
  ```

### 创建BFC包裹浮动元素

创建BFC的方式比如：

* 浮动元素父元素设置 float 属性
* 浮动元素父元素设置 overflow 属性，且值为 auto、scroll 或 hidden
* 浮动元素父元素设置 position 属性，且值不为 relative或 static
* 浮动元素父元素设置 display 属性，且值为 inline-block、table-cell 或 table-caption

::: tip 说明
float 属性，一开始的设计目的，仅仅是为 文字和图片服务的， 是为了实现文字的环绕效果。
但是由于当年可用的布局手段很少，想要实现复杂的排版，大都依然`<table>`布局，后来发现给元素浮动后，
可以像垒房子一样，把元素变成一块块砖搭建页面，float也被开发人员变成了一种网页布局手段。

在当下，网页可用的布局方式已经越来越丰富，比如 `flex`布局、`Gird`布局等，都比用float属性进行布局要更加强大。
所以在当下，不推荐继续使用 float进行布局。
:::

---

---
url: /czxBlog/interview-question/5z48vy52/index.md
---
# 选择排序
::: tip 提问

1. 选择排序
2. 实现

:::

## 选择排序

选择排序，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

## 实现

```js
function selectSort(arr) {
  if (!Array.isArray(arr) || arr.length <= 1)
    return arr
  const len = arr.length
  for (let i = 0; i < len - 1; i++) {
    let minIndex = i
    for (let j = i + 1; j < len; j++) {
      if (arr[minIndex] > arr[j]) {
        minIndex = j
      }
    }
    ;[arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
  }
  return arr
}
```

---

---
url: /czxBlog/interview-question/5z5tyxb9/index.md
---
# 浏览器解析过程
::: tip 提问

1. 什么是文档预解析？
2. CSS如何阻塞文档解析
3. 渲染过程遇到 JS文件怎么处理？
4. `<script>` 的 `async` 和 `defer` 属性有什么作用？区别是什么？

:::

## 文档预解析

当执行 Javascript 脚本时，另一个线程会解析剩下的文档，并加载后面需要通过网络加载的资源。
这种方式可以使资源并行加载从而使整体速度更快。

预解析并不改变DOM树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表和图片。

Webkit和Firefox 都做了这个优化。

## CSS如何阻塞文档解析

虽然样式表不改变DOM树，看起来没有必要停下文档的解析等待它们。
但是这里存在一个问题，Javascript 脚本执行时可能在文档的解析过程中请求样式信息，
如果样式还没有加载和解析，脚本将得到错误的值，显然会导致很多问题。

所以如果浏览器尚未完成 CSSOM 的下载和构建，但却在此时运行脚本，那么浏览器将延迟Javascript脚本执行和文档的解析,
直至其完成 CSSOM 的下载和构建。

在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行，最后再继续文档的解析。

## 渲染过程遇到 JS文件

Javascript 的加载、解析和执行会阻塞文档的解析。
在构建 DOM时，HTML解析器若遇到了 Javascript，那么会暂时停止文档的解析，将控制权移交给 Javascript引擎，
等 Javascript引擎运行完毕，浏览器在从中断的地方恢复继续解析文档。

所以为了首屏渲染的速度更快，不应该在首屏就加载JS文档，这也是建议将 script 标签放在 body标签底部的原因。
但在现在，因为 script 标签有了 async 和 defer属性，也不一定需要放在body标签底部了。

## `<script>` 的 `async` 和 `defer` 属性

* `async` 属性 表示 异步执行引入的 javascript 脚本。

  当前 javascript 加载时不会阻塞HTML文档的解析，加载完成后立即执行脚本。
  即加载过程不阻塞HTML文档解析，但是加载完成开始执行仍然会阻塞HTML文档解析。
  多个脚本的执行顺序无法保证。

* `defer` 属性 表示 延迟执行引入的 javascript 脚本。

  当前 javascript 加载时不会阻塞HTML文档的解析，这两个过程是并行的。
  当整个HTML解析完毕后在执行脚本文件。
  并在 DOMContentLoaded事件触发之前完成执行脚本文件，多个脚本按顺序执行。

---

---
url: /czxBlog/interview-question/69vboeiz/index.md
---
# 严格模式
::: tip 提问

1. 什么是严格模式？
2. 严格模式有什么作用？

:::

## 严格模式

严格模式 是 ECMAScript5 添加的 严格运行模式，这种模式使得 javascript 在更严格的条件下运行。

```js
'use strict'
```

### 目的

* 消除 javascript 语法的一些不合理，不严谨之处，减少一些怪异行为；
* 消除代码运行的一些不安全之处，保证代码运行的安全；
* 提高编译效率，增加运行速度；
* 为未来新版本的 javascript做好铺垫。

## 区别

* 禁止使用 with 语句
* 禁止 this 关键字指向全局对象
* 对象不能有重名的属性

---

---
url: /czxBlog/interview-question/6lud0xnd/index.md
---
# watch-watchEffect
::: tip 提问

1. watch 是什么？
2. watchEffect 是什么？
3. watch 和 watchEffect 有什么异同？

:::

## 分析

本题考查对 vue 中 watch 和 watchEffect 的理解，实现原理等。

### 回答策略

1. 两个的定义
2. 使用场景的差异
3. 简述原理

## 回答

1. `watchEffect` 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。
2. `watch` 侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。
3. `watch` 和 `watchEffect` 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：
   1. `watch` 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
   2. `watchEffect`，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。
   3. 从实现上看，`watchEffect(fn, options)` 相当于 `watch(fn, null, options)`

---

---
url: /czxBlog/interview-question/6pdcf9h0/index.md
---
# http协议
::: tip 提问

1. http协议
2. http 状态码
3. https 协议
4. post和get区别？
5. options请求有什么用？

:::

## http协议

http 是超文本传输协议，定义了客户端和服务器之间交换报文的格式和方式。
http使用TCP作为传输层协议，保证了数据传输的可靠性。
http是一个无状态协议，http服务器不会保存关于客户的任何信息。

http报文有两种：

* 请求报文，包括 请求行和 首部行 和实体主体。请求行包括了请求方法和 URL字段等。
* 响应报文，包括 状态行和首部航和实体主体。 状态行包括了 状态码 和 状态信息 等。

## http 状态码

http 状态吗 是由三个十进制的数字组成，可以分为五类。

* `1**` 信息响应，服务器接受到请求，需要请求者继续执行操作
* `2**` 成功响应，操作被成功接收并处理
* `3**` 重定向，需要进一步的操作以完成请求
* `4**` 客户端错误，请求包含语法错误或无法完成请求
* `5**` 服务器错误，服务器在处理请求的过程中发生了错误

常见的状态码

* `200` 请求成功
* `204` 无内容。请求成功，服务器成功处理，但未返回内容
* `304` 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。
* `400` 客户端请求语法错误，服务器无法理解
* `401` 请求要求用户的身份认证
* `403` 服务器拒绝执行请求
* `404` 服务器无法根据客户端的请求找到资源

## HTTPS 协议

https 是超文本传输安全协议，是基于HTTP协议的，使用 TLS/SSL来对数据加密。

## Post 和 Get 的区别

* 从应用场景上来说，GET请求是一个幂等请求，一般GET请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。
  而POST请求不是一个幂等请求，一般用于对服务器资源会产生影响的请求。比如注册用户等操作。

* 由于不同的应用场景，浏览器一般会对 GET请求缓存，但很少对POST请求缓存

* 从发送的报文格式来说，GET请求的报文实体不为空，POST请求的报文实体部分一般为向服务器发送的数据

* GET 请求的请求参数一般是放入到URL中想服务器发送，POST请求一般是在请求实体中发送数据

## OPTIONS 请求的作用

一般是用于客户端 请求服务端返回该资源所支持的所有HTTP请求方法。

该方法会用 `*` 来代替资源名称，向服务器发送OPTIONS请求，测试服务器功能是否可用。

JS的XMLHttpRequest对象进行 CORS 跨域资源共享时，对复杂请求，会使用OPTIONS方法发送嗅探请求，判断是否有对指定资源的访问权限。

---

---
url: /czxBlog/interview-question/6tzvt9fs/index.md
---
# IFC,GFC,FFC
::: tip 提问

1. IFC
2. GFC
3. FFC

:::

::: details 不用看
很少会在面试中问这几个问题就是了。大多数时候 BFC 才是关注点。
这几个有了解就行，实际情况存在感挺低的...
:::

## IFC

`IFC` 即 `(Inline Formatting Context)` 内联格式上下文。

* 行级上下文内部的盒子会在水平方向，一个接一个地放置。
* 当一行不够的时候会自动切换到下一行。
* 行级上下文的高度由内部最高的内联盒子的高度决定。

## GFC

`GFC` 即 `(GrideLayout Formatting Context)` 网格布局格式上下文

* `display` 属性声明为 `gird` 的元素会获得一个独立的渲染区域。
* 元素内的子元素会以网格的形式进行布局，元素称为 网格容器。

## FFC

`FFC` 即 `(Flex Formatting Context)` 弹性格式上下文

* `display` 属性声明为 `flex` 的元素会获得一个弹性盒子。
* 盒子内的子元素称为项目
* 项目以一条主轴方向进行排列
* 每个项目都可根据规则进行弹性缩放。

---

---
url: /czxBlog/interview-question/6x9ta62c/index.md
---
# 路由
[![vue@2](https://img.shields.io/badge/vue-%403-brightgreen)](https://cn.vuejs.org/)

[![vue-router@3](https://img.shields.io/badge/vue--router-%404-brightgreen)](https://v3.router.vuejs.org/zh/)

::: tip 提问

1. `vue-route@4` 和 `vue-router@3`有什么区别？

:::

## 区别

以下是主要变化：

* 使用 `createRouter()` 代替 `new Router()`

*

* 使用 `history` 配置 代替 `mode` 配置

  使用 `createHashHistory()` 代替 `hash` ，使用 `createWebHistory()` 代替 `history`;
  新增了 `createMemoryHistory()` 用于非浏览器环境（如SSR时）。

* 新增 组合式API

  * `useRouter()` 获取路由实例
  * `useRoute()` 获取当前路由地址
  * `onBeforeRouteUpdate()` 导航守卫，在当前位置即将更新时触发
  * `onBeforeRouteLeave()` 导航守卫，在即将离开当前位置时触发

---

---
url: /czxBlog/interview-question/73zv8wla/index.md
---
# pm2
::: tip 提问

1. 什么是 pm2 ?

:::

## pm2

`pm2` 是 node 进程管理工具，可以用它来管理 node应用和运行持久服务。

`pm2` 提供了很多功能，如 性能监控、自动重启、负载均衡等。

---

---
url: /czxBlog/interview-question/7fmfc0hi/index.md
---
# axios
[axios](https://github.com/axios/axios)

::: tip 提问

1. 简单介绍一下 axios
2. axios拦截器是如何实现的？

:::

## axios

axios 是一个基于 promise 的 HTTP库，可以在浏览器和nodejs中使用。

### 特性

* 从浏览器中创建 XMLHttpRequests
* 从 nodejs 创建 http 请求
* 支持 Promise API
* 拦截请求和响应
* 转换请求数据和响应数据
* 取消请求
* 自动转换JSON数据
* 客户端支持防御 XSRF

## 拦截器实现

axios的拦截器分为 请求体拦截器 和 响应体拦截器，

* 请求体拦截器： 在请求发送前，进行拦截，在拦截的回调中可以对请求体数据进行 同步或异步处理，
  并返回一个处理后的 请求体数据 或者 由 promise 包装的 请求体数据。

* 响应体拦截器： 在请求成功收到响应后，进入响应回调前，进行拦截，在拦截的回调中可以响应体数据进行同步或异步处理，
  并返回一个处理后的响应体数据或者 由 promise 包装的响应期数据

两个拦截器的实现思路是相同的。本质上是定义了一个拦截器队列 `handlers`，当使用 `use()` 方法时，

`use()` 方法接受两个参数： `fulfilled` 和 `rejected` 函数，
参数以 `{ fulfilled, rejected }` 的形式推送到 `handlers` 的尾部。

```js
class Interceptor {
  constructor() {
    this.handlers = []
  }

  use(fulfilled, rejected) {
    this.handlers.push({ fulfilled, rejected })
    return this.handlers.length - 1
  }
}
```

在发起请求前，初始化一个 promise, 并直接返回 请求体数据`requestConfig`,
同时以 请求对象实例，初始化一个 promise 队列 `[dispatchRequest, undefined]`

```js
let promise = Promise.resolve(requestConfig)
// dispatchRequest，即一个 实例化后封装的 XMLHttpRequests，返回一个 promise.resolve(response)
const chain = [dispatchRequest, undefined]
```

然后将 请求拦截器 的 `handlers` 按顺序，以 `fulfilled, rejected` 添加到 `chain` 的头部，
将 响应拦截器 的 `handlers` 按顺序，以 `fulfilled, rejected` 添加到 `chain` 的尾部。

最后将得到 chain 数组，作为参数，循环传入 promise.then 的链式调用中,

```js
while (chain.length) {
  promise = promise.then(chain.shift(), chain.shift())
}
```

即， 拦截器的本质上是在 请求实例的 promise 上，在其前后添加 promise实例，然后依次，将上一个promise的结果
作为参数，传入到下一个promise中。 这也是 拦截器 为什么支持 同步函数和异步函数的原因。

---

---
url: /czxBlog/interview-question/7vkp68sw/index.md
---
# HTML语义化的理解
::: tip 提问
说说你对HTML语义化的理解。
:::

HTML标签语义化是指，使用合适的标签做合适的事情，使文档的内容结构清晰，易于理解。

语义化的好处：

* 有利于开发者的维护和理解；
* 有利于机器对文档内容进行正确的解读；
* 有利于搜索引擎爬虫正确的读取内容，优化SEO；
* 有利于即使样式表丢失，网页仍能维持基本的内容供给用户阅读；

---

---
url: /czxBlog/interview-question/7xxy6of5/index.md
---
# 执行上下文和执行栈
::: tip 提问

1. 什么是执行上下文
2. 什么是执行栈

:::

## 执行上下文

执行上下文就是当前 `JavaScript` 代码被解析和执行时所在环境的抽象概念，
`JavaScript` 中运行任何的代码都是在执行上下文中运行。

### 类型

* 全局执行上下文

  最基础的执行上下文，不在任何函数中的代码都位于全局执行上下中。
  全局执行上下文有两个特性：1. 创建一个全局对象，如 window；2. 将this指向这个全局对象。
  一个程序只能有一个全局上下文。

* 函数执行上下文

  每次调用函数时，都会为该函数创建一个新的执行上下文。
  每个函数都拥有自己的执行上下文，但只有被调用时才会被创建。

* eval函数执行上下文

  运行在eval函数里中的代码有自己的执行上下文

### 生命周期

* 创建阶段

  * 创建变量对象
  * 创建作用域链
  * 确定this指向

* 执行阶段

* 回收阶段

## 执行栈

执行栈指 执行上下文栈（Execute Context Stack）。

执行栈 是一个存储函数调用的栈结构，遵循 先进后出 的规则。

* javascript 执行在单线程中，所有代码都是排队执行
* 执行全局代码时，创建全局执行上下文并压入执行栈的顶部
* 每当进入一个函数的执行就创建一个函数执行上下文，并压入执行栈的顶部，当前函数执行完后，当前函数的执行上下文出栈，等待垃圾回收
* 浏览器的JS引擎总是访问执行栈顶部的执行上下文
* 全局执行上下文总是只有一个，它在浏览器关闭时出栈。

---

---
url: /czxBlog/interview-question/7y6d3oqt/index.md
---
# 事件循环
::: tip 提问

1. 什么是事件循环？
2. 什么是宏任务和微任务？
3. 事件循环的执行步骤？

:::

参阅 [Event Loop 浏览器端的事件循环](/article/browser-event-loop)

## 什么是 Event-Loop ？

Event-Loop 是一个执行模型，在 [html5规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops) 中进行了浏览器端的 Event-Loop 的明确定义。

## 宏任务与微任务

javascript 有两种异步任务，分别是`宏任务`和`微任务`

### 宏任务

宏任务，`macro task`，也叫 `tasks`，一些异步任务的回调会依次进入 `macro task queue`，等待后续被调用。

这些异步任务包括：

* setTimeout
* setInterval
* setImmediate (Node独有)
* requestAnimationFrame (浏览器独有)
* I/O
* UI rendering

### 微任务

微任务， `micro task`, 也叫 `jobs`，另一些异步任务的回调会依次进入`micro task queue`，等待后续被调用。

这些异步任务包括：

* process.nextTick(Node独有)
* Promise
* Object.observe
* MutationObserver

## 事件循环 Event Loop

1. 执行全局 `script` 代码，这些代码有一些是同步语句，有一些是异步语句（如： setTimeout）；
2. 全局`script`同步代码执行完毕后，调用栈Stack会清空；
3. 从微任务`micro task queue` 中取出位于队首的任务，放入调用栈Stack中执行，执行完后`micro task queue`长度减一；
4. 继续取出微任务`micro task queue`位于队首的任务，放入调用栈Stack中执行，
   以此类推，直到把`micro task queue`中的所有任务都执行完毕。**注意，如果在执行micro task的过程中，产生了`micro task`那么会加入到队列的末尾，也会在这个周期被调用执行**；
5. `micro task`中的所有无人都执行完毕，此时 `micro task queue` 为空队列，调用栈Stack也为空；
6. 取出宏队列 `macro task queue` 中位于队首的任务，放入Stack中执行；
7. 执行完毕后，调用栈Stack为空；
8. 重复第3-7个步骤；
9. 以此继续循环重复；

::: important 重点

1. 宏任务`marco task` 一次只从队列中取出一个任务执行，执行后就去执行微任务队列中的任务；
2. 微任务队列中所有的任务都会依次取出来执行，直到`micro task queue`为空，
   且当前微任务执行过程中产生新的`micro task`，也会加入到当前`micro task queue`;
3. `UI Rendering`由浏览器自定判断决定执行节点。但是只要执行`UI Rendering`，它的节点是在执行完所有
   `micro task`之后，下一个`macro task`之前，紧跟着执行`UI Rendering`

:::

---

---
url: /czxBlog/interview-question/87vd50ex/index.md
---
# 浏览器存储
::: tip 提问

1. 浏览器有哪些存储方式？
2. 什么是 cookie ？
3. 什么是 本地存储？
4. 什么是 indexedDB ?
5. 它们之间有什么区别？

:::

## 浏览器存储技术

* cookie
* Web Storage
* IndexedDB

## cookie

cookie 指网站为了辨别用户身份而存储在用户本地终端的数据，通常该数据经过加密。

cookie 是服务端生成的，在客户端进行维护和存储，存储在内存或磁盘中。

cookie 可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态维护。比如维护用户登录态等。

cookie 使基于无状态的HTTP协议记录稳定的状态信息成为了可能。

## Web Storage

Web Storage 提供了存储机制。通过该机制，，浏览器可以安全的存储键值对，比使用cookie更加直观。

Web Storage 提供了两种存储机制：

* sessionStorage: 会话级别的存储。浏览器为每一个给定的源维持了一个独立的存储区域，
  该存储区域在页面会话期间可用。
* localStorage: 跟 sessionStorage同样的功能，但提供了长期存储机制，
  即浏览器关闭后重新打开，数据仍然存在。

## IndexedDB

IndexedDB 用于在客户端存储大量的结构化数据。

IndexedDB 是基于 javascript的面向对象数据库，允许存储和检索用键索引的对象。

特点：

* 键值对存储
* 支持事务
* 异步
* 同源限制
* 存储空间大
* 支持二进制存储

## 区别

| 特性         | cookie                             | localStorage             | sessionStorage   | indexedBD                |
| ------------ | ---------------------------------- | ------------------------ | ---------------- | ------------------------ |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间 | 除非被清理，否则一直存在 | 页面被关闭就清理 | 除非被清理，否则一直存在 |
| 数据存储大小 | 4k                                 | 5M                       | 5M               | 没有限制                 |
| 与服务端通信 | 每次都会携带在headers中            | 不参与                   | 不参与           | 不参与                   |

---

---
url: /czxBlog/interview-question/8dyy8lg6/index.md
---
# HTML5新特性
::: tip 提问

1. HTML5有哪些新特性？
2. 如何处理HTML5新标签的浏览器兼容?
   :::

## 新特性

* 媒介 video和 audio 元素
* 绘画 canvas
* 本地离线存储 localStorage、sessionStorage
* 语义化标签：article,footer,header,nav,section,aside,表单控件等
* Web Worker
* Web Socket

等

## HTML5 新标签的浏览器兼容方案

在 IE 6/7/8 中，支持通过 `document.createElement` 方法产生标签，可以利用这个特性
让这些浏览器支持 hTML5标签，同时还需要为标签添加默认样式。

---

---
url: /czxBlog/interview-question/8hujc044/index.md
---
# jenkins
::: tip 提问
简单介绍一下 jenkins
:::

jenkins 是一个基于java开发的 持续集成工具。提供了大量的插件来支持软件的构建、部署、自动化等。

jenkins 提供了多种方式用于 CI\&CD 。

其中比较常用的是 流水线 pipeline。

pipeline将软件的版本迭代时所需要经历的各个阶段，抽象为一个个 stage， 而每个stag有多个step步骤。
软件变更，通过启动流水线，自动按顺序执行每个stage。

stage 比如，build、test、deploy等。

step 比如 一段shell命令等。

---

---
url: /czxBlog/interview-question/94077huq/index.md
---
# 像素
::: tip 提问
设备像素，css像素， dpr， ppi
:::

* 设备像素： 物理像素。 设备像素决定了设备的分辨率。

* css像素： css像素是相对于设备像素的，当用户为进行缩放操作，那么css像素跟设备像素重叠。
  如果进行了缩放操作，那么 css像素会等比例于设备像素。
  css像素也被称为 设备独立像素。

* dpr：设备像素和设备独立像素的比值。

* ppi: 每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。

---

---
url: /czxBlog/interview-question/9m3js49s/index.md
---
# 数据类型转换
::: tip 提问

1. 显式类型转换 （强制类型转换）
2. 隐式类型转换

:::

## 显示类型转换

### 转换为 String 类型

* `toString` 方法，除了 null、undefined，其他数据类型几乎都有 `toString`方法，
  该方法不转换值本身，而是将返回转换后的结果

* `String()`函数

### 转换为 Number 类型

* `Number()` 函数
* `parseInt` 、`parseFloat()` 函数

### 转换为 Boolean 类型

* `Boolean()` 函数

## 隐式类型转换

* 算术运算符 `- * /` 跟非Number类型进行运算时，会将这些值转换为 Number类型后进行运算
* 运算符 `+`，当 左右两边均非String类型时，会转换为 Number类型进行运算
* 运算符 `+`，当 左右两边有一个或两个String类型时，非String类型会转换为String类型后进行运算
* 条件运算时，空字符串、null、undefined、+0， -0 和 NaN 被转为布尔型 false，其他都是true

---

---
url: /czxBlog/interview-question/9mbb0ngo/index.md
---
# 浏览器渲染过程
::: tip 提问

1. 如果优化关键渲染路径？
2. 渲染页面时常会出现哪些不好的现象？

:::

## 渲染页面常见问题

* 无样式内容闪烁

  由于浏览器的渲染机制，在CSS加载之前，先呈现了HTML，就会导致展示出无样式的内容，然后样式突然呈现的现象。
  这个问题出现的原因是由于CSS加载时间过长，或者CSS被放在了文档的底部。

* 白屏

  有些浏览器渲染机制要先构建DOM树和 CSSOM树，构建完成后在进行渲染，如果CSS部分放在HTML尾部，由于CSS加载未完成，
  浏览器迟迟未渲染，从而导致白屏；也可能是把JS文件放在头部，脚本的加载会阻塞后面文档的内容解析，从而页面迟迟未
  渲染出来，导致了白屏问题。

## 优化关键渲染路径

优化关键渲染路径，首要是尽快完成首次渲染。要达到这个目的，就需要尽快让 文档解析完成并渲染。

所以需要最大限度的减小以下三种可变因素：

1. 关键资源数量
2. 关键路径长度
3. 关键字节数量

* 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越少，对CPU以及其他资源的占用也越少。
* 关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响，某些资源只能在上一个资源处理完毕后才能开始下载，
  并且资源越大，下载所需要的往返次数就越多。
* 浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。
  要减少字节数，可以减少资源数（将它们删除或者设为非关键资源），此外还需要压缩和优化各项资源，确保最大限度减少
  传输大小。

优化关键路径的常规步骤如下：

* 对关键路径进行分析和特性描述：资源数、字节数、长度。
* 最大限度减少关键资源的数量：删除、延迟下载，标记为异步等。
* 优化关键字节数以缩短下载时间（往返次数）
* 优化其余关键资源的加载顺序。

---

---
url: /czxBlog/interview-question/9zwkibho/index.md
---
# 路由
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

[![vue-router@3](https://img.shields.io/badge/vue--router-%403-brightgreen)](https://v3.router.vuejs.org/zh/)

::: tip

1. 路由的历史模式有哪些？有什么不同？
2. 路由的导航守卫
3. 导航守卫的解析流程（执行顺序）

:::

## 历史模式

1. Hash 模式

   使用 URL 的 `hash` 来模拟一个完整的 URL， 当 `hash` 改变时，页面不会重新加载

2. History 模式

   使用 `history.pushState` API 来完成 URL 而无需页面重新加载。

   History 模式需要后端服务器进行配置以提供支持。通过特定的规则，将路径重定向到 一个特定的页面路径。

## 导航守卫

路由的导航守卫 主要是用来 通过跳转和取消的方式守卫导航。

导航守卫 包括：

* `beforeEach`

  全局前置守卫。 在导航被确认之前调用。

* `beforeResolve`

  全局解析守卫。 在导航被确认之前，同时所有组件内守卫和异步路由组件被解析之后 调用。

* `afterEach`

  全局后置钩子. 在导航被确认之后调用。

* 路由独享守卫

  在路由配置上定义 `beforeEnter`。 在进入当前路由之前被调用。

* 组件内守卫

  * `beforeRouteEnter` 渲染该组件的对应路由被 confirm 前调用
  * `beforeRouteUpdate` 当前路由改变，但是该组件被复用时调用
  * `beforeRouteLeave` 导航离开该组件的对应路由时调用

## 导航守卫的解析流程

1. 导航被触发。
2. 在失活的组件里调用 beforeRouteLeave 守卫。
3. 调用全局的 beforeEach 守卫。
4. 在重用的组件里调用 beforeRouteUpdate 守卫。
5. 在路由配置里调用 beforeEnter。
6. 解析异步路由组件。
7. 在被激活的组件里调用 beforeRouteEnter。
8. 调用全局的 beforeResolve 守卫。
9. 导航被确认。
10. 调用全局的 afterEach 钩子。
11. 触发 DOM 更新。
12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

---

---
url: /czxBlog/interview-question/a6txp0c3/index.md
---
# TCP协议
::: tip 提问

1. TCP协议
2. 三次握手

:::

## TCP协议

TCP协议是面向链接的，提供可靠数据传输服务的传输层协议

### 特性

* 在通信前，通信双方需要通过三次握手建立链接，并在端系统中维护双方链接的状态信息
* 通过序号、确认好、定时重传、检验和等机制，提供可靠的数据传输服务
* 点对点服务。提供的是 单个发送方和单个接收方之间的连接
* 全双工服务。连接成功的双方都能够向对方发送和接收数据
* 拥塞控制机制。在网络用色是会控制发送数据的速率，减少数据包丢失概率和减轻网络拥塞程度
* 流量控制机制。保证通信双方的发送和接收速率相同。

### 三次握手过程

1. 第一次握手，客户端向服务端发送一个`SYN`链接请求报文段。
2. 第二次握手，服务端接收到客户端发送的`SYN`链接请求报文段后，会为该连接分配缓存和变量，
   然后向客户端发送 `SYN ACK` 报文段。
3. 第三次握手，客户端接收到服务端的肯定应答后，会为这次TCP连接分配缓存和变量，
   同时向服务器发送一个对服务端的报文段的确认。

::: info 说明
简单来说，

* 第一次握手就是 客户端对服务端说：你好，我是 A。
* 第二次握手就是 服务端对客户端说：你好，我是 B。
* 第三次握手就是 客户端对服务端说：那现在我们认识了。

:::

### 四次挥手过程

1. 第一次挥手，客户端认为没有数据要再发送给服务端，向服务端发送一个 `FIN` 报文段，申请断开客户端到服务端的连接状态。
2. 第二次挥手，服务端收到客户端断开连接的请求后，向客户端发送一个确认报文段，
   表示已经接收到了客户端释放连接的请求，以后不再接收来自客户端的数据。
3. 第三次挥手，服务器发送完所有数据后，向客户端发送 `FIN` 报文段，申请断开服务器到客户端的连接状态。
4. 第四次挥手，客户端收到服务器的 `FIN` 后，像服务器发送一个确认应答，等待一段时间后，确认服务器没有重发请求。
   服务器收到客户端的确认应答。 双方没有重发请求，那么TCP连接就完成了释放。

::: info 说明
简单来说，

* 第一次挥手： 客户端对服务端说：没啥事，我准备撤了
* 第二次挥手： 服务端对客户端说：好的，知道了
* 第三次挥手： 服务端对客户端说：那我也准备撤了
* 第四次挥手： 客户端对服务端说：那一起撤吧

:::

---

---
url: /czxBlog/interview-question/a895fu8f/index.md
---
# promise
::: tip 提问

1. 简单介绍一下 promise
2. 说一下 Promise A+ 规范

:::

参阅 [详解promise](/article/q40nq4hv)

## promise

promise 是一个 异步编程解决方案，提供了一种 链式调用的方法，以一种更为扁平的方式处理复杂异步编程场景。
在早期使用 异步回调函数时，经常容易出现 在异步回调中写异步回调的回调嵌套地域，导致代码拥冗难以阅读。

`Promise`是一个构造函数，用于创建一个新的 Promise 对象，该构造函数主要用于包装还没添加 promise支持的函数。

### 状态

promise创建后，必然出于一下三种状态之一：

* `pending` 待定状态
* `fulfilled` 操作成功
* `rejected` 操作失败

当状态从 `pending` 更新到另外一种状态后，就再也不能变更为其他状态。

### 实例方法

* `.then()` 接受两个函数参数 ，状态从 pending 更新到另一个状态时触发
* `.cache()` 接受一个函数参数，状态从 pending 更新到 rejected 时触发
* `.finally()` 只要状态发生变化，所有 then() 和 catch() 执行完成后，最后执行 finally

### 静态方法

* `resolve(value)` 返回一个 状态为给定的value决定的 promise实例
* `reject(reason)` 返回一个状态为失败的 promise 实例
* `all()` 传入一组promise实例并返回一个新的promise实例，当传入的promises状态均更新为成功时触发
  返回实例的状态更新为成功，否则更新为失败
* `allSettled()` 传入一组promise实例并返回一个新的promise实例，当传入的promises状态均更新到最终状态，
  触发返回实例promise的状态更新
* `race()` 传入一组promise实例并返回一个新的promise实例，只要传入的promises有一个状态更新的熬最终状态，
  触发返回实例promise的状态更新

## Promise A+ 规范

Promise A+ 规范 是 一个开放、健全且通用的 Javascript Promise标准。

规范不设计如何创建、解决和拒绝promise，而是专注于提供一个通用的then方法。

---

---
url: /czxBlog/interview-question/aalt1m8q/index.md
---
# 闭包
::: tip 提问

1. 什么是闭包？
2. 闭包有什么作用？

:::

## 闭包

闭包是指有权访问另一个函数作用域中变量的函数。

创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

闭包的本质就是作用域链的一个特殊应用，只要了解作用域链的创建过程，就能够理解闭包的实现原理。

## 作用

* 闭包可以使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，
  从而在外部访问到函数内部的变量，可以用这种方法来创建私有变量。

* 闭包可以使已经结束运行的函数上下文中的半两对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，
  所以这个变量对象不会被回收。

---

---
url: /czxBlog/interview-question/alfe37yd/index.md
---
# 希尔排序
::: tip 提问

1. 希尔排序
2. 实现

:::

## 希尔排序

把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元 素越来越多，当增量减至1时，整个数组恰被分成一组，算法便终止。

## 实现

```js
function hillSort(arr) {
  if (!Array.isArray(arr) || arr.length <= 1)
    return arr
  const len = arr.length
  if (!Array.isArray(arr) || len <= 1)
    return
  for (let gap = Number.parseInt(len >> 1); gap >= 1; gap = Number.parseInt(gap >> 1)) {
    for (let i = gap; i < len; i++) {
      let temp = arr[i]
      let j = i

      while (j - gap >= 0 && arr[j - gap] > temp) {
        arr[j] = arr[j - gap]
        j -= gap
      }
      arr[j] = temp
    }
  }
  return arr
}
```

---

---
url: /czxBlog/interview-question/at4kz32a/index.md
---
# 插入排序
::: tip 提问

1. 插入排序
2. 实现

:::

## 插入排序

一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

### 过程

1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5。

## 实现

```js
function insertSort(arr) {
  if (!Array.isArray(arr) || arr.length <= 1)
    return arr
  const len = arr.length
  for (let i = 1; i < len; i++) {
    let tmp = arr[i]
    let j = i
    while (j - 1 >= 0 && arr[j - 1] > tmp) {
      arr[j] = arr[j - 1]
      j--
    }
    arr[j] = tmp
  }
  return arr
}
```

---

---
url: /czxBlog/interview-question/bnjq8wxb/index.md
---
# 外边距合并
::: tip 提问

* 什么是外边距合并？
* 什么情况下会发生外边距合并？

:::

## 外边距合并

块元素的上外边距和下外边距有时候会发生合并，其大小取其中绝对值最大的值，这种行为叫做外边距合并。

## 发生外边距合并的场景

**浮动元素** 和 **绝对定位元素** 的外边距不会发生合并。这是因为触发了 **块格式化上下文** 。

1. 相邻元素之间的外边距会发生合并（如果后一个元素需要清除前面的浮动，则不一定发生合并）。
2. 父元素与其第一个子元素之间不存在边框、内边距、行内内容、没有创建 **块格式化上下文**、没有清除浮动；或者父元素与其最后一个子元素之间不存在边框、内边距、行内内容、heigh、min-height、max-height，那么子元素的外边距会溢出到父元素外面。
3. 如果一个块级元素不包含任何内容，并且在不存在边框、内边距、行内内容、heigh、min-height，则该元素的上下外边距会发生合并。

三种情况的外边距合并是可以组合产生更加复杂的外边距合并情况的。

*如果外边距合并的值都是负值，则合并的值为最小的外边距的值。*

*如果发生外边距合并的值包含负值，则合并后的值为最大的正外边距与最小的负外边距之和。*

---

---
url: /czxBlog/interview-question/bu32tzua/index.md
---
# 元素的分类
::: tip 提问

1. 行内元素和块级元素
2. HTML5元素的分类
3. 空元素的定义

:::

## 行内元素和块级元素

在 HTML4 中，元素被分为两大类， inline（内联元素）和 block（块级元素）

1. 内联元素

   内联元素 只占据它对应的标签的边框所包含的空间。

   常见的内联元素有： `<a>`, `<span>`, `<img>`, `<button>`, `<input>`, `strong`, `<label>`,
   `<select>`, `<textarea>` 等

2. 块级元素

   块级元素占据其父元素（容器）的整个宽度，创建了一个`块`。

   常见的块级元素有： `<div>`, `<ul>`, `<ol>`, `<li>`, `<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`,
   `<h6>`, `<p>` 等

## HTML5元素的分类

由于 CSS 属性 `display` 可以直接声明 元素是 `block` 或 `inline` 或`inline-block` 等，
所以简单的将 元素分类为 内联元素和块级元素已不再符合需求。

在HTML5中，元素主要分为 7 类， 并且每个元素可以归属于一个或多个类型：

* Metadata 元数据元素

  `<base>`, `<link>`, `<link>`, `<meta>`, `<script>`, `<noscript>`, `<style>`, `<title>`

* Flow 流式元素

  `<a>`, `<abbr>`, `<address>`, `<article>`, `<aside>`, `<audio>`, `<br>`, `<button>`,
  `<blockquote>`, `<canvas>`, `<div>`, `<footer>`, `<form>`, `<h1>`, `<h2>`, `<h3>`,
  `<h4>`, `<h5>`,`<h6>`, `<p>` 等

* Sectioning 章节元素

  `<article>`, `<aside>`, `<nav>`, `<section>` 等

* Heading 标题元素

  `<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`,`<h6>`, `<hgroup>`等

* Phrasing 短语元素

  `<abbr>`, `<br>`, `<button>`, `<canvas>`, `<code>`, `<img>`, `<i>`, `<strong>`, `<iframe>`,
  `<input>`, `<small>`, `<select>` 等

* Embedded 嵌入元素

  `<audio>`, `<video>`, `<canvas>`, `<iframe>`, `<img>`, `<embed>`, `<svg>` 等

* Interactive 交互元素

  `<a>`, `<button>`, `<details>`, `<embed>`, `<iframe>`, `<label>`, `<textarea>`, `<select>`

## 空元素的定义

标签内没有内容的 HTML 标签被称为空元素。

空元素是在开始标签中关闭的，也称 自闭合元素。

`<br>`, `<hr>`, `<img>`, `<input>`, `<link>`, `<meta>`

---

---
url: /czxBlog/interview-question/bvx4d2u5/index.md
---
# css三角形原理
::: tip 提问

1. 如何用css画一个 三角形
2. 原理是什么？

:::

## 原理

由于 CSS 对于元素的边框，其相邻的边框的连接处，采用的是均分的处理方式，我们可以利用这个特性，
使用元素的边框，画一个三角形。

* 将元素的display属性设置为 block 或 inline-block；
* 宽高均设置为0；
* 设置border-width为大于 1px 的值，border-style为 solid；
* 设置 border-color， 仅保留一条边的颜色，其他边的颜色为透明

```css
.demo {
  display: block;
  width: 0;
  height: 0;
  border-width: 30px;
  border-style: solid;
  border-color: transparent transparent blue transparent;
}
```

:::: demo title="CSS三角形"
::: code-tabs

@tab HTML

```html
<div class="triangle-demo"></div>
```

@tab CSS

```css
.triangle-demo {
  display: block;
  width: 0;
  height: 0;
  border-width: 30px;
  border-style: solid;
  border-color: transparent transparent cyan transparent;
}
```

:::
::::

---

---
url: /czxBlog/interview-question/bww4boap/index.md
---
# 事件
::: tip 提问

1. 什么是事件？
2. 标准事件模型
3. 什么是事件委托？

:::

## 事件

事件是 在浏览器窗口中被触发并且通常被绑定在窗口内部的特定部分。
可能是一个元素、一系列元素、被加载到这个窗口的HTML代码，或者整个浏览器窗口。

比如：

* 用户对页面进行的操作，如 点击鼠标或悬停光标、按下键盘某个按键、调整浏览器的大小
* 网页停止加载
* 提交表达
* 发生错误

## 标准事件模型

DOM标准事件模型指的是 DOM2事件模型。

在标准事件模型中，一次事件的发生有三个阶段：

1. 事件捕获阶段。事件从window对象自上而下向目标节点传播的阶段；
2. 目标阶段。 真正的目标节点正在处理事件的阶段；
3. 冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。

## 事件委托

事件委托本质上是利用浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，
并且父节点可以通过事件对象获取到目标节点，因此可以吧子节点的监听函数定义在父节点上，
由父节点的监听函数统一处理多个子元素的事件，这种方式称为 事件代理 或者 事件委托。

使用事件委托，就可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。
并且使用事件委托，可以实现事件的动态绑定，比如新增了一个子节点，就不需要单独地为它添加一个监听事件，
节点发生的事件会交给父元素中的监听函数来处理。

---

---
url: /czxBlog/interview-question/chnx193c/index.md
---
# new操作符
::: tip 提问

1. `new` 操作符 具体做了什么？
2. 如果实现 `new`？

:::

## new 操作符

1. 首先创建了一个空对象
2. 设置原型，将对象的原型指向函数的原型
3. 让函数的 `this` 指向这个对象的原型，并执行构造函数的代码
4. 判断函数的返回值类型，如果是值类型，返回创建的对象，如果是引用类型，返回这个引用类型的对象。

## 实现

```js
function newFactory(constructor, ...args) {
  if (typeof constructor !== 'function') {
    throw new TypeError('constructor must be a function')
  }

  const object = Object.create(constructor.prototype)
  const result = constructor.apply(object, args)

  if (result && (typeof result === 'object' || typeof result === 'function')) {
    return result
  }
  else {
    return object
  }
}
```

---

---
url: /czxBlog/interview-question/cipqku16/index.md
---
# 排序算法总结
| 排序方法 | 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度 （最好） |  空间复杂度   | 稳定性 |
| :------: | :----------------: | :----------------: | :-----------------: | :-----------: | :----: |
| 冒泡排序 |     *O(n^2^)*      |     *O(n^2^)*      |       *O(n)*        |    *O(1)*     |  稳定  |
| 选择排序 |     *O(n^2^)*      |     *O(n^2^)*      |      *O(n^2^)*      |    *O(1)*     | 不稳定 |
| 插入排序 |     *O(n^2^)*      |     *O(n^2^)*      |       *O(n)*        |    *O(1)*     |  稳定  |
| 希尔排序 |    *O(n^1.3^)*     |     *O(n^2^)*      |       *O(n)*        |    *O(1)*     | 不稳定 |
| 归并排序 |   *O(nlog~2~n)*    |   *O(nlog~2~n)*    |    *O(nlog~2~n)*    |    *O(1)*     |  稳定  |
| 快速排序 |   *O(nlog~2~n)*    |     *O(n^2^)*      |    *O(nlog~2~n)*    | *O(nlog~2~n)* | 不稳定 |

---

---
url: /czxBlog/interview-question/cl8r03ok/index.md
---
# CSP内容安全策略
::: tip 提问
什么是 CSP？
:::

CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。

我们只需要配置规则，如何拦截由浏览器自己来实现。

通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式

```html
<meta http-equiv="Content-Security-Policy" />
```

---

---
url: /czxBlog/interview-question/dmtwgwoc/index.md
---
# 原型和原型链
::: tip 提问

1. 什么是原型
2. 什么是原型链
3. 原型链与继承

:::

## 原型

Javascript 是一种基于原型的语言，同时，javascript只有一种结构：对象。
每个实例对象都有一个私有属性 `__proto__`指向它的构造函数的原型对象`prototype`

## 原型链

原型对象`prototype`也有自己的原型对象`__proto__`，层层向上，直到有一个的原型对象为null。根据定义，null没有原型，并作为这个原型链的最后一个环节。

## 原型链与继承

`javascript` 对象是动态的属性"包裹"（指自身的属性）。同时，对象还有一个指向一个原型对象的链。
当访问一个对象的属性时，不仅会在该对象上查找，也会在该对象的原型上查找，进而在该对象的原型的原型上查找，
依次层层向上查找，直到找到匹配的属性，或者到达原型链的末尾。

当继承的函数被调用时，`this`指向的是当前继承的对象，而不是继承的函数所在的原型对象。

## 获取原型的方法

* `someObj.__proto__`
* `someObj.constructor.prototype`
* `Object.getPrototypeOf(someObj)`

---

---
url: /czxBlog/interview-question/dr6sis13/index.md
---
# 浏览器内核
::: tip 提问

1. 说说你对浏览器内核的理解。
2. 常见的浏览器内核有哪些？
3. 浏览器内核的比较。

:::

## 浏览器内核

浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是JS引擎。

* 渲染引擎 的职责是渲染，即在浏览器窗口中显示所请求的内容。
* JS引擎：解析和执行 javascript 来实现网页的动态效果。

早期时候渲染引擎和JS引擎并没有明确的区分，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

## 常见的浏览器内核

| 内核           | 浏览器        | 描述                                                                |
| -------------- | ------------- | ------------------------------------------------------------------- |
| Trident        | IE            | IE浏览器内核                                                        |
| Chromium/Blink | Chrome、Opera | Chrome浏览器内核，以前是 WebKit内核，现在是 Blink内核（Webkit分支） |
| Gecko          | Firefox       | Firefox 浏览器的内核                                                |
| Webkit         | Safari、Opera | Webkit内核                                                          |
| Presto         | Opera         | Opera浏览器使用过的内核，但Opera已转向 Webkit/Blink                 |

## 浏览器内核比较

* Trident内核： IE系列浏览器所用的内核，但由于微软长期没有更新 Trident内核，导致与W3C标准脱节，且存在大量bug等
  安全问题没有解决，导致很多用户转向其他浏览器。

* Gecko内核：Firefox使用的内核，优点是功能强大、丰富，可以支持很多复杂的网页效果和浏览器扩展接口，
  但是代价是需要消耗很多资源，比如内存资源等。

* Presto内核：Opera曾经采用的内核，被称为公认的浏览网页速度最快的内核。但缺点是为了达到很快的速度，
  而丢掉了一部分网页兼容性。

* WebKit内核：Safari采用的内核，优点是网页浏览速度较快，虽然不及Presto，但快于 Trident和Gecko，
  缺点是对网页代码的容错性不高，也就是对网页代码的兼容性较低。

* Blink内核：Chrome采用的内核，是从 Webkit上独立出来的分支，由谷歌和Opera共同研发。

---

---
url: /czxBlog/interview-question/dyfx0oo9/index.md
---
# 函数柯里化
## 函数柯里化

函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。

函数柯里化的目的是参数复用。本质上是降低通用性，提高适用性。

实现：

```js
function curry(fn, ...args) {
  return fn.length < args.length ? fn(...args) : curry.bind(null, fn, ...args)
}
```

---

---
url: /czxBlog/interview-question/e2tpl1sq/index.md
---
# webpack
::: tip 提问

1. 对webpack的了解
2. webpack的工作原理
3. loader和plugin？ 有什么区别？
4. 做过哪些webpack优化？

:::

::: info 说明
一般来说， 面试中问及的webpack相关知识，如果是面向招写业务代码的，
能了解个webpack的原理和能做什么，就差不多够了。如果是面向招做基础设施的，
那么还需要了解 loader、 plugin等相关内容，以及如何写一个 loader/plugin，
还有就是如何做webpack优化这些，但做招基础设施又不仅仅只考擦webpack，更多还是对构建工具的整体理解。
:::

## webpack

webpack是一个用于 现代javascript应用程序的静态模块打包工具。

## 工作原理

1. 读取 `webpack` 的配置参数；
2. 启动 `webpack` , 创建 `compiler` 对象，开始解析项目；
3. 从入口文件 `entry` 开始解析，并找到其导入的**依赖模块**，递归遍历分析，形成**依赖关系树**；
4. 对不同的文件类型资源的依赖模块文件，使用对应的 `Loader` 进行转换，最终转为 webpack的有效模块；
5. 在编译过程中， `webpack` 通过 发布订阅模式，向外抛出一些 `hooks` ，`webpack` 的 `Plugin` 通过监听各个 `hooks` ，
   执行插件任务，扩展 `webpack` 的功能，干预输出结果。
6. 根据 输出配置 `output` ，将打包构建好的资源文件 输出。

## loader

将其他类型的资源文件转换为 webpack能够处理的有效模块。

## plugin

plugin是webpack的核心功能，其目的是在于解决loader无法解决的其他事上。

plugin可以在webpack访问到webpack的整个生命周期，并且可以访问到compile对象，以及当前编译过程对象 compilation, 这使得plugin拥有非常强大的能力。

## loader和plugin的区别

loader仅能对其关联的模块类型进行解析转换，不能访问到webpack的整个生命周期

plugin是对webpack的扩展，可以访问到webpack整个生命周期。

## webpack 优化

以下内容是针对 webpack@5 的优化方向建议：

### 构建流程分析

在进行优化前，首先要搞清楚有哪些地方出现了痛点，需要进行优化。

* 编译速度分析

  借助 `speed-measure-webpack-plugin` 插件，可以帮助我们获取插件、loader的耗时。
  消耗时间比较长的，认为可以优化的，则放到优化计划中。

* 打包体积分析

  借助 `webpack-bundle-analyzer` 插件，可以帮助我们获取打包后生成的bundle的体积中，各个模块的位置、体积等信息。

### 编译速度优化

1. 配置缓存方案。

   在webpack的配置文件中 声明 配置： `{ cache: { type: 'filesystem } }`,来启用对模块和chunk的持久缓存。
   可以大幅度优化 二次启动构建速度、打包速度等。

2. 对使用的 loader，根据其作用，指定 include 或者 exclude，减少 loader的应用范围。

3. 管理资源

   使用 webpack5 内置的 `asset/resource` 代替 `assets loader`(如， url-loader、file-loader、raw-loader)。

4. 多进程打包编译

   使用 `thread-loader`将耗时长的loader进行包装，放到其他的线程中进行处理。

### 打包体积优化

重复多次出现的模块，可以抽到共享chunk中，非首屏加载必须的模块，可以抽到异步chunk中。

（还有对各种资源进行压缩等）

---

---
url: /czxBlog/interview-question/e3adhfty/index.md
---
# nextTick
::: tip 提问

1. nextTick 是什么？
2. nextTick 的实现原理？
3. nextTick 的作用？

:::

## 分析

此题考查 对 `vue` 异步更新队列的理解。

## 回答

> **官方定义：**
>
> 当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。
>
> nextTick() 可以在状态改变后立即使用，以等待 DOM 更新完成。你可以传递一个回调函数作为参数，或者 await 返回的 Promise。

1. nextTick是Vue提供的一个全局API，由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法。

2. 当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，
   直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。
   本质上， nextTick 会被添加到 队列的最后再执行，而如果队列为空，则 nextTick 就是一个 普通的 promise 。

3. 当需要在数据发生变更后，立即获取更新后的dom状态、修改dom时，可以使用 nextTick() 方法。

---

---
url: /czxBlog/interview-question/e78132ku/index.md
---
# 冒泡排序
::: tip 提问

1. 冒泡排序
2. 实现

:::

## 冒泡排序

冒泡排序是指， 对相邻的元素进行两两比较，顺序相反则进行交换。 这样每次都会将最小或者最大的元素 "浮" 到顶端，最终达到完全有序。

冒泡排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。

### 优化

* 外层循环优化，记录当前循环中是否发生了交换，如果没有发生交换，则说明该序列已经为有序序列了。 因此我们不需要再执行之后的外层循环，此时可以直接结束。
* 内层循环的优化，记录当前循环中最后一次元素交换的位置，该位置以后的序列都是已排好的序列，因此下 一轮循环中无需再去比较。

优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。

## 实现

```js
function bubbleSort(arr) {
  if (!Array.isArray(arr) || arr.length <= 1)
    return arr
  let lastIndex = arr.length - 1
  while (lastIndex > 0) {
    let flag = true
    const k = lastIndex
    for (let j = 0; j < k; j++) {
      if (arr[j] > arr[j + 1]) {
        flag = false
        lastIndex = j
        ;[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
      }
    }
    if (flag)
      break
  }
  return arr
}
```

---

---
url: /czxBlog/interview-question/eftuz9uz/index.md
---
# SQL注入攻击
::: tip 提问

1. 什么是SQL注入攻击

:::

SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，
服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，
破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。

---

---
url: /czxBlog/interview-question/enq4k5mb/index.md
---
# 设计模式
::: tip 提问

1. javascript 有哪些常用的设计模式？
2. 简单说一下你知道的设计模式

:::

## 常用的设计模式如

* 单例模式
* 工厂模式
* 策略模式
* 代理模式
* 中介者模式
* 装饰者模式
* 观察者模式

## 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

实现方法是，先判断实例是否存在，如果不存在就创建后返回，如果存在就直接返回。

## 工厂模式

工厂模式是一种创建型的模式，主要是 提供一个通用的接口来创建对象。

适用于 当对象或组件设置涉及搞复杂性，或者需要根据所在的不同环境生层对象的不同实例，
或者处理很多共享相同属性的小型对象或组件 等场景。

## 策略模式

将方法的实现和方法的调用分离开来，其中方法的实现是可互相替换的，可以通过相同的方式进行调用。

## 代理模式

为一个对象提供一个代用品或占位符，以便控制对它的访问。

比如说常见的事件代理。

## 中介者模式

多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。

## 装饰者模式

在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。

适用于：
原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；
函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。

## 观察者模式

一个被称作被观察者的对象，维护一组被称为观察者的对象，这些对象依赖于被观察者，被观察者自动将自身的状态的任何变化通知给观察者。

当一个被观察者需要将一些变化通知给观察者的时候，它将采用广播的方式，这条广播可能包含特定于这条通知的一些数据。

当特定的观察者不再需要接受来自于它所注册的被观察者的通知的时候，被观察者可以将其从所维护的组中删除。

---

---
url: /czxBlog/interview-question/f4snyn2e/index.md
---
# 重绘与回流
::: tip 提问

1. 什么是重绘和回流
2. 哪些属性会引起重绘和回流
3. 如何减少回流

:::

## 重绘和回流

* 重绘

  当渲染树中的一些元素需要更新属性，而这些属性只影响元素的外观、风格，而不会影响布局的操作，称之为重绘

* 回流

  当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，
  称之为回流。

回流必定会发生重绘，重绘不一定会引起回流。

回流所需的成本比重绘高得多，改变父节点里的子节点可能会导致父节点的一系列回流。

### 常见引起重绘的属性

`border-styl` , `border-radius` , `border-color` , `color`,
, `background` , `background-image` , `background-position` , `background-repeat` ,
, `visibility` , `outline` , `box-shadow`, `text-decoration` 等

### 常见引起回流的方式

* 页面首次渲染

* 浏览器窗口大小发生改变

* 元素尺寸或位置发生改变

* 元素内容发生变化

* 元素字体大小变化

* 添加或删除可见的DOM元素

* 激活 CSS 伪类

* 查询某些属性或者调用某些方法

* `width`, `height`, `margin`, `padding`, `display`, `border`, `position`, `overflow`,

* `clientWidth`, `clientHeight`, `clientTop`, `clientLeft`,

* `offsetWidth`, `offsetHeight`,`offsetLeft`, `offsetTop`,

* `scrollWidth`, `scrollHeight`, `scrollTop`, `scrollLeft`,

* `scrollIntoView()`, `scrollIntoViewIfNeeded()`,

* `getComputedStyle()`

* `getBoundingClientRect()`

* `scrollTo()`

## 减少回流的方式

* 避免使用 table 布局，因为可能一个很小的改变，都会造成整个 table 的重新布局
* 避免一条一条的修改DOM样式，可以采用预定义的css的class，或者将所有修改都保存起来，再一次性修改
* 避免设置多层内联样式
* 避免频繁的操作DOM
* 避免频繁读取会引发回流的属性
* 对具有复杂动画的元素，将其脱离文档流

---

---
url: /czxBlog/interview-question/f6unprhu/index.md
---
# 点击劫持
::: tip 提问

1. 什么是点击劫持？
2. 如何防护？

:::

## 点击劫持

点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。

## 防护

我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特
定的一些情况才能作为 iframe 来使用。

---

---
url: /czxBlog/interview-question/ffvuo8ul/index.md
---
# 生命周期
[![vue@3](https://img.shields.io/badge/vue-%403-brightgreen)](https://staging-cn.vuejs.org/)

::: tip 提问
简述一下 vue3 的组件生命周期
:::

## 生命周期

### 选项式

1. `beforeCreate` 在组件实例初始化完成之后立即调用。
2. `created` 在组件实例处理完所有与状态相关的选项后调用。
3. `beforeMount` 在组件被挂载之前调用。
4. `mounted` 在组件被挂载之后调用。
5. `beforeUpdate` 在组件即将因为一个响应式状态变更而更新其 DOM 树之前调用。
6. `updated` 在组件即将因为一个响应式状态变更而更新其 DOM 树之后调用。
7. `beforeUnmount` 在一个组件实例被卸载之前调用。
8. `unmounted` 在一个组件实例被卸载之后调用。
9. `errorCaptured` 在捕获了后代组件传递的错误时调用。

### 组合式

1. `onMounted()` 注册一个在组件挂载完成后执行的回调函数。
2. `onUpdated()` 注册一个回调函数，在组件由于响应性状态改变而更新了 DOM 树后调用。
3. `onUnmounted()` 注册一个要在组件卸载后调用的回调。
4. `onBeforeMount()` 注册一个钩子在组件被挂载之前被调用。
5. `onBeforeUpdate()` 注册一个钩子，在组件因为响应式状态改变而要更新 DOM 树之前调用
6. `onBeforeUnmount()` 注册一个钩子，在组件实例被卸载之前调用。
7. `onErrorCaptured()` 注册一个钩子，当从下级组件抛上来的错误被捕获时被调用。

---

---
url: /czxBlog/interview-question/fq0fou9z/index.md
---
# 模块加载器原理
::: tip 提问

1. AMD 模块加载器原理？
2. CMD 模块加载器原理？
3. CommonJS 模块加载器原理？

:::

::: tip 说明
虽然各个规范有所差异，但其最基本的一些原理原则还是相似的，
这里主要讲 AMD规范的模块加载器的原理，其他规范的差异部分再补充说明。
:::

1. **模块ID**, ID即路径原则。

2. **脚本加载**， 使用 `createElement('script') && appendChild` 请求加载模块。

   一般需要给 script设置一个属性用于标识模块ID。

3. **document.currentScript**，通过该属性获取当前模块的基本信息

文件的路径等信息，对于匿名模块非常有用。

4. 依赖分析

   模块被define后并不是马上可用了，在执行factory方法生产的 export 之前，需要保证它的依赖是可用的，
   需要先把依赖分析出来。

5. 递归加载

分析出模块依赖后，需要递归加载依赖模块。

在 CommonJs规范的nodeJS实现中，一个简化的实现例子如下：

```js
function require(path) {
  if (require.cache[path]) {
    return require.cache[path].exports
  }
  let src = fs.readFileSync(path)
  let code = new Function('exports, module', src)
  let module = { exports: {} }
  code(module.exports, module)
  require.cache[path] = module
  return module.exports
}
require.cache = Object.create(null)
```

---

---
url: /czxBlog/interview-question/gojlegqf/index.md
---
# 写一个通用事件侦听器
::: tip 提问
写一个通用事件侦听器
:::

一个通用事件侦听器 需要考虑到 浏览器的兼容问题，
在旧浏览器、IE浏览器、现代浏览器中，事件侦听的绑定和移除均有所差别，而且 event 也有差别。

```js
const DomEvent = {
  add(el, type, handler) {
    if (el.addEventListener) {
      el.addEventListener(type, handle, false)
    }
    else if (el.attachEvent) {
      el.attachEvent(`on${type}`, handler)
    }
    else {
      el[`on${type}`] = handler
    }
  },
  remove(el, type, handler) {
    if (el.removeEventListener) {
      el.removeEventListener(type, handler, false)
    }
    else if (el.detachEvent) {
      el.detachEvent(`on${type}`, handler)
    }
    else {
      el[`on${type}`] = null
    }
  },
  getTarget(event) {
    return event.target || event.srcElement
  },
  getEvent(event) {
    return event || window.event
  },
  stopPropagation(event) {
    if (event.stopPropagation) {
      event.stopPropagation()
    }
    else {
      event.cancelBubble = true
    }
  },
  preventDefault(event) {
    if (event.preventDefault) {
      event.preventDefault()
    }
    else {
      event.returnValue = false
    }
  }
}
```

---

---
url: /czxBlog/interview-question/h4casm3q/index.md
---
# 归并排序
::: tip 提问

1. 归并排序
2. 实现

:::

## 归并排序

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

### 描述

* 把长度为n的输入序列分成两个长度为n/2的子序列；
* 对这两个子序列分别采用归并排序；
* 将两个排序好的子序列合并成一个最终的排序序列。

## 实现

```js
function mergeSort(arr) {
  if (!Array.isArray(arr) || arr.length <= 1)
    return arr
  const len = arr.length
  const middle = Number.parseInt(len >> 1)
  const left = arr.slice(0, middle)
  const right = arr.slice(middle, len)
  return merge(mergeSort(left), mergeSort(right))
}

function merge(left, right) {
  const result = []
  const leftLen = left.length
  const rightLen = right.length
  let il = 0
  let ir = 0

  while (il < leftLen && ir < rightLen) {
    if (left[il] < right[ir]) {
      result.push(left[il++])
    }
    else {
      result.push(right[ir++])
    }
  }

  while (il < leftLen) {
    result.push(left[il++])
  }

  while (ir < rightLen) {
    result.push(right[ir++])
  }
  return result
}
```

---

---
url: /czxBlog/interview-question/jdk3bh3a/index.md
---
# 函数与箭头函数
::: tip 提问

1. 箭头函数相比函数有什么区别？

:::

1. 箭头函数总是匿名的
2. 绑定this

   在箭头函数出现之前，每个新函数都重新定义了自己的 `this` 值，在ES6之前，通过把this的值赋值给一个变量来保存

   ```js
   function demo() {
     let that = this
     that.count = 0
     // eslint-disable-next-line prefer-arrow-callback
     setTimeout(function () {
       that.count++
       console.log(that.count)
     }, 0)
   }
   ```

   箭头函数可以捕捉闭包上下文的`this`值，所以可以改写成：

   ```js
   function demo() {
     this.count = 0
     setTimeout(() => {
       this.count++
       console.log(this.count)
     })
   }
   ```

---

---
url: /czxBlog/interview-question/jilzuxpt/index.md
---
# NaN
::: tip 提问

1. typeof NaN的结果是什么？
2. isNaN() 和 Number.isNaN() 有什么区别？

:::

## typeof NaN

`NaN` 表示不是一个数字 （not a number），NaN 是一个警戒值，用于指出数字类型中的错误情况，
即 执行数字预算没有成功，这是失败后返回的结果。

```js
typeof Number.NaN // "number"
```

NaN 作为一个特殊值， 它和自身是不相等的，是唯一个非自反的值，即

```js
// eslint-disable-next-line no-self-compare, use-isnan
Number.NaN === Number.NaN // false
```

## isNaN() 和 Number.isNaN()

`isNaN()` 接受参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的值都会返回true，因此非数字值传入也会
返回 true，影响 NaN 的判断。

`Number.isNaN()` 会首先判断传入的参数是否为数字，如果是数字再继续判断是否为 NaN, 这种方法对NaN的判断更为准确。

---

---
url: /czxBlog/interview-question/jzx0jvhn/index.md
---
# 前端性能优化
::: tip 提问
如何做前端性能优化？
:::

前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。

为了能够提高页面的加载速度，就需要从资源的数量、大小、加载方式、加载时间等方面去优化，包括：

* 资源压缩与合并

  对HTML、CSS、JS进行压缩和文件合并； 对图片进行压缩、使用雪碧图等；

  资源压缩后可以减少资源的大小，从而提高加载速度；

  而对文件进行合并，可以减少网站http请求的次数，让更多的资源能够并发完成加载。

* 对非核心代码使用异步加载。

  对于首屏渲染不需要使用到的代码，使用异步加载的方式，等待首屏渲染完成后，再进行加载。
  可以使用 defer、 async 属性，或者动态脚本的方式进行脚本的异步加载。

* 避免使用 `@import` 加载 CSS资源

* 使用CDN服务，对内容进行分发，提高用户对资源请求的相应速度。

  还可以更细致的将 js、css资源放在一个CDN域名，将图片资源放在另一个CDN域名，
  通过多个域名并发加载更多的资源，以减少最终等待时间。

* 利用 浏览器/HTTP 缓存

  对 JS、CSS、图片等资源，使用强缓存策略，使用打包工具对这些资源文件进行哈希重命名。
  强缓存过的资源，二次访问时不会再发起网络请求，而是直接从浏览器缓存区读取。

* 服务器开启 GZip/Brotli 压缩，进一步减少请求文件大小

---

---
url: /czxBlog/interview-question/k8vcpo28/index.md
---
# 对vuex的理解
::: tip 提问

1. 简单说说你对 `vuex` 的理解

:::

## 分析

此题考察实践能力，对 `vuex` 的设计理念和实现原理的解读。

### 回答策略

1. 说明 `vuex` 的定义
2. `vuex` 解决了什么问题
3. 什么时候需要 `vuex`
4. 具体用法
5. 简述原理，优缺点等

## 回答

> **官网定义:**
>
> Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

1. `vuex` 是 `vue` 官方开源并维护的状态管理库，它以 **全局的方式集中管理应用状态**，并保证应用状态变更的可预测性。
2. `vuex` 主要解决的问题是多组件之间状态共享的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会使程序逻辑变得复杂。 `vuex` 通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。
3. `vuex` 并非必须的，它帮我们管理共享状态，但却带来更多的概念和框架。
   如果我们不打算开发大型单页应用或者我们的应用并没有大量全局的状态需要维护，完全没有使用 `vuex` 的必要。
   一个简单的 `store` 模式就足够了。反之， `vuex` 将会成为自然而然的选择。
   引用 `Redux` 的作者 `Dan Abramov` 的话说就是：Flux 架构就像眼镜：您自会知道什么时候需要它。
4. 我在使用 `vuex` 过程中有如下理解：首先是对核心概念的理解和运用，将全局状态放入 `state` 对象中，
   它本身一棵状态树，组件中使用 `store` 实例的state访问这些状态；
   然后有配套的 `mutation` 方法修改这些状态，并且只能用 `mutation` 修改状态，
   在组件中调用 `commit` 方法提交 `mutation` ；如果应用中有异步操作或者复杂逻辑组合，
   我们需要编写 `action` ，执行结束如果有状态修改仍然需要提交 `mutation` ，
   组件中调用这些 `action` 使用 `dispatch` 方法派发。最后是模块化，
   通过 `modules` 选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，
   如果子模块有设置 `namespace` ，那么在提交 `mutation` 和派发 `action` 时还需要额外的命名空间前缀。
5. `vuex` 在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了 `vue` 的数据响应化特性实现的，它会利用Vue将 `state` 作为 `data` 对其进行响应化处理，从而使得这些状态发生变化时，能够通知组件重新渲染。

---

---
url: /czxBlog/interview-question/kby2ggwi/index.md
---
# 异步请求
::: tip 提问

1. ajax
2. Fetch API
3. jsonp

:::

## ajax

ajax（Asynchronous JavaScript and XML）是指通过 javascript的异步通信，从服务端获取XML文档，
从中提取数据，再将数据更新到当前网页的对应部分，而不需要刷新网页。

一般来说，ajax 包括以下几个步骤：

* 通过 XMLHttpRequest 对象创建一个异步调用对象；
* 创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息
* 设置响应HTTP请求状态变化的函数
* 发送HTTP请求
* 获取异步调用返回的数据
* 使用javascript和 DOM 实现局部更新

## Fetch API

Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。

## jsonp

jsonp 是一种利用 `<script>` 标签 来实现的 支持跨域的异步通信方案。

前端将函数名作为参数传递到后端服务，后端服务在函数中注入需要返回的数据后，作为动态脚本返回给前端，
前端通过 script 标签加载这个动态脚本后，调用该函数，获取到返回的数据。

---

---
url: /czxBlog/interview-question/kfthgdn7/index.md
---
# 跨域
::: tip 提问

1. 什么是跨域？
2. 浏览器的同源策略
3. 跨域解决方案？

:::

## 跨域

当 协议、 子域名、 主域名、 端口号 中任意一个不相同是，都算作不同域。
不同域之间相互请求资源，就被认为是 **跨域**。

## 浏览器的同源策略

同源策略是一种约定，它是浏览器最核心也是最基本的安全功能。

同源策略是指： `协议 + 域名 + 端口` 三者相同，即使两个不同的域名指向同一个IP地址，也非同源。

同源策略限制的内容有：

* Cookie、LocalStorage、IndexedDB 等存储性内容
* DOM节点
* AJAX 请求

有三个标签允许跨域加载资源：

* `<img>`
* `<link>`
* `<script>`

## 跨域解决方案

跨域问题并不是前端开发人员仅依靠浏览器和javascript就能够解决的，常常需要跟服务器、后端技术人员进行配合，
才能解决。

### jsonp

利用`<script>` 标签没有跨域限制的特点，网页可以得到从其他来源动态产生的 JSON 数据。
JSONP请求一定需要对方的服务器做支持才可以。

### cors

cors方案需要浏览器和后端同时支持。

服务端需要设置 `Access-Control-Allow-Origin` 就可以开启cors。

该属性表示哪些域名可以访问资源，如果设置了通配符则表示所有网站都可以访问资源。

浏览器端会自动进行CORS通信。

### 代理转发

* 通过 nginx 配置一个代理服务器，反向代理 非同源域名的接口到当前域名。
* 服务器 中间代理。通过 服务器 代理转发非同源域名的接口。
*

### 其他

以下方法仅能解决部分场景下的跨域问题，并不是一种通用的，合适的解决方案。

* postMessage
* websocket
* window.name + iframe
* location.hash + iframe
* document.domain + iframe

::: tip 说明
在工作中最常用的跨域解决方案是 CORS 和 服务器代理转发。
这两种方法是最合适和最通用的解决方案。
:::

---

---
url: /czxBlog/interview-question/kqeizag0/index.md
---
# 变量
::: tip 提问

1. 声明变量的方式
2. 有什么区别

:::

## 声明变量

声明变量的方式有三种，分别是`var`、`let`、`const`。

其中`let`、`const`是`es6`新增的变量声明方式。

`var`声明的变量的作用域是它当前执行的上下文中，并且存在变量提升

```js
function fn() {
  console.log(a)
  var a = 1
  console.log(a)
}
fn()
```

相当于

```js
function fn() {
  let a
  console.log(a) // undefined
  a = 1
  console.log(a) // 1
}
fn()
```

并且在可以重复声明同一变量，在该声明的上下文中不会丢失其值。通过var声明的全局变量会作为窗口对象的属性。

`let` 声明的变量是块级作用域，不存在变量提升，并存在暂时死区，不允许在同一块级作用域重复声明。

```js
function fn() {
  console.log(a) // ReferenceError: a is not defined
  let a = 1
  let a = 2 // TypeError thrown
  console.log(a)
}
fn()
```

## 区别

`const` 声明一个常量，其作用域可以是全局或者是本地声明的块级作用域，与`var`变量不同，全局常量不会变为窗口对象的属性。

常量必须在声明的同时初始化。同时声明创建的值是一个只读引用，但不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。

如果引用内容是对象的情况下，则可以改变对象内容，除非使用`Object.freeze()`方法冻结对象。`const`声明常量同样存在暂时死区。

---

---
url: /czxBlog/interview-question/kr0wd3xk/index.md
---
# 数组和对象
::: tip 提问

1. 对象有哪些原生方法？
2. 数组有哪些原生方法？
3. 什么是类数组？

:::

## 对象的原生方法

* `Object.assign()` 通过复制一个或多个对象来创建一个新的对象
* `Object.create()` 使用指定的原型对象和属性创建一个新对象
* `Object.defineProperty()` 给对象添加一个属性并指定该属性的配置
* `Object.defineProperties()` 给对象添加多个属性并分别指定它们的配置
* `Object.entries()` 返回给定对象自身可枚举属性的`[key, value]` 数组
* `Object.freeze()` 冻结对象，其他代码不能删除或更改任何属性
* `Object.getOwnPropertyNames()` 返回一个包含了指定对象所有可枚举或不可枚举的属性名的数组
* `Object.getOwnPropertySymbols()` 返回一个包含了指定对象自身所有的符号属性
* `Object.getPrototypeOf()` 返回指定对象的原型对象
* `Object.is()` 比较两个值是否相同。(所有 NaN值都相等。)
* `Object.keys()` 返回一个包含所有给定对象自身可枚举属性名称的数组
* `Object.preventExtensions()` 防止对象的任何扩展
* `Object.seal()` 防止其他代码删除对象的属性
* `Object.values()` 返回给定对象自身可枚举值的数组

## 数组的原生方法

### 静态方法

* `Array.from()` 从类数组对象或可迭代对象中创建一个新的数组实例
* `Array.isArray()` 判断某个变量是否是一个数组对象
* `Array.of()` 根据一组参数来创建新的数组实例

### 实例方法

* `Array.prototype.concat()` 合并两个或多个数组，并返回一个新的数组
* `Array.prototype.copyWithin` 浅复制数组的一部分到同一数组的另一个返回，并返回它，不会改变原数组的长度
* `Array.prototype.entries()` 返回一个新的`Array Iterator`对象，对象包含数组中的每个索引的键值对
* `Array.prototype.every()` 测试一个数组组内的所有元素是否都能通过某个指定函数的测试，并返回一个布尔值
* `Array.prototype.fill()` 用一个固定值填充一个数组中的全部元素
* `Array.prototype.filter()` 创建一个新数组，包含通过所提供的函数实现的测试的所有元素
* `Array.prototype.find()` 返回数组中满足提供的测试函数的第一个元素，否则返回 undefined
* `Array.prototype.findIndex()` 返回数组中满足提供的测试函数的第一个元素的索引，否则返回 -1
* `Array.prototype.flat()` 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回
* `Array.prototype.flatMap()` 使用映射函数映射每一个元素，然后将结果压缩成一个新数组
* `Array.prototype.forEach()` 对数组的每一个元素执行一次给定的函数
* `Array.prototype.includes()` 判断一个数组是否包含一个指定的值，返回一个布尔值
* `Array.prototype.indexOf()` 返回在数组中可以找到一个给定元素的第一个索引，不存在则返回 -1
* `Array.prototype.join()` 将一个数组的所有元素链接成一个字符串并返回
* `Array.prototype.keys()` 返回一个包含数组中每个索引建的 `Array Iterator`对象
* `Array.prototype.lastIndexOf()` 返回指定元素在数组中的最后一个索引，不存在则返回 -1
* `Array.prototype.map()` 返回一个数组，其结果是该数组的每个元素是调用一次提供的函数后的返回值
* `Array.prototype.pop()` 从数组中删除最后一个元素，并返回该元素的值
* `Array.prototype.push()` 将一个或多个元素添加到数组的末尾，并返回该数组的新长度
* `Array.prototype.reduce()` 对数组中的每个元素指定一个指定的reducer函数（从左向右），将其结果汇总为单个返回值
* `Array.prototype.reduceRight()` 类似于 `reduce()`，但是是从右向左
* `Array.prototype.reverse()` 将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组
* `Array.prototype.shift()` 从数组中删除第一个元素，并返回该元素的值
* `Array.prototype.slice()` 提取原数组的一部分并返回一个新数组
* `Array.prototype.some()` 测试数组中是不是至少有一个元素通过了提供的测试函数
* `Array.prototype.sort()` 对数组元素进行原地排序并返回此数组
* `Array.prototype.splice()` 通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容
* `Array.prototype.unshift()` 将一个或多个元素添加到数组的头部，并返回该数组的新长度
* `Array.prototype.values()` 返回一个新的`Array Iterator` 对象，该对象包含数组每个索引的值。

### 类数组

类数组是指 一个拥有 `length` 属性 和 若干索引属性的对象。

类数组对象和数组类似，但不能调用数组的方法。

常见的类数组有， `arguments` 和 DOM方法返回的结果

---

---
url: /czxBlog/interview-question/ku3jvbnj/index.md
---
# git
::: tip 提问

1. git 是什么？
2. git和 svn 有什么区别？
3. git pull 和 git fetch有什么区别？
4. git merge 和 git rebase 有什么区别？
5. git-flow 是什么？

:::

## 什么是 git

git是目前使用最广泛的软件版本管理系统。

git是分布式版本管理工具。

## git和svn的区别

* git是分布式的，而svn是集中式的
* svn的分支是整个版本库的复制的一份完整目录，而git的分支是指针指向某次提交。因此git的分支创建更快，开销更小，
  并且分支上的变化不会影响到其他人。svn的分支变化会影响到所有人。

## git pull 和 git fetch 的区别

* git fetch 用于将远程仓库的变化下载到本地，但不与本地分支合并，主要用于同步远程仓库的变更到本地仓库
* git pull 用于将远程仓库的变下下载并和当前分支进行合并。

## git merge 和 git rebase 的区别

两个命令都是用于 分支合并，区别在于 commit 记录的处理有所不同

* git merge 会新建一个 合并 commit， 然后两个分支以前的commit记录都指向这个新的合并 commit 记录。
  这种方法会保留之前每个分支的commit历史

* git rebase 会先找到两个分支的第一个共同 commit 祖先记录，然后提取当前分支之后的所有commit记录，然后将

* 这个commit记录添加到目标分支的最新提交后面。经过合并后，两个分支合并后的commit记录就变为了线性记录。

如果想要一个干净的，没有 merge commit 的线性历史，那么可以选择 git rebase，
如果想要保留完整的历史记录，并且避免重写 commit history的风险，那么应该选择 git merge。

个人认为在团队协作中，如果团队成员对 git 的掌握一般，并不了解 rebase黄金法则，同时想要把控所有成员完整的提交历史，
建议选择使用 git merge，能够更好的追踪所有成员提交记录。

## git-flow

git-flow 是git的一种工作流，一种git分支管理方案。

git-flow 分支规范：

* master ：主分支，存储项目正式发布历史。
* develop: 开发分支，用作 feature 分支的 集合分支。
* feature/\*: 从开发分支拉取的 功能分支，开发完成后推送到 开发分支，不跟 主分支产生交互
* release： 发布分支，当开发分支累计了一定量的发布功能，就从开发分支分离一条 release分支，
  此时 develop分支不再添加新的功能，仅能做一些修复、文档相关的面向发布的任务。
* hotfix： 紧急修复分支，用于发布产品的补丁，从master分支分离，发布完成后应该马上合并回master分支，
  并合并到 develop或release分支。然后主分支马上被打上新版本的tag

团队是否使用 git-flow 的完整工作流程，见仁见智，对于项目比较大，涉及人数较多，git-flow 是个不错的选择；
如果人数较少，那么可以在这个基础上，选择简化工作流。

---

---
url: /czxBlog/interview-question/leu2g17b/index.md
---
# UI框架
常用的 UI框架有包括：

* element-ui (vue@2)
* element-plus (vue@3)
* ant-design (react)
* iView
* vant-ui
* vuefity
* navie-ui

---

---
url: /czxBlog/interview-question/lkriz1wa/index.md
---
# 响应式原理
[![vue@3](https://img.shields.io/badge/vue-%403-brightgreen)](https://staging-cn.vuejs.org/)

::: tip 提问

1. 简单介绍一下Vue的响应式原理
2. vue2 和 vue3 的响应式对象有什么区别？

:::

## Vue 响应式原理

在 javascript 中，有两种劫持属性访问的方式： `getter/setter` 和 `Proxies`。
在`Vue3` 中，使用了 `Proxy` 来创建响应式对象。

* 在 Vue中，跟数据关联的其他操作行为，被称为`副作用 effect`，Vue内部会维护一个使用 `WeakMap` 定义的副作用队列，
  将副作用订阅都存储在其中。

  ```ts
  WeakMap<target, Map<key, Set<effect>>>
  ```

* 在 数据的 `getter` 方法中，使用 `track` 函数检查是否有正在运行的副作用，然后将这个副作用添加到该数据的订阅者 `Set` 中。

* 在数据的 `setter` 方法中，当数据发生改变，则找到该数据的所有订阅的副作用，然后一一执行这些副作用。

* 对于组件实例，将DOM渲染也认为是副作用的一种，数据更新时，同样会去执行这个副作用。

## Vue3 和 Vue2 实现响应式原理的区别

* 相比于 Vue2， Vue3的由于采用了 `Proxy`的方式来实现响应式对象，
  响应式数据能够检测到响应式对象的属性的添加和删除

* 使用`WeakMap`数据结构来保存响应式对象的副作用，在响应式对象没有再被引用时，能够及时的被垃圾回收，减少内存开销。

---

---
url: /czxBlog/interview-question/lzbk7vkc/index.md
---
# 数据类型
::: tip 提问

1. javascript有哪些数据类型？
2. 什么是基本数据类型？
3. 什么是引用数据类型？
4. 如何做数据类型判断？

:::

## 数据类型

javascript 有两种数据类型，分别是 基本数据类型 和 引用数据类型。

## 基本数据类型

javascript一共有7中基本数据类型，包括：
`undefined`, `null`, `Boolean`, `Number`,
`String`, `BigInt`, `Symbol`。

特性：

* 存放在栈区
* 进行值比较时，`==` 只进行值的比较，会进行数据类型转换， `===` 不仅进行值的比较，还要进行数据类型的比较。

## 引用数据类型

引用数据类型指 Object 类型， 所有其他的如 Array、Date、Function等类型都可以理解为Object类型的子类。

特性：

* 同时保存在栈内存和堆内存中。解释器寻找引用值是，会首先检索它在栈中的地址，取得地址后从堆中获得实体。
* 比较时是引用的比较

## 数据类型判断

### typeof

`typeof` 返回一个表示数据类型的字符串，可以用来判断 `number`, `boolean`, `string`,`symbol`,`object`,
`undefined`, `function` 等7种数据类型，但不能判断 `null`，`Object`的子类等。

### instanceof

`instanceof` 用来判断 A是否为B的实例。 一般用于判断引用类型。但在 类的原型继承中，结果不一定准确。

### constructor

`constructor` 和 `instanceof` 类似， 但还可以处理除了 null、undefined 之外的基本数据类型的检测。

`constructor`不是稳定的，如果把类的原型重写，可能会把之前的`constructor`给覆盖了。

### Object.prototype.toString.call(someObj)

最准确也是最常用的数据类型检测方式。 该方法会将数据类型的检测结果以`[object <type>]` 的形式返回。

### 其他

除了上述的方式，一些数据类型也提供了方法进行数据类型判断，如：

* Array.isArray()
* Number.isNaN()

---

---
url: /czxBlog/interview-question/m9iifxl4/index.md
---
# 生命周期
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问

1. 简述下vue组件的生命周期

:::

## 生命周期

1. `beforeCreate` 在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。

2. `created` 在实例创建完成后被立即同步调用。

   实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。

3. `beforeMount` 在挂载开始之前被调用：相关的 render 函数首次被调用。

4. `mounted` 实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。

   `mounted` 不会保证所有的子组件也都被挂载完成。

5. `beforeUpdate` 在数据发生改变后，DOM 被更新之前被调用。

6. `updated` 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。

7. `activated` 被 keep-alive 缓存的组件激活时调用。

8. `deactivated` 被 keep-alive 缓存的组件失活时调用。

9. `beforeDestroy` 实例销毁之前调用。在这一步，实例仍然完全可用。

10. `destroyed` 实例销毁后调用。

11. `errorCaptured` 在捕获一个来自后代组件的错误时被调用。

---

---
url: /czxBlog/interview-question/mp8b8qeh/index.md
---
# 内存泄露
::: tip 提问
哪些操作会造成内存泄露？
:::

1. 意外的全局变量

   由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

2. 被遗忘的计数器或回调函数

   设置了`setInterval`定时器时，忘记取消它。如果循环函数有对外部变量的引用，那么这个变量会一直被留在内存中无法被回收。

3. 脱离DOM的引用

   在获取一个DOM的元素引用后，这个元素被删除，由于保留了对这个元素的引用，所以也无法被回收。

4. 闭包

   不合理的使用闭包，从而导致某些变量一直留在内存中无法被回收。

---

---
url: /czxBlog/interview-question/mvcgg9uz/index.md
---
# XSS攻击
::: tip 提问

1. 什么是XSS攻击？
2. 如何防范 XSS攻击？

:::

## XSS攻击

XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。
攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，
浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

## 防范XSS攻击

* 对存入数据库的数据都进行的转义处理
* 对需要插入到 HTML 中的代码做好充分的转义
* 使用 CSP
* cookie 使用 http-only

---

---
url: /czxBlog/interview-question/nj8az302/index.md
---
# 栈和堆
::: tip 提问

1. 什么是栈？
2. 什么是堆？
3. 有什么区别和联系？

:::

栈和堆的概念存在于数据结构中和操作系统内存中。

在数据结构中，栈中的数据的存取方式是先进后出。
而堆是一个优先队列，按优先级来进行排序的，优先级可以按照大小来规定。

在操作系统中，内存被分为栈区和堆区。

栈区内存由变意思自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。

堆区内存一般有程序员分配释放，若不手动释放，程序结束时可能有垃圾回收机制回收。

在javascript中，由于 javascript的 GC机制，开发人员很少需要关注 栈和堆。

一般都是了解 基本数据类型是存放在 栈中，而引用数据类型的实体存放在堆中，然后在栈中保存该数据在堆中的地址。

---

---
url: /czxBlog/interview-question/nx0xqyp5/index.md
---
# v-if和v-show的区别
::: tip 提问

1. `v-if` 和 `v-show` 有什么共同点？
2. 有什么区别？
3. 该如何选择使用哪个？

:::

## 共同点

* 都是 Vue的内置指令
* 都能控制元素的 显示和隐藏

## 区别

* `v-show` 是通过控制 元素 的 `display`， 通过设置为 `none` 来实现元素的隐藏，
  初始值无论是true或false，都会进行编译，且只会编译一次，后续状态变更仅改变 `display`的值。
  频繁切换开销比较小。

* `v-if` 是 动态的向 DOM树中插入和删除DOM元素，若初始值为 false，则跳过编译。
  后续状态变更，每次都会重新向 DOM树中插入或删除DOM元素。
  频繁切换开销比较大。

## 选择

* 对于不需要频繁切换状态的，选择使用 `v-if`
* 对于频繁切换状态的，选择使用 `v-show`。

---

---
url: /czxBlog/interview-question/oc3hgg0h/index.md
---
# 作用域和作用域链
::: tip 提问

1. 什么是javascript的作用域？
2. 什么是 javascript的作用域链？

:::

## 作用域

作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。

作用域决定了代码区块中变量和其他资源的可见性。

### 全局作用域

在代码中任意地方都能访问到的对象拥有全局作用域。

### 函数作用域

声明在函数内部的变量，仅能在当前函数内部访问到的，拥有函数作用域

### 块级作用域

通过 `let` 或 `const` ，在 函数内部，或者在一队花括号 里声明的变量，拥有块级作用域

块级作用域 特性：

* 声明的变量不会提升到当前作用域顶部
* 禁止重复声明

## 作用域链

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。

作用域链本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。
作用域链的前端使用都是当前执行上下文的变量对象。全局执行上下文的变量对象始终是作用域链的最后一个对象。

当我们查找一个变量时，如果当前执行环境中没有找到，会沿着作用域链向后查找。

作用域链的创建过程跟执行上下文的建立有关。

---

---
url: /czxBlog/interview-question/oi8seb1b/index.md
---
# 集合对象
集合对象是指： `Set`、 `Map` 、`WeakSet`、 `WeakMap`

::: tip 提问
简单介绍一下 `Set`、 `Map` 、`WeakSet`、 `WeakMap`
:::

## Set

`Set` 对象是 值的集合，Set中的元素只会出现一次，即 Set 中的元素值是唯一的。

* `Set.prototype.add()` 在当前实例的尾部添加一个元素，并返回当前Set实例
* `Set.prototype.clear()` 移除当前实例的所有元素
* `Set.prototype.delete()` 移除当前实例中的指定的元素
* `Set.prototype.has()` 判断当前实例中是否存在指定的元素
* `Set.prototype.entries()` 返回一个迭代器对象，该对象包含按照插入顺序排列所有元素的 `[value, value]`数组
* `Set.prototype.keys()` 同 `values()` 方法
* `Set.prototype.values()` 返回一个迭代器对象，该对象包含按照插入顺序排列的所有元素的值

## Map

`Map` 对象保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。

* `Map.prototype.set()` 在当前实例添加或更新一个指定的键和值的键值对
* `Map.prototype.get()` 返回当前实例中的一个指定元素
* `Map.prototype.has()` 判断当前实例中是否存在指定元素，返回 布尔值
* `Map.prototype.delete()` 移除当前实例中指定元素
* `Map.prototype.clear()` 移除当前实例所有元素
* `Map.prototype.entries()` 返回一个迭代器对象，该对象包含按照插入顺序排列所有元素的 `[key, value]`数组
* `Map.prototype.keys()` 返回一个迭代器对象，该对象包含按照插入顺序排列的所有元素的键
* `Map.prototype.values()` 返回一个迭代器对象，该对象包含按照插入顺序排列的所有元素的值

## WeakSet

`WeakSet` 对象是一些对象值的集合，并且其中的每个对象值都只能出现一次，在集合中是唯一的。

`WeakSet` 和 `Set` 的区别：

* 与`Set` 相比，`WeakSet`只能是对象的集合，而不能是任何类型的任意值

* `WeakSet`集合中的对象的引用为弱引用。如果没有其他的对`WeakSet`中的对象的引用，那么这些对象会被当成垃圾回收掉。

* `WeakSet` 是不可枚举的。

* `WeakSet.prototype.add()` 在当前实例的尾部添加一个元素，并返回当前Set实例

* `WeakSet.prototype.delete()` 移除当前实例中的指定的元素

* `WeakSet.prototype.has()` 判断当前实例中是否存在指定的元素

## WeakMap

`WeakMap` 对象是一组 键值对 的集合，其中的键是弱引用的，且键必须是对象，而值可以是任意的。

`WeakMap` 和 `Map` 的区别

* `WeakMap` 的键必须是对象，值可以使任意的。

* 由于键是弱引用的，所以当键所指对象没有其他地方引用的时候，它会被GC回收掉。

* `WeakMap` 是不可枚举的。

* `WeakMap.prototype.set()` 在当前实例添加或更新一个指定的键和值的键值对

* `WeakMap.prototype.get()` 返回当前实例中的一个指定元素

* `WeakMap.prototype.has()` 判断当前实例中是否存在指定元素，返回 布尔值

* `WeakMap.prototype.delete()` 移除当前实例中指定元素

---

---
url: /czxBlog/interview-question/os6hn2b8/index.md
---
# CDN
::: tip 提问
CDN是什么？
:::

CDN是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域，不同运营商的服务器，
向用户提供资源就近访问的功能。

用户的请求不直接发送到原网站，而是发送给CDN服务器，由CDN服务器将请求定位到最近的含有该资源的服务器上去请求。

有利于提高网站的访问速度，同时也减轻了源服务器的访问压力。

---

---
url: /czxBlog/interview-question/ouqcf733/index.md
---
# 前端SEO
1. 设置合适`title`、`description`、`keywords`，搜索引擎对这三项的权重逐步减小。
   title值强调重点，不同页面title要不同；重要关键词不要出现超过2次，且必须靠前；
   description概括页面内容，长度不宜过长。

2. 语义化的html代码，符合W3C规范。

3. 重要内容HTML代码放在最前，搜索引擎爬取HTML顺序是从上到下，尽可能保证重要内容能够提前被抓取。

4. 图片必须设置 alt属性值

5. 提高网站访问速度，网站速度是搜索引擎排序的重要指标

6. 准备一个 robot.text 文件，给搜索引擎爬取

7. 为网站生成 sitemap，方便搜索引擎爬取网站需要被收录的页面。

---

---
url: /czxBlog/interview-question/ov7st17l/index.md
---
# 负载均衡
::: tip 提问

1. 什么是负载均衡
2. 如何实现？

:::

## 负载均衡

负载均衡指， 将负载（即工作任务）进行平衡，分摊到多个操作单元上执行。

## 负载均衡实现

1. 反向代理服务器
2. DNS

---

---
url: /czxBlog/interview-question/p1gn97x5/index.md
---
# BFC块级格式化上下文
::: tip 提问

* 什么是 BFC ?
* 如何创建BFC ?
* BFC有什么作用 ？

:::

## 什么是 BFC

BFC, Block Formatting Context。是 W3C CSS2.1规范中的一个概念。 是页面中的一块块级渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和作用。

具有BFC特性的元素，可以看做是一个被隔离了的独立容器，容器内的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。

## 创建BFC的方式

1. 根元素（html）
2. 浮动元素，即 float值不为 none。
3. 绝对定位元素， 元素的 position 为 absolute 或者 fixed
4. 行内块元素， 元素的 display 为 inline-block
5. 表格单元格， 元素的 display 为 table-cell。 （HTML表格单元格默认为该值）
6. 表格标题， 元素的display为table-caption。 （HTML表格标题默认为该值）
7. 匿名表格单元格元素， 元素的display为 table、table-row、table-row-group、
   table-header-group、table-footer-group 。 （分别是 HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table。
8. overflow计算值不为visible的块元素
9. display值为 flow-root的元素
10. contain值为 layout、content、paint的元素
11. 弹性元素，display为 flex、inline-flex元素的直接子元素
12. 网格元素， display为gird、inline-gird元素的直接子元素
13. 多列容器，元素的column-count或column-width不为 auto， 包括column-count不为1
14. colum-span为all的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中。

## 作用

1. 同一个BFC的外边距会发生折叠（合并）， 通过将其放在不同的BFC中规避折叠。
2. BFC可以包含浮动元素，即清除浮动。
3. BFC可以阻止元素被浮动元素覆盖。

---

---
url: /czxBlog/interview-question/qm07ep25/index.md
---
# CSRF攻击
::: tip 提问

1. 什么是CSRF攻击？
2. 如何防范CSRF攻击？

:::

## CSRF攻击

CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。

如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

## 防护CSRF攻击

* 同源检测的方法。

  服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。

* 使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。

  这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，
  我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。
  还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，
  但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。

* 使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。

  使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。

* 使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。

  Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。

---

---
url: /czxBlog/interview-question/r3evwwd7/index.md
---
# 元素垂直居中
::: tip 提问

* 在 某某场景下，如何让某某元素垂直居中？
* 有哪些方式可以实现元素的垂直居中？

:::

**设立一个场景：在一个宽高不固定的容器中，实现一个宽高不固定的内容盒子，并垂直水平居中。**

```html
<!-- 假设 warpper、container 宽高不固定 实现container相对于wrapper垂直水平居中-->
<div class="wrapper">
  <div class="container"></div>
</div>
```

**方法一：** 使用 flex 布局

```css
.wrapper {
  display: flex;
}
.container {
  margin: auto;
}
```

适用于支持 flex布局的浏览器（IE11以上，其他现代浏览器）。这里是利用flex弹性布局的特性，弹性容器改变了其子元素填充可用空间的方式，子元素默认从容器左上角开始排列，在不设置宽高时，子元素填充空间由`flex`声明，默认值为`0 1 auto`,即
`flex-grow: 0;flex-shrink: 1;flex-basis: auto`; 其中 `flex-basis`定义了子元素的宽和高的尺寸大小，`auto`值表示自动尺寸，根据子元素内容计算宽高，在子元素上设置`margin: auto`，这是利用`auto`平均分配水平或垂直方向上的额外的空间，从而达到目的。（此方法实现的结果是“真正的”垂直水平居中）

或者

```css
.wrapper {
  display: flex;
  justify-content: center;
  align-content: center;
}
```

**方法二：** 使用 table 布局

```css
.wrapper {
  display: table-cell;
  vertical-align: middle;
}
.container {
  margin: auto;
}
```

利用的是table布局的特性，不过该方法有个缺点就是，`display: table-cell`元素的宽高设置百分比数值是“无效的”，原因是父元素非`table`元素或`display: table`元素，`display: table-cell`元素的宽高百分比数字是相对于`table`计算的。

**方法三：** `position` + `transform`

```css
.wrapper {
  position: relative;
}
.container {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

该方法与前面两个方法的作用机理有很大的不同，首先第一点是`container`脱离了文档流，
并且`container`自身的宽高发生了坍塌，在不设置宽高属性下，尺寸由内容撑开，
`container`相对`wrapper`元素进行绝对定位，水平方向与垂直方向上，
`container`的左上角顶点偏移到`wrapper`中点，`container`的`transform`是相对于自身的，
`translate(-50%, -50%)`相对于自身，将左上角顶点做左上偏移自身的一半，从而实现了目的。

*有一些面试者给出了`container`元素上设置`margin-left: -50%; margin-top: -50%`的答案，然而，margin的百分比值，是相对于其父元素计算的。*

**方法四：** 使用 行内块元素

```css
.wrapper {
  text-align: center;
}
.wrapper:after {
  content: '';
  display: inline-block;
  vertical-align: middle;
  height: 100%;
}
.container {
  display: inline-block;
  vertical-align: middle;
  text-align: left;
}
```

该方法实现的垂直水平居中其实是一个近似垂直水平居中，兼容IE7以上的浏览器。
水平方向上`.wrapper`设置`text-align: center;`实现了水平居中；垂直方向上，
给定`container`声明行内块元素，并`vertical-align: middle`，但由于`container`高度不确定，
无法声明具体的行高，所以借助了父元素的伪类元素，创建了一个宽度为0高度为100%的行内块元素，
从而使`container`元素在垂直方向上实现了居中。
但由于`vertical-align: middle`是元素的中线与字符X的中心点对齐，大多数字体设计字体的中心点偏下，
也导致了实现的垂直居中并不是绝对的垂直居中。而要实现绝对的垂直居中，需要添加一下属性：

```css
.wrapper {
  font-size: 0;
  white-space: nowrap;
}
.container {
  font-size: 14px; /* 重置回默认字体大小 */
  white-space: normal;
}
```

---

---
url: /czxBlog/interview-question/rh7yy89s/index.md
---
# lodash
lodash 是一个 工具库，提供了一系列 对于 字符串、数组、对象、集合 等数据结构的工具函数

支持在项目引入整个lodash，也支持在项目中仅引入某个工具函数。

---

---
url: /czxBlog/interview-question/rumwg3ew/index.md
---
# data为什么必须是函数
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问
在vue2的组件中，data为什么必须是一个函数
:::

## data

因为一个组件可能会产生多个组件实例，而每个组件实例都应该拥有私有的数据空间，
也就是说每个组件实例的data应该是相互独立的。

将 `data` 使用函数的形式返回一个对象，这样每个组件实例都会获取一个新的 数据对象。

---

---
url: /czxBlog/interview-question/sfnusib9/index.md
---
# 盒模型
::: tip 提问

* 请简述 CSS 盒模型。
* 盒模型有哪些类型？有什么区别？

:::

盒模型是CSS规范定义的模块，它规定了一个矩形盒子（标准盒模型），描述任意元素在文档树中占据的空间区域。每个盒子有四个边：

* `外边距边（margin edge or outer edge）`
* `边框边（border edge）`
* `内填充边（padding edge）`
* `内容边（content edge or inner edge）`

可以划分四个区域：

* `外边距区域（margin area）`
* `边框区域（border area）`
* `内填充区域（padding area）`
* `内容区域（content area）`

![css box model](https://drafts.csswg.org/css-box-3/images/box.png)

为什么会有盒模型类型，严格来说，多数浏览器都按照规范实现了标准盒模型，而盒模型的类型主要是来自于不同浏览器对元素宽高的方式不同而导致，IE浏览器认为元素的`width/height`应该是由元素的`内容+内填充+边框`组成，而W3C规定的元素的`width/height`应该是元素的`内容`，从而衍生了不同的盒子模型。到`CSS3`，添加了`box-sizing`属性，用于更改用于计算元素宽高的默认盒子模型，并将IE浏览器和W3C规范纳入了实现中。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。

*注：`width/height`最终并不能完全决定元素的实际占用宽高。*

```css
/* 关键字值 */
box-sizing: border-box; /* 默认值 */
box-sizing: content-box;
/* 全局值 */
box-sizing: inherit;
box-sizing: initial;
box-sizing: unset;
```

`border-box`规定了元素的`width`由`内容+内填充+边框`组成，即IE浏览器的实现。 元素的实际占据宽度由 width属性+外边距。内容宽度为`width - padding - border`。

`content-box`规定了元素的`width`即`内容宽度`, W3C规范的标准。元素的实际占据宽度由`widht + padding + border + margin`。内容宽度为`width`。

`box-sizing`还有一个待废除的值`padding-box`，`width` 和 `height` 属性包括内容和内边距，但是不包括边框和外边距。只有Firefox实现了这个值，它在Firefox 50中被删除。

在高度计算上以上规则同样适用，但对非替换行内元素，尽管内容周围存在内边距与边框，但其占用空间受到`line-height`属性影响。

---

---
url: /czxBlog/interview-question/sx71rqqx/index.md
---
# 浏览器渲染原理
::: tip 提问

1. 说说 浏览器的渲染原理

:::

1. 解析收到的文档， 根据文档定义构建一棵 DOM 树， DOM 树是由DOM元素及属性节点组成的。

2. 对CSS进行解析，生成 CSSOM（CSS Object Model） 规则树。

3. 根据DOM树和CSSOM规则树构建 渲染树。 渲染树的节点被称为渲染对象，渲染对象是一个包含颜色和大小等属性的矩形，
   渲染对象和DOM元素相对应，但并非一对一的对应关系，不可见的DOM元素不会被插入渲染树。
   还有一些元素对应几个可见对象，它们一般是具有复杂结构的元素，无法用一个矩形来描述。

4. 当渲染对象被创建并添加到渲染树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，
   就会根据渲染树来进行布局（也可以叫回流）。这一阶段浏览器要做的事情是确定各个节点在页面中的位置和大小。
   通常这个行为也被称为`自动重排`。

5. 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，
   绘制使用UI基础组件。

这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等所有的html都解析
完成之后再去构建和布局渲染树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

---

---
url: /czxBlog/interview-question/ud3m8zxg/index.md
---
# MVC/MVP/MVVM
::: tip 提问

1. MVC
2. MVP
3. MVVM
4. 区别

:::

::: info 说明
以上架构设计模式，仅限于在前端领域内进行说明
:::

## Model\&View

* `Model` 是用于封装应用程序的业务逻辑的相关数据以及对数据的处理方法。

* `View` 作为视图层，主要负责数据的展示。

## MVC

`C` 是指 `Controller`。负责监听 `View` 的用户事件，得到数据后后 `Controller` 做一些处理，然后渲染 `View`。

`MVC` 通过分离 `Model`、`View` 和 `Controller` 的方式来组织代码结构。
`View` 和 `Model` 应用了观察者模式，当 `Model` 层发生改变的时候它会通知有关 View 层更新页面。
`Controller` 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，
`Controller` 中的事件触发器就开始工作了，通过调用 `Model` 层，来完成对 `Model` 的修改，然后 `Model` 层再去通知 View 层更新。

## MVP

`P` 是指 `Presenter`。`Presenter`会调用View层提供的接口去渲染Model。

`MVP` 模式中，View 层的接口暴露给了 `Presenter`，
因此可以在 `Presenter` 中将 `Model` 的变化和 `View` 的变化绑定在一起，以此来实现 `View` 和 Model 的同步更新。
这样就实现了对 `View` 和 `Model` 的解耦，`Presenter` 还包含了其他的响应逻辑。

## MVVM

`VM` 是指 `ViewModel`。

`MVVM` 在`VM`中构建一组状态数据（state data），作为`View`状态的抽象。
然后通过 **双向数据绑定（data binding）** 使`VM`中的 **状态数据（state data）** 与`View`中的 **显示状态（screen state）** 保持一致。
这样，`VM`中的展示逻辑只需要修改对应的状态数据，就可以控制`View`的状态，从而避免在`View`上开发大量的接口。

---

---
url: /czxBlog/interview-question/uvtzbz89/index.md
---
# 模块化
::: tip 提问

1. 什么是前端的模块化？
2. 模块化的规范
3. `AMD`、`CMD`、`CommonJs`， `ES Module` 有什么区别？

:::

参阅 [javascript模块化](/article/javascript-modules/)

---

---
url: /czxBlog/interview-question/uyl99uql/index.md
---
# 代理
::: tip 提问

1. 什么是正向代理？
2. 什么是反向代理？

:::

## 正向代理

正向代理指 客户端请求的服务，都被代理服务器代替来请求。

它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁。

## 反向代理

反向代理指， 客户端请求的服务，都会被代理服务器转发到真实的服务器。

反向代理隐藏了真实的服务端，当请求一个网站的时候，背后可能有成千上万台服务器在提供服务，但具体是哪一台，并不需要关注，客户端只需要知道反向代理服务器就可以了。

反向代理一般用来实现负载均衡。

---

---
url: /czxBlog/interview-question/w122van2/index.md
---
# Virtual DOM
::: tip 提问

1. 什么是 Virtual DOM?
2. Virtual DOM 比 原生DOM快在哪里？

:::

## Virtual DOM

本质上，`Virtual DOM` 是一个普通的javascript对象。
我们将需要需要插入的文档的DOM树结构进行解析，使用一个对象结构进行表述，
比如一个元素对象，包含了 `TagName` , `props` , `attribute` ,`children` 等属性，
然后我们将这个对象结构保存起来，最后再将DOM片段插入到文档中。

当页面的状态发生变化，需要对页面的DOM结构进行调整的时候，首先根据变更的状态，重新构建一颗对象树，
然后将新的对象数和旧的对象数进行对比，记录下两颗树的差异，最后将有差异的地方应用到DOM树中，视图就实现了更新。

## Virtual DOM 比 原生DOM快在哪里？

首先，`Virtual DOM` 本身并没有比原生DOM直接操作DOM要快，但是 `Virtual DOM` 这种方法对于需要进行大量的DOM操作，
操作颗粒比较细、多、复杂的场景下，能够很好的提高操作效率。

通过在操作DOM前，通过 Diff 算法对比新旧两个`Virtual DOM`，我们可以 确定最小的更新范围，尽可能的减少DOM操作带来的回流和重绘的影响。

其目的是是提高了我们的开发时的可维护性，在任意情况下，都能保证在 `Virtual DOM` 带来的尽量小的性能消耗操作DOM。

## DOM 树的比较

两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。

算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。

在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。

---

---
url: /czxBlog/interview-question/w4yx9kq0/index.md
---
# Flex弹性布局
::: tip 提问
描述一下 Flex box
:::

## Flex Box

Flex Box 即 弹性盒布局模型。

任何一个容器都可以指定为Flex布局。

采用Flex布局的元素，称为Flex容器，简称容器。它的所有子元素自动成为容器成员。

在容器上，可以设置以下属性：

* `flex-direction`: 主轴的方向， 默认值是 row
* `flex-wrap` : 一条轴线排不下时，如何换行，默认值是 nowrap
* `flex-flow` : flex-direction 和 flex-wrap 的简写形式，默认值是 row nowrap
* `justify-content` 定义容器成员在主轴上的对齐方式
* `align-items` 定义项目成员在交叉轴上的对齐方式
* `align-content` 定义多跟轴线的对齐方式，如果容器成员只有一根轴线，该属性不起作用

在项目成员上，可以设置以下属性：

* `order` 定义成员的排列顺序。数值越小，排列越靠前，默认为 0
* `flex-grow` 定义成员的放大比例，默认为 0
* `flex-shrink` 定义成员的缩小比例，默认为 1
* `flex-basis` 定义在分配多余空间之前，成员占据的主轴空间，默认为 auto
* `flex` flex-grow, flex-shrink , flex-basis 的简写，默认为 0 1 auto
* `align-self` 定义单个成员的对齐方式

## 总结

flex布局是css3新增的布局方式，可以通过将一个元素的display属性声明为 flex 从而使元素成为 flex容器。

一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴，可以声明主轴的方向、定义容器成员的主轴上的对齐方式，
交叉轴的对齐方式、换行方式等。对容器成员，可以定义排列顺序、空间利用方式、对齐方式等。

---

---
url: /czxBlog/interview-question/w6mai9ic/index.md
---
# v-if和v-for优先级
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问

1. vue2中 `v-if` 和 `v-for` 哪个优先级高？
2. 当需要同时使用时，该如何进行优化？

:::

## 优先级

* 当两个指令位于同一个DOM时，`v-for` 的优先级总是 高于 `v-if`。

## 优化

同时使用时，由于优先级的原因， 每次渲染总会先执行循环再执行 `v-if`, 无论如何，循环都不可避免。
对于这类情况：

* 如果是需要控制 由 `v-for` 执行生成元素列表的判断，可在 `v-for` 的外层嵌套一个 `template` 标签，
  在 `template` 标签上进行 `v-if`的判断

* 如果是需要控制 由 `v-for` 执行生成的元素列表的特定子项的判断，可以先使用 计算属性提前过滤 不需要的 项。

---

---
url: /czxBlog/interview-question/wdcjym47/index.md
---
# this对象
::: tip 提问
谈谈你对 this 对象的理解
:::

`this` 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象，
在实际开发中，this的指向可以通过四种调用模式来判断。

* 函数调用模式。当一个函数不是一个对象的属性时，直接作为函数来调用，this指向全局对象。
* 方法调用模式。如果一个函数作为一个对象的方法来调用时，this指向这个对象。
* 构造器调用模式。如果一个函数用new调用时，函数执行前会新创建一个对象，this指向这个新创建的对象。
* apply、call、bind调用模式，这三个方法都可以显式的指向调用函数的this指向。
  * `apply` 方法接受两个参数，一个是this绑定的对象，一个是参数数组。
  * `call` 方法接受的参数，第一个参数是this绑定的对象，后面其余的参数是传入函数执行的参数。
  * `bind` 方法通过传入一个对象，返回一个this绑定了传入对象的函数。

---

---
url: /czxBlog/interview-question/wnuvm4t1/index.md
---
# 字符串
::: tip 提问
String有哪些原始方法？
:::

## 静态方法

* `String.fromCharCode()` 返回一个由指定的 UTF-16 代码单元序列创建的字符串

## 实例方法

* `String.prototype.charAt()` 从一个字符串中返回指定的字符
* `String.prototype.charCodeAt()` 返回 0 到 65535 之间的整数，表示给定索引处的UTF-16代码单元
* `String.prototype.concat()` 将一个或多个字符串与原字符串连接合并成一个新的字符串并返回
  （不建议使用，使用赋值操作符 `+`， `+=` 代替）
* `String.prototype.endsWith()` 判断当前字符串是否是以给定的字符串结尾的，并返回布尔值
* `String.prototype.includes()` 判断一个字符串中是否包含另一个字符串，并返回布尔值
* `String.prototype.indexOf()` 返回当前字符串中第一次出现指定值的索引，不存在则返回 -1
* `String.prototype.lastIndexOf()` 返回当前字符串中最后一次出现指定值的索引，不存在则返回 -1
* `String.prototype.match()` 检索返回一个字符串匹配正则表达式的结果
* `String.prototype.matchAll()` 返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器
* `String.prototype.padEnd()` 用一个字符串填充当前字符串，返回填充后达到指定长度的字符串，从末尾开始填充
* `String.prototype.padStart()` 用一个字符串填充当前字符串，返回填充后达到指定长度的字符串，从左侧开始填充
* `String.prototype.repeat()` 构造并返回一个新字符串，该字符串包含被链接在一起的制定数量的字符串。
* `String.prototype.replace()` 返回一个由替换字符串替换部分或所有的模式匹配项后的新字符串。
* `String.prototype.replaceAll()` 返回一个新字符串，新字符串所有满足模式匹配和被替换部分字符串都被替换
* `String.prototype.search()` 执行正则表达式和 字符串之间一个搜索匹配。
* `String.prototype.slice()` 提取某个字符串的一部分，并返回一个新的字符串
* `String.prototype.split()` 使用指定的分隔符字符串将一个字符串分割成子字符串数组，并返回。
* `String.prototype.startsWith()` 判断当前字符串是否以给定的字符串开头，并返回布尔值
* `String.prototype.substring()` 返回当前字符串从开始索引到结束索引之间的子集。
* `String.prototype.toLocaleLowerCase()` 根据任何指定区域语言环境设置的大小写映射，返回当前字符串被转换为小写格式的新字符串
* `String.prototype.toLocaleUpperCase()` 根据任何指定区域语言环境设置的大小写映射，返回当前字符串被转换为答谢格式的新字符串
* `String.prototype.toLowerCase()` 将当前字符串转为小写形式并返回
* `String.prototype.toUpperCase()` 将当前字符串转为大写形式并返回
* `String.prototype.trim()` 删除当前字符串两端的空白字符，并返回新的字符串
* `String.prototype.trimEnd()` 删除当前字符串末端的空白字符
* `String.prototype.trimStart()` 删除当前字符串开头的空白字符

---

---
url: /czxBlog/interview-question/y0d1fb60/index.md
---
# 模块打包器
::: tip 提问

1. 什么是模块打包器？
2. 有哪些常用的模块打包器？

:::

## 模块打包器

一个完整的前端项目，由各种各样的资源组成，包括 html文件、css文件、javascript文件、图片文件等等。
我们可以认为这些资源文件就是一个个的模块。
模块打包器可以通过分析入口文件引用了哪些模块，这些模块又引用了哪些模块，通过模块之间的相互引用，获得模块依赖关系图。
通过模块依赖关系图，将这些模块进行合并，打包，执行输出，形成一个完整的可执行的前端项目资源包。

## 常用的模块打包器

* webpack
* rollup
* parcel
* esbuild
* vite
* snowpack

---

---
url: /czxBlog/interview-question/y0fs63f1/index.md
---
# 在浏览器输入URL按下回车后发生了什么？
::: tip 提问

1. 在浏览器的地址栏输入一个 网址URL，并按下回车后，发生了什么？

:::

1. 首先对 URL地址进行解析，分析所需要使用的传输协议和请求的资源路径。如果输入的URL不合法，则认为不是一个有效的URL，
   按下enter时会将输入的内容传给搜索引擎；如果输入的URL合法，浏览器检查URL是否出现了非法字符，
   如果存在则对非法字符进行转译，然后进入到下个过程。

2. 浏览器判断当前URL所请求的资源是否在缓存里，如果有缓存且缓存没有失效，则直接返回缓存的资源，否则向服务器发起新的请求。

3. 向服务器发起请求前，需要获取当前域名的IP地址，首先先判断本地DNS缓存是否有该域名的DNS缓存，如果有则使用，如果没有，
   则向DNS服务器发起请求，获取域名的IP地址，然后把IP地址返回给浏览器。

4. 浏览器获得IP地址后，通过TCP协议进行建立连接的三次握手，成功后，浏览器与服务端建立连接。
   如果是HTTPS协议，还需要进行TSL四次握手，建立安全连接。

5. 浏览器发起的URL请求成功抵达服务器，服务器返回一个html文件作为响应。浏览器接收到html文件后，开始对html文件进行解析。

6. 浏览器首先根据html文件进行解析，构建DOM树，遇到 link标签发现CSS资源请求时，停止html解析，
   请求CSS资源并解析为 CSSOM树后，继续解析html文件。

7. 如果遇到 script 标签，则判断是否有声明 defer或async属性，如果都没有，则script的加载和执行都会阻塞html文档的解析，
   如果声明了defer属性，则并行加载javascript资源后等待html解析完成再执行；
   如果声明了async属性，则并行加载javascript资源，加载完成后立即执行并阻塞html文档解析。

8. 当 DOM树和CSSOM树都解析建立完成，浏览器根据它们构建渲染树，渲染树构建完成后，根据渲染树进行布局。

9. 浏览器布局完成后，使用浏览器的UI接口对网页进行绘制，此时整个页面就显示出来了。

10. 最后退出网页后， TCP开始断开连接的四次挥手过程。

---

---
url: /czxBlog/interview-question/y5w6l1js/index.md
---
# DOM节点操作
::: tip 提问
如何添加、移除、移动、复制、创建、查找节点？
:::

## 创建节点

* `document.createDocumentFragment(node)` 创建一个虚拟节点对象
* `document.createElement(node)` 创建一个新的元素
* `document.createTextNode(text)` 创建一个文本节点

## 添加、移除、替换、插入

* `appendChild(node)` 在元素的末尾插入一个子元素
* `removeChild(node)` 删除元素中的指定的元素
* `replaceChild(newNode, oldNode)` 使用 newNode 替换 oldNode
* `insertBefore(newNode, node)` 在 node元素之前插入一个 newNode

## 查找

* `getElementById(id)`
* `getElementsByName(name)`
* `getElementsByTagName(tagName)`
* `getElementsByClassName(className)`
* `querySelector(selector)`
* `querySelectorAll(selector)`

## 属性操作

* `getAttribute(key)`
* `setAttribute(key, value)`
* `hasAttribute(key)`
* `removeAttribute(key)`

---

---
url: /czxBlog/interview-question/y6r9lfa3/index.md
---
# computed和watch
::: tip 提问
`computed` 和 `watch` 的区别
:::

## 区别

* `computed` 是 计算一个新的属性，并将该属性挂载到 组件实例上。
* `watch` 是 监听已经存在且挂载在 组件实例上的数据， watch通过可以监听 计算属性。
* `computed` 是一个惰性求值的观察者，具有缓存性，只有第一次访问 computed属性,或者当依赖发生变化，，才会计算新的值。
* `watch` 是当监听的数据发生变化后，就会执行监听函数

---

---
url: /czxBlog/interview-question/yiutzl7y/index.md
---
# http2
::: tip 提问

1. http/2
2. http2有什么特性？

:::

## HTTP/2

HTTP/2 是对HTTP/1.1的升级，对HTTP/1.1做了优化。

## 特性

* 二进制协议

  在http/1.1 版中，报文的头信息必须是文本，数据体可是是文本或者二进制。
  而在HTTP/2中，头信息和数据体都是二进制，并且统称为`帧`。

* 多路复用

  HTTP/2 复用TCP连接，客户端和服务器都可以同一个TCP连接中并发请求或响应，且之间互不干扰。

* 数据流

  每个请求或响应的所有数据包，称为一个数据流。

* 头信息压缩

  头信息使用 gzip或 compress 压缩后再发送；客户端和服务器会同时维护一张头信息表，所有字段都会存入这张表，并生成
  一个索引号，对于相同字段，只发送索引号。

* 服务器推送

  允许服务器未经请求，主动向客户端发送资源。

---

---
url: /czxBlog/interview-question/ynqkgvbf/index.md
---
# 响应式原理
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问

1. 简单介绍一下Vue2的响应式原理

:::

* Vue会将传入`data` 选项的普通javascript对象，对它的所有 `property` 进行遍历，
  并使用 `Object.defineProperty` 把这些 `property` 全部转换为 `getter/setter`。

* Vue 通过 `getter/setter` 来实现监听数据的变化，通过 `getter` 进行依赖收集，通过`setter`观察数据变化。

* Vue 的每个组件实例，都对应一个 `Watcher` 实例，`Watcher` 会在组件渲染过程中，把 "接触" 过的数据 property
  记录为依赖，当依赖项的 `setter` 触发时，会通知 `Watcher` ,使关联的组件重新渲染。

* Vue 更新 DOM 是异步的，Vue 会开启一个队列，在同一个事件循环中，Vue会缓冲所有数据变更，
  如果同一个 `Watcher` 被触发多次，只会被推入到队列一次。在下一个事件循环`tick`中，
  Vue刷新队列并执行实际的工作。这种异步方式，可以去除重复的数据，可以避免不必要的计算和DOM的操作。

由于 Vue2 是通过 `Object.defineProperty` 实现的 数据劫持，

* 无法检测对象是否有新增和删除 `property`

  需要通过 `this.$set` 来添加为对象添加新的`property`，或者重新进行变量的对象赋值。

* 无法检测通过数组下标进行的赋值操作，无法检测 通过 `length` 修改数组长度

  需要通过 `this.$set` 为数组的子元素重新赋值，或者用 splice 方法替换子元素

* 需要对数组的方法进行重写，实现对数组的数据监听

---

---
url: /czxBlog/interview-question/yrfvyyod/index.md
---
# 组件通信方式
[![vue@3](https://img.shields.io/badge/vue-%403-brightgreen)](https://staging-cn.vuejs.org/)

::: tip 提问
vue3 有哪几种组件通信方式？
:::

在vue2 中能够使用的 组件通信方式，在 vue3 中同样的都能够使用，但有部分有区别，同时，还扩展了其他的通信方式

[vue2 组件通信方式](/interview-question/1ryrldbc/)

## 组件通信方式

::: info
仅列出跟vue2有区别的部分，以及新增的方式
:::

### $parent / refs / expose

相比于 vue3 ，vue2 删除了 `$children` ，可以使用 `refs` 获取子组件的实例。

子组件还可以通过 `expose` 选项 控制允许哪些内容暴露给父组件

适用场景：

* 父子组件通信

### $attr

在 vue3 中， 已经移除了 `$listener`， 并将其合并到了 `$attr` 中，所以可以直接使用 `attr`向后代组件传递数据

### 共享响应式对象

使用 `reactive` 创建一个响应式对象，并在不同组件中导入它。

这种方式可以创建一个简单的共享状态管理， 但由于任何导入它的组件都可以对其进行修改，这种做法不好维护。
而且仅适用于纯客户端前端页面，如果需要使用 `SSR`，那么这种方式可能会导致 **跨请求状态污染**

适用场景：

* 父子组件通信
* 兄弟组件通信
* 隔代组件通信

这种方式虽然可以进行各种组件间关系的通信，但不适合用于有复杂变更状态的场景。

### Pinia

一个 替代 `Vuex` 的 状态管理库。

---

---
url: /czxBlog/interview-question/z7aq1w36/index.md
---
# 代码检查工具
::: tip 提问

1. eslint
2. prettier
3. stylelint

:::

## eslint

eslint 是一个 javascript 代码风格检查工具，提供了完全插件化的模式，允许自定义各种各样的规则。

比较通用的开源配置有：

* eslint-config-standard
* eslint-config-airbnb
* eslint-config-vue
* eslint-config-prettier

## prettier

prettier 是一个代码格式化工具，支持多数编程语言，prettier自身提供了一种通用代码风格，并仅支持少量的配置。
这样做的好处是，当选择prettier时，就已经选择了使用它的代码风格，避免了团队成员再去纠结代码风格的某些规则。

## stylelint

stylelint 是一个 类似于 eslint 的专注于 css 代码风格检查工具。

同时还支持对 LESS、 SCSS 的代码风格检查

## 使用

过去在使用 以上的 代码风格工具时，比如在 使用 webpack作为构建工具的项目中，会通过 webpack plugin 或 loader，将
代码风格工具内置到 开发时进行实时检查，每次对代码的修改，都会通过 webpack plugin 或 loader 调用 工具进行代码检查。

但是这样做带来了不必要的开发时时间开销。

目前个人在使用时，不再 通过 webpack plugin 去添加 代码风格检查支持。 而是借助于 编辑器插件，已经 git hook。

比如，在 VSCode 中安装 eslint、prettier、stylelint 插件，并设置在文件修改时对当前文件进行检查。
这样的好处是，不影响 webpack的开发时编译速度，更好的利用 VSCode相关插件的错误提示支持。

再利用 git hook，在 pre-commit 阶段启动 代码风格检查工具，对整个项目进行检查，通过后再提交和推送。

---

---
url: /czxBlog/interview-question/z7vgfuwo/index.md
---
# 指令
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问

1. 什么是指令？
2. 如何自定义指令？

:::

## 指令

指令是用于 封装对于底层DOM元素的操作。

## 自定义指令

使用 `Vue.directive()` 注册全局自定义指令，也可以在 组件示例的 directives 注册局部自定义指令。

指令提供了五个钩子函数

* `bind` 指令第一次绑定到元素时调用
* `inserted` 被绑定元素第一次插入到父节点时调用
* `update` 所在组件的 VNode 更新时调用
* `componentUpdated` 指令所在组件的VNode及其子VNode全部更新后调用
* `unbind` 指令与元素解绑时调用，只调用一次。

---

---
url: /czxBlog/interview-question/zs2xi1mk/index.md
---
# 对浏览器的理解
::: tip 提问

1. 说说你对浏览器的理解

:::

浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，
资源的格式通常是 HTML， 也包括 PDF、image 以及其他格式，
用户使用 URI（Uniform Resource Identifier 统一资源标志符）来制定请求资源的位置。

HTML 和 CSS 规范中规定了浏览器解释html文档的方式，由W3C组织对这些规范进行维护，
W3C是负责制定web标准的组织。

但是浏览器厂商 对规范的遵循并不完善，且有各自的扩展和补充，这为web开发带来了严重的兼容性问题。

浏览器可以分为两个部分，shell 和 内核。

* shell 指浏览器的外壳，例如菜单、工具栏等。
  主要是给用户提供用户界面操作，参数设置等，它是调用内核来实现各种功能的。

* 内核 是浏览器的核心。内核是基于标记语言显示内容的程序或模块。

也有一些浏览器并不区分外壳和内核，从 mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。

---

---
url: /czxBlog/memorandum/index.md
---
# 备忘录

---

---
url: /czxBlog/memorandum/cargo/index.md
---
```sh :no-line-numbers
# 显示版本信息以确认 Cargo 已安装
cargo version
# 创建新项目 二进制程序

cargo new --bin
# 创建新项目 库
cargo new --lib

# 在项目中运行单元测试
cargo test
# 快速编译项目，无需生成二进制文件来检查错误
cargo check
# 自动格式化代码
cargo fmt
# 编译一个项目
cargo build
# 一步编译和运行项目
cargo run
# Linter 检查错误
cargo clippy --all-targets -- --D warnings
# 检查代码覆盖率
cargo tarpaulin --ignore-tests
```

## 安装/升级

适用于 Linux 和  MacOS

```sh :no-line-numbers
curl -sSf https://static.rust-lang.org/rustup.sh | sh
```

在 Windows 中，下载 [rustup-init.exe](https://win.rustup.rs/) 并运行。

## 切换源

配置文件： `~/.cargo/config`

```toml
[source.crates-io]
registry = "https://github.com/rust-lang/crates.io-index"
replace-with = 'tuna' # 👈 如果需要提交包注释配置源

[source.tuna]
registry = "https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"
# registry = "git://mirrors.ustc.edu.cn/crates.io-index"
```

切换源需要删除缓存目录

```sh :no-line-numbers
rm -rf ~/.cargo/.package-cache   # ⚠️ 删除缓存目录内容
```

---

---
url: /czxBlog/memorandum/git/index.md
---
## 分支

```sh :no-line-numbers
# 删除本地存在远程不存在的分支
git remote prune origin

# 删除已经合并到 master 的分支
git branch --merged master | grep -v '^\*\|  master' | xargs -n 1 git branch -d

# 查看远程分支和本地分支的对应关系
git remote show origin
```

## 提交

```sh :no-line-numbers
# 重写最后一次提交信息
git commit --amend -m "new message"

# 修改最新的提交而不更改提交消息
git commit --amend --no-edit
```

## 配置

```sh :no-line-numbers
# 获取配置帮助信息
git help config
# 配置全局用户名
git config --global user.name "name"
# 配置全局邮箱
git config --global user.email "email"
# 配置全局颜色，对 git 输出进行美化
git config --global color.ui auto
# 在文本编辑器中编辑全局配置文件
git config --global --edit
# 删除全局配置
git config --global --unset <entry-name>
# 查看本地 repo 配置
git config --list
```

### 解决中文乱码

```sh :no-line-numbers
git config --global core.quotepath false
```

不再将 文件权限变更 作为改动

```sh :no-line-numbers
git config core.fileMode false
```

### 设置大小写敏感

```sh :no-line-numbers
# 大小写敏感
git config --get core.ignorecase
# 远程有俩相同目录，通过这种方式清除掉，然后提交记录
git rm -r --cached <dirOrFile>
```

### 代理

```sh :no-line-numbers
# 查看代理
git config --global http.proxy
git config --global https.proxy
git config --global socks.proxy

# 设置代理
# 适用于 privoxy 将 socks 协议转为 http 协议的 http 端口
git config --global http.proxy http://127.0.0.1:1080
git config --global https.proxy http://127.0.0.1:1080
git config --global socks.proxy 127.0.0.1:1080

# 取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy
git config --global --unset socks.proxy

# 只对 github.com 设置代理
git config --global http.https://github.com.proxy socks5://127.0.0.1:1080
git config --global https.https://github.com.proxy socks5://127.0.0.1:1080

# 取消 github.com 代理
git config --global --unset http.https://github.com.proxy
git config --global --unset https.https://github.com.proxy
```

## 统计查询

```sh :no-line-numbers
# 提交数统计
git log --oneline | wc -l
# 查看文件内容的提交者
git blame <file-name>
# 仓库总大小
git count-objects -vH
# 仓库大小
git ls-files | xargs -r du -hs
# 在 commit log 中查找内容
git log --all --grep='<given-text>'
```

### 查看 个人代码量

```sh :no-line-numbers
# username 需要修改为 个人用户名
git log --author="username" --pretty=tformat: --numstat | awk \
'{ add += $1; subs += $2; loc += $1 - $2 } END { printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc }' -
```

### 每人增删行数

```sh :no-line-numbers
git log --format='%aN' | sort -u |\
  while read name; do echo -en "$name\t";\
  git log --author="$name" --pretty=tformat: --numstat | awk \
  '{ add += $1; subs += $2; loc += $1 - $2 } END { printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc }' -; done
```

### 查看提交者排名

```sh :no-line-numbers
# 取前十个的排名
git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 10
```

## submodule 子模块

```sh :no-line-numbers
# 添加包含子模块的仓库
git clone <repo_url> --recursive
# 查看当前仓库中的子模块
git submodule status

# 添加子模块
git submodule add <repo_url> <submodule_path>

# 初始化子模块
git submodule init

# 更新子模块
git submodule update --remote

# 删除子模块
git submodule deinit <path_to_submodule>
git rm <path_to_submodule>
```

切换到子模块的特定提交

```sh :no-line-numbers
cd <path_to_submodule>
git checkout <commit_hash>
```

切换到父仓库的特定提交，并更新子模块

```sh :no-line-numbers
git submodule update --remote
git checkout <commit_hash>
```

获取并切换子模块的最新标签

```sh :no-line-numbers
cd <path_to_submodule>
git fetch --tags
git checkout $(git describe --tags $(git rev-list --tags --max-count=1))
```

子模块递归

```sh :no-line-numbers
# 添加所有已存在的子模块
git submodule foreach --recursive git submodule add <repo_url>

# 更新所有子模块到最新提交
git submodule foreach --recursive git pull origin master

# 检出特定的子模块路径
git submodule foreach --recursive git checkout <branch_name>

# 获取仓库中的所有子模块变化
git submodule foreach --recursive git fetch

# 获取并合并子模块的远程分支
git submodule foreach --recursive git pull origin <branch_name>

# 将子模块还原到父仓库中的初始提交
git submodule foreach --recursive git checkout .

# 获取子模块的更新并忽略本地修改
git submodule foreach --recursive git fetch --all
git submodule foreach --recursive git reset --hard origin/master
```

---

---
url: /czxBlog/memorandum/git/emoji/index.md
---
# git emoji
## 概述

在 git 提交信息中受支持的 emoji 。

## 使用

**输入：**

```sh
git commit -m "feat: :rocket: add new feature"
```

**输出：**

```txt
feat: 🚀 add new feature
```

## emoji 列表

:::important 数据源 [gitmoji](https://github.com/carloscuesta/gitmoji)
:::

---

---
url: /czxBlog/memorandum/grep/index.md
---
# grep
## 参数

|                 |                                         | 说明                                                                                                 |
| --------------- | --------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| `-a`            | `--text`                                | 不要忽略二进制数据。                                                                                 |
| `-A <显示行数>` | `--after-context=<显示行数>`            | 除了显示符合范本样式的那一行之外，并显示该行之后的内容。                                             |
| `-b`            | `--byte-offset`                         | 在显示符合范本样式的那一行之外，并显示该行之前的内容。                                               |
| `-B <显示行数>` | `--before-context=<显示行数>`           | 除了显示符合样式的那一行之外，并显示该行之前的内容。                                                 |
| `-c`            | `--count`                               | 计算符合范本样式的列数。                                                                             |
| `-C <显示行数>` | `--context=<显示行数>` 或 `-<显示行数>` | 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。                                           |
| `-d<进行动作>`  | `--directories=<动作>`                  | 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。                 |
| `-e <范本样式>` | `--regexp=<范本样式>`                   | 指定字符串作为查找文件内容的范本样式。                                                               |
| `-E`            | `--extended-regexp`                     | 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。                                 |
| `-f <范本文件>` | `--file=<规则文件>`                     | 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。 |
| `-F`            | `--fixed-regexp`                        | 将范本样式视为固定字符串的列表。                                                                     |
| `-G`            | `--basic-regexp`                        | 将范本样式视为普通的表示法来使用。                                                                   |
| `-h`            | `--no-filename`                         | 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。                                           |
| `-H`            | `--with-filename`                       | 在显示符合范本样式的那一列之前，标示该列的文件名称。                                                 |
| `-i`            | `--ignore-case`                         | 忽略字符大小写的差别。                                                                               |
| `-l`            | `--file-with-matches`                   | 列出文件内容符合指定的范本样式的文件名称。                                                           |
| `-L`            | `--files-without-match`                 | 列出文件内容不符合指定的范本样式的文件名称。                                                         |
| `-n`            | `--line-number`                         | 在显示符合范本样式的那一列之前，标示出该列的编号。                                                   |
| `-P`            | `--perl-regexp`                         | PATTERN 是一个 Perl 正则表达式                                                                       |
| `-q`            | `--quiet或--silent`                     | 不显示任何信息。                                                                                     |
| `-R`/`-r`       | `--recursive`                           | 此参数的效果和指定“-d recurse”参数相同。                                                             |
| `-s`            | `--no-messages`                         | 不显示错误信息。                                                                                     |
| `-v`            | `--revert-match`                        | 反转查找。                                                                                           |
| `-V`            | `--version`                             | 显示版本信息。                                                                                       |
| `-w`            | `--word-regexp`                         | 只显示全字符合的列。                                                                                 |
| `-x`            | `--line-regexp`                         | 只显示全列符合的列。                                                                                 |
| `-y`            |                                         | 此参数效果跟“-i”相同。                                                                               |
| `-o`            |                                         | 只输出文件中匹配到的部分。                                                                           |
| `-m <num>`      | `--max-count=<num>`                     | 找到num行结果后停止查找，用来限制匹配行数                                                            |

## 规则表达式

```sh :no-line-numbers
^      # 锚定行的开始 如：'^grep'匹配所有以grep开头的行。
$      # 锚定行的结束 如：'grep$' 匹配所有以grep结尾的行。
.      # 匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。
*      # 匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。
.*     # 一起用代表任意字符。
[]     # 匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。
[^]    # 匹配一个不在指定范围内的字符，如：'[^A-Z]rep' 匹配不包含 A-Z 中的字母开头，紧跟 rep 的行
(..)   # 标记匹配字符，如'(love)'，love被标记为1。
<      # 锚定单词的开始，如:'<grep'匹配包含以grep开头的单词的行。
>      # 锚定单词的结束，如'grep>'匹配包含以grep结尾的单词的行。
x{m}   # 重复字符x，m次，如：'0{5}'匹配包含5个o的行。
x{m,}  # 重复字符x,至少m次，如：'o{5,}'匹配至少有5个o的行。
x{m,n} # 重复字符x，至少m次，不多于n次，如：'o{5,10}'匹配5--10个o的行。
\w     # 匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。
\W     # \w的反置形式，匹配一个或多个非单词字符，如点号句号等。
\b     # 单词锁定符，如: '\bgrep\b'只匹配grep。
```

---

---
url: /czxBlog/memorandum/nginx/index.md
---
## 服务管理

```sh :no-line-numbers
sudo systemctl status nginx  # nginx当前状态
sudo systemctl reload nginx  # 重新加载 nginx
sudo systemctl restart nginx # 重启nginx

sudo nginx -t   # 检查语法
nginx           # 启动
nginx -s reload # 重启
nginx -s stop   # 关闭进程
nginx -s quit   # 平滑关闭nginx
nginx -V        # 查看nginx的安装状态
```

## 全局变量

| 变量                | 说明                                                            |
| ------------------- | --------------------------------------------------------------- |
| `$args`             | 这个变量等于请求行中的参数，同 `$query_string`                  |
| `$remote_port`      | 客户端的端口                                                    |
| `$content_length`   | 请求头中的 `Content-length` 字段                                |
| `$remote_user`      | 已经经过 `Auth Basic Module` 验证的用户名                       |
| `$content_type`     | 请求头中的 `Content-Type` 字段                                  |
| `$request_filename` | 当前请求的文件路径，由 `root` 或alias指令与URI请求生成          |
| `$document_root`    | 当前请求在 `root` 指令中指定的值                                |
| `$scheme`           | HTTP方法（如http，https）                                       |
| `$host`             | 请求主机头字段，否则为服务器名称                                |
| `$hostname`         | 主机名                                                          |
| `$http_user_agent`  | 客户端`agent`信息                                               |
| `$http_cookie`      | 客户端`cookie`信息                                              |
| `$server_protocol`  | 请求使用的协议，通常是`HTTP/1.0`或`HTTP/1.1`                    |
| `$server_addr`      | 服务器地址，在完成一次系统调用后可以确定这个值                  |
| `$server_name`      | 服务器名称                                                      |
| `$server_port`      | 请求到达服务器的端口号                                          |
| `$limit_rate`       | 这个变量可以限制连接速率                                        |
| `$request_method`   | 客户端请求的动作，如 GET/POST                                   |
| `$request_uri`      | 包含请求参数的原始URI，不包含主机名，如：`/foo/bar.php?arg=baz` |
| `$remote_addr`      | 客户端的IP地址                                                  |
| `$uri`              | 不带请求参数的当前URI，`$uri`不包含主机名，如 `/foo/bar.html`   |
| `$document_uri`     | 与 `$uri` 相同                                                  |
| `$nginx_version`    | `nginx` 版本                                                    |

## 监听端口

```nginx :no-line-numbers
server {
  listen 80;      # 标准 HTTP 协议
  listen 443 ssl; # 标准 HTTPS 协议
  listen 443 ssl http2; # 对于 http2
  listen [::]:80; # 使用 IPv6 在 80 上收听
  # 仅收听使用 IPv6
  listen [::]:80 ipv6only=on;
}
```

## 域名 (server\_name)

```nginx :no-line-numbers
server {
  # 监听 example.com
  server_name example.com;
  # 监听多个域
  server_name example.com www.example.com;
  # 监听所有子域
  server_name *.example.com;
  # 监听所有顶级域
  server_name example.*;
  # 监听未指定的主机名（监听 IP 地址本身）
  server_name "";
}
```

## 负载均衡

### 简单实例

```nginx :no-line-numbers
upstream node_js {
  server 0.0.0.0:3000;
  server 0.0.0.0:4000;
  server 127.155.142.421;
}
```

### 权重

```nginx :no-line-numbers
upstream test {
  server localhost:8080 weight=9;
  server localhost:8081 weight=1;
}
```

### ip\_hash

解决负载均衡 `session` 的问题

```nginx:no-line-numbers {2}
upstream test {
  ip_hash;
  server localhost:8080;
  server localhost:8081;
}
```

### fair

响应时间短的优先分配

```nginx:no-line-numbers {2}
upstream backend {
  fair;
  server localhost:8080;
  server localhost:8081;
}
```

### url\_hash

按访问url的hash结果来分配请求

```nginx:no-line-numbers {2,3}
upstream backend {
  hash $request_uri;
  hash_method crc32;
  server localhost:8080;
  server localhost:8081;
}
```

### keepalive

激活缓存以连接到上游服务器

```nginx:no-line-numbers {4}
upstream memcached_backend {
    server 127.0.0.1:11211;
    server 10.0.0.2:11211;
    keepalive 32;
}
```

### server 可选参数

| 参数名         | 说明                             |
| -------------- | -------------------------------- |
| `weight`       | 访问权重数值越高，收到请求越多   |
| `fail_timeout` | 指定的时间内必须提供响应         |
| `max_fails`    | 尝试失败服务器连接的最大次数     |
| `down`         | 标记一个服务器不再接受任何请求   |
| `backup`       | 有服务器宕机，标记的机器接收请求 |

## 反向代理

```nginx :no-line-numbers
server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://0.0.0.0:3000;
    # 其中 0.0.0.0:3000 是绑定在
    # 0.0.0.0端口3000 列表上的 Node.js 服务器
  }
}
```

负载均衡 + 反向代理

```nginx :no-line-numbers
upstream node_js {
  server 0.0.0.0:3000;
  # 其中 0.0.0.0:3000 是绑定在
  # 0.0.0.0端口3000 列表上的 Node.js 服务器
}

server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://node_js;
  }
}
```

升级连接（适用于支持 WebSockets 的应用程序）

```nginx :no-line-numbers
upstream node_js {
  server 0.0.0.0:3000;
}

server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://node_js;
    proxy_redirect off;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;

  }
}
```

## 跨域

```nginx :no-line-numbers
server {
  listen 80;
  server_name api.xxx.com;

  add_header 'Access-Control-Allow-Origin' '*';
  add_header 'Access-Control-Allow-Credentials' 'true';
  add_header 'Access-Control-Allow-Methods' 'GET,POST,HEAD';

  location / {
    proxy_pass http://127.0.0.1:3000;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host  $http_host;
  }
}
```

重定向 URI

```nginx :no-line-numbers
upstream test {
  server 127.0.0.1:8080;
  server localhost:8081;
}
server {
  listen 80;
  server_name api.xxx.com;
  location / {
    root  html;                   # 去请求../html文件夹里的文件
    index  index.html index.htm;  # 首页响应地址
  }
  # 用于拦截请求，匹配任何以 /api/开头的地址，
  # 匹配符合以后，停止往下搜索正则。
  location ^~/api/{
    # 代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用
    # 例如www.a.com/api/msg?meth=1&par=2重写，只对/api/msg重写。
    # rewrite后面的参数是一个简单的正则 ^/api/(.*)$，
    # $1代表正则中的第一个()，$2代表第二个()的值，以此类推。
    rewrite ^/api/(.*)$ /$1 break;

    # 把请求代理到其他主机
    # 其中 http://www.b.com/ 写法和 http://www.b.com写法的区别如下
    # 如果你的请求地址是他 http://server/html/test.jsp
    # 配置一： http://www.b.com/ 后面有“/”
    #         将反向代理成 http://www.b.com/html/test.jsp 访问
    # 配置一： http://www.b.com 后面没有有“/”
    #         将反向代理成 http://www.b.com/test.jsp 访问
    proxy_pass http://test;

    # 如果 proxy_pass  URL 是 http://a.xx.com/platform/ 这种情况
    # proxy_cookie_path应该设置成 /platform/ / (注意两个斜杠之间有空格)。
    proxy_cookie_path /platfrom/ /;

    # 设置 Cookie 头通过
    proxy_pass_header Set-Cookie;
  }
}
```

## 屏蔽 IP

```nginx :no-line-numbers
可以放到 http, server, location, limit_except 语句块

include blockip.conf;
在 blockip.conf 里面输入内容，如：

deny 165.91.122.67;

deny IP;            # 屏蔽单个 ip 访问
allow IP;           # 允许单个 ip 访问
deny all;           # 屏蔽所有 ip 访问
allow all;          # 允许所有 ip 访问
deny 123.0.0.0/8;   # 屏蔽整个段即从 123.0.0.1 到 123.255.255.254 访问的命令
deny 124.45.0.0/16; # 屏蔽IP段即从 123.45.0.1 到 123.45.255.254 访问的命令
deny 123.45.6.0/24; # 屏蔽IP段即从 123.45.6.1 到 123.45.6.254 访问的命令

# 如果你想实现这样的应用，除了几个IP外，其他全部拒绝
allow 1.1.1.1;
allow 1.1.1.2;
deny all;
```

## 代理转发重写路径

```nginx :no-line-numbers
location ^~/api/upload {
  rewrite ^/(.*)$ /wfs/v1/upload break;
  proxy_pass http://wfs-api;
}
```

## 图片防盗链

```nginx :no-line-numbers
location ~* \.(gif|jpg|png|swf|flv)$ {
  root html;

  valid_referers none blocked *.nginx.com;

  if ($invalid_referer) {
    rewrite ^/ www.nginx.cn;
    # return 404;
  }
}
```

## 屏蔽文件目录

```nginx :no-line-numbers
通用备份和归档文件

location ~* "\.(old|orig|original|php#|php~|php_bak|save|swo|aspx?|tpl|sh|bash|bak?|cfg|cgi|dll|exe|git|hg|ini|jsp|log|mdb|out|sql|svn|swp|tar|rdf)$" {
    deny all;
}
拒绝访问 .git 和 .svn 目录

location ~ (.git|.svn) {
    deny all;
}
拒绝访问隐藏文件和目录

location ~ /\.(?!well-known\/) {
    deny all;
}
```

## Gzip 配置

```nginx :no-line-numbers
gzip  on;
gzip_buffers 16 8k;
gzip_comp_level 6;
gzip_http_version 1.1;
gzip_min_length 256;
gzip_proxied any;
gzip_vary on;
gzip_types
    text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml
    text/javascript application/javascript application/x-javascript
    text/x-json application/json application/x-web-app-manifest+json
    text/css text/plain text/x-component
    font/opentype application/x-font-ttf application/vnd.ms-fontobject
    image/x-icon;
gzip_disable  "msie6";
```

---

---
url: /czxBlog/memorandum/pm2/index.md
---
## 启动

启动 node 进程

```sh :no-line-numbers
pm2 start app.js

pm2 ping # 确保 pm2 守护进程已经启动
```

启动其它应用程序

```sh :no-line-numbers
pm2 start bash.sh
pm2 start python-app.py --watch
pm2 start binary-file -- --port 1520
```

## 流程管理

```sh :no-line-numbers
pm2 restart app_name # 重启 app_name
pm2 reload app_name  # 重载 app_name
pm2 stop app_name    # 停止 app_name
pm2 delete app_name  # 删除 app_name
```

可以将 `app_name` 替换为：

* `all`: 表示所有进程
* `id`: 指定特定 id 的进程

## 检查状态

列出 PM2 的所有应用状态

```sh :no-line-numbers
pm2 [list|ls|status]

pm2 list        # 显示所有进程状态
pm2 jlist       # 以原始 JSON 格式打印进程列表
pm2 prettylist  # 以美化JSON打印进程列表
pm2 describe 0  # 显示有关特定进程的所有信息
```

## 日志

```sh :no-line-numbers
pm2 logs
pm2 logs --lines 200 # 旧日志
pm2 flush         # 清空所有日志文件
pm2 reloadLogs    # 重新加载所有日志
```

终端仪表板

```sh :no-line-numbers
pm2 monit
```

Web 的仪表板

```sh :no-line-numbers
pm2 plus
```

## 集群模式

```sh :no-line-numbers
# 0 / max 表示根据 CPU 数量启动多个进程
pm2 start app.js -i 0
pm2 start app.js -i max # 等同 0 ，已弃用
```

## 常用命令行参数

```sh :no-line-numbers
--name <app_name> # 指定应用名称
--watch # 监听文件更新并重启应用
--max-memory-restart <200MB> # 设置应用重新加载的最大内存阈值
--log <log_path> # 指定日志路径
--restart-delay <delay in ms> # 自动重启之间的延迟
--time # 带时间前缀的日志
--no-autorestart # 不自动重启
--cron <cron_pattern> # 指定 cron 强制重启
```

## 更新 PM2

```sh :no-line-numbers
npm install pm2@latest -g
pm2 update  # 更新内存中的 pm2
```

---

---
url: /czxBlog/memorandum/ssh/index.md
---
## 配置位置

| 位置                     |           说明 |
| :----------------------- | -------------: |
| `/etc/ssh/ssh_config`    | 系统范围的配置 |
| `~/.ssh/config`          | 用户特定的配置 |
| `~/.ssh/id_{type}`       |           私钥 |
| `~/.ssh/id_{type}.pub`   |           公钥 |
| `~/.ssh/known_hosts`     |       登录主机 |
| `~/.ssh/authorized_keys` |   授权登录密钥 |

## 执行远程命令

```sh :no-line-numbers
ssh root@192.168.1.5 'ls -l'

# 调用本地脚本
ssh root@192.168.1.5 bash < script.sh

# 从服务器压缩和下载
ssh root@192.168.1.5 "tar cvzf - ~/source" > output.tgz
```

## SCP

| 命令          |                      说明 |
| :------------ | ------------------------: |
| `scp -r`      |          递归复制整个目录 |
| `scp -C`      |                  压缩数据 |
| `scp -v`      |              打印详细信息 |
| `scp -P 8080` |              使用特定端口 |
| `scp -B`      | 批处理模式 *（防止密码）* |
| `scp -p`      |            保留时间和模式 |

从远程复制到本地

```sh :no-line-numbers
scp user@server:/dir/file.ext dest/
```

两台服务器之间的副本

```sh :no-line-numbers
scp user@server:/file user@server:/dir
```

从本地复制到远程

```sh :no-line-numbers
scp dest/file.ext user@server:/dir
```

复制整个文件夹

```sh :no-line-numbers
scp -r user@server:/dir dest/
```

复制文件夹中的所有文件

```sh :no-line-numbers
scp user@server:/dir/* dest/
```

从服务器文件夹复制到当前文件夹

```sh :no-line-numbers
scp user@server:/dir/* .
```

## keygen

```sh :no-line-numbers
ssh-keygen -t rsa -b 4096 -C "your@mail.com"
```

* `-t` 指定密钥类型, `rsa | ed25519 | dsa | ecdsa`
* `-b` 指定密钥长度
* `-C` 指定注释

指定文件名

```sh :no-line-numbers
ssh-keygen -f ~/.ssh/filename
```

从私钥生成公钥

```sh :no-line-numbers
ssh-keygen -y -f private.key > public.pub
```

更改私钥密码

```sh :no-line-numbers
ssh-keygen -p -f ~/.ssh/id_rsa
```

从 known\_hosts 搜索

```sh :no-line-numbers
ssh-keygen -F <ip/hostname>
```

从 known\_hosts 中删除

```sh :no-line-numbers
ssh-keygen -R <ip/hostname>
```

---

---
url: /czxBlog/note/vuepress-theme-plume/index.md
---
# vuepress-theme-plume
::: tip
主题说明文档已迁移至 <https://theme-plume.vuejs.press/>。

:::

---

---
url: /czxBlog/projects/index.md
---
# Projects
## 开源项目

### vite-plugin-mock-dev-server

**说明：**

`vite-plugin-mock-dev-server` 专注于在 `Vite` 开发环境下 提供 Mock 服务。
通过 vite 内置的 `http` 和 `http-proxy` 服务，以 `middleware` 的方式，对 `server.proxy` 配置的代理路径
进行二次拦截，命中规则后，返回配置的 `mock data` 。

你可以在 mock配置文件中使用`node` 任意第三方模块。 这表示，你可以使用如 `mockjs` / `faker-js` 等库帮助生成 `mock data`。

插件支持响应多种数据类型包括 `text/json/Buffer/ReadStream`等，还支持设置 headers、cookies。

插件还支持模拟 `WebSocket`，可以轻松的实现在本地开发环境调试 `WebSocket` 服务。

[查看 **vite-plugin-mock-dev-server** 使用文档](https://vite-plugin-mock-dev-server.netlify.app/){.read-more}

***

### vuepress-theme-plume

**说明：**

vuepress-theme-plume 是一个基于 VuePress 的主题。适用于 博客、文档 和 知识笔记 。

与 vuepress 默认主题相比：

* 大幅度优化了界面、交互，更具美观度，更好的用户体验。
* 同时，还添加了大量的丰富实用的功能，如 代码分组、提示容器、任务列表、数学公式、代码演示、 内容搜索、文章评论、加密 等。
* 大幅度简化了配置，更易于使用，同时还保留了丰富灵活的配置项，满足个性化的需求。

plume 主题尽可能的内置你可能需要的功能，以及搭建站点所需要的一般性配置，您无需关注这些细节。 目的是，让您更专注于 内容的创作，更好的表达你的想法，享受 Markdown 增强语法带来的便利。

[查看 **vuepress-theme-plume** 使用文档](https://theme-plume.vuejs.press/){.read-more}

***

### vite-plugin-image-placeholder

**说明：**

在项目开发过程中，为未准备好图片资源的内容区域，生成占位图片。

***

### rspack-plugin-mock

**说明：**

`vite-plugin-mock-dev-server` 对标 `vite-plugin-mock-dev-server` 在 `rspack/rsbuild` 上的实现， 专注于在 `rspack / rsbuild` 开发环境下 提供 Mock 服务。

[查看 **rspack-plugin-mock** 使用文档](https://github.com/pengzhanbo/rspack-plugin-mock){.read-more}

***

### vulcan

**说明：**

基于 vite + vue3 的项目模板，帮助快速创建 Mobile Web 应用。

***

### @any-hooks/solid

**说明：**

一套高质量可靠的 Solidjs Hooks 库。

[使用文档](https://solid-hooks.netlify.app/en-US)

***

### stylelint-define-config

**说明：**

为 `stylelint` 提供 `defineConfig` 配置类型帮助，可以在 `stylelint.config.js` 中配置自定义配置。

***

### @pengzhanbo/utils

**说明：**

一个常用的工具类库, 无依赖， 任何运行时。

[使用文档](http://jsr.io/@pengzhanbo/utils)

***

### geo-pattern-ts

**说明：**

生成漂亮的SVG图案。

[使用文档](https://github.com/pengzhanbo/geo-pattern-ts) | [在线演示](geo-pattern.netlify.app)

***

### chinese-simple2traditional

**说明：**

中文繁简体转换。

* 内置字库，零依赖，支持任何运行环境。
* 支持 3077+ 常用简体字 和 4919+ 繁体字/异体字。
* 支持 3577+ 简体短语转繁体的特殊情况。
* 支持 117+ 繁体短语/异体短语 转简体的特殊情况。

[使用文档](https://github.com/pengzhanbo/chinese-simple2traditional) | [在线演示](https://han-convert.netlify.app/)

***

### caniuse-embed

**说明：**

基于 `Astro` 开发的 `caniuse-embed` 组件。

从 [caniuse.com](https://caniuse.com/) 和 [mozilla's browser compat data](https://github.com/mdn/browser-compat-data) 嵌入最新数据。

显示10个主要浏览器多个版本的功能支持数据。可配置、可靠且完全响应。

[使用文档](https://caniuse-embed.vercel.app/zh-CN)

***

### spearjs

**说明：**

一个 低代码平台。使用 vite 构建。前端基于 vue， 后端基于 nestjs。

---

---
url: /czxBlog/recommend/index.md
---
# 个人知识库
## 面试相关

* 推荐 **`《Head First HTML与CSS（第2版）》`**

---

---
url: /czxBlog/sites-collect/index.md
---
# 站点导航
## Runtime

## Registry

## 库/框架

***

***

***

### 微前端

***

### CSS

### Vue

***

### React

***

***

***

***

### 小程序

## 图标

## 素材

## 桌面应用开发

## 跨平台开发

## 构建工具

### 站点生成工具

## 社区

### 周刊

### 博客

## Git

## 工具

### javascript

### css

***

### 正则

### shell

### 开源

## 服务

## Test

## Chart

## CDN

---

---
url: /czxBlog/type-challenges/index.md
---
# Type Challenges
:::warning 施工中...
:::

## 简介

[type-challenges](https://github.com/type-challenges/type-challenges) 是一个能够让你更好的
了解 `typescript` 类型系统的开源项目。

本笔记整理记录了我个人在解答这个项目中的挑战，所使用的解题思路，回答，以及相关的 `typescript` 知识点。

根据 [type-challenges](https://github.com/type-challenges/type-challenges) 的题目难度，
分为了五个难度：

* `热身`  1 / 1
* `简单`  13 / 13
* `中等`  57 / 103
* `困难`  0 / 43
* `地狱`  0 / 14

请从上到下依次阅读本笔记，以便更好的了解 `type-challenges` 的挑战。

如果你是新手，或者仅想在你的日常工作中用好 `typescript`，那么阅读到 `中等` 难度的题目就足够了。
从 `困难` 难度开始，这些题目可能更适合于 想要深入理解某些库或框架的类型设计，或者想要编写自己的类型工具的开发者。

## VSCode 插件

[VS Code 插件 **Type-Challenges**](https://marketplace.visualstudio.com/items?itemName=YRM.type-challenges){.read-more}

插件提供了开源项目的所有题目，以及测试用例，可以通过在 `VSCode` 中安装该插件，在 `VSCode` 中进行答题，
以获得良好的 编辑器类型检查帮助。

## 说明

在这个项目中，每一个挑战都将作为单独的文章进行编写。其内容包括:

* **题目**：提出的挑战
* **解题思路**
* **答案**
* **验证**：借助 [typescript twoslash](https://theme-plume.vuejs.press/guide/markdown/twoslash/) 的帮助，你可以在这里查看答案中每一处的类型，以及验证结果是否符合预期
* **参考**：列出这个挑战需要使用的 `typescript` 知识点

## 类型工具

在 验证 过程中，将会使用到以下的类型工具：

```ts
/**
 * 类型断言
 */
export type Expect<T extends true> = T
export type ExpectTrue<T extends true> = T
export type ExpectFalse<T extends false> = T
export type IsTrue<T extends true> = T
export type IsFalse<T extends false> = T

/**
 * 比较两个类型是否完全相等
 */
export type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
  ? true
  : false
export type NotEqual<X, Y> = true extends Equal<X, Y> ? false : true

/**
 * 判断类型是否为 `any`
 */
export type IsAny<T> = 0 extends 1 & T ? true : false
export type NotAny<T> = true extends IsAny<T> ? false : true

export type Debug<T> = { [K in keyof T]: T[K] }
export type MergeInsertions<T> = T extends object ? { [K in keyof T]: MergeInsertions<T[K]> } : T

/**
 * 判断两个类型是否相似
 */
export type Alike<X, Y> = Equal<MergeInsertions<X>, MergeInsertions<Y>>

/**
 * 判断一个类型是否继承于另一个类型
 */
export type ExpectExtends<VALUE, EXPECTED> = EXPECTED extends VALUE ? true : false
/**
 * 判断一个函数的参数是否符合预期
 */
export type ExpectValidArgs<
  FUNC extends (...args: any[]) => any,
  ARGS extends any[]
> = ARGS extends Parameters<FUNC> ? true : false

/**
 * 将联合类型转换为交叉类型
 */
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I
) => void
  ? I
  : never
```

---

---
url: /czxBlog/type-challenges/easy/awaited/index.md
---
# Awaited
## 问题

Github: [Awaited](https://github.com/type-challenges/type-challenges/blob/main/questions/00189-easy-awaited/)

假如我们有一个 `Promise` 对象，这个 Promise 对象会返回一个类型。在 `TS` 中，我们用 `Promise` 中的 `T` 来描述这个 `Promise` 返回的类型。请你实现一个类型，可以获取这个类型。

例如：`Promise<ExampleType>`，请你返回 ExampleType 类型。

```ts
type ExampleType = Promise<string>

type Result = MyAwaited<ExampleType> // string
```

## 解题思路

这个挑战中，需要对类型 `Promise<ExampleType>` 进行展开。

**展开** 指的是，**从一个类型中提取其内部的类型** 。 比如 `Promise<string>` 的展开结果是 `string`。

```ts
type MyAwaited<T> = T extends Promise<string> ? string : T
```

但这样做我们只能处理 `Promise<string>` 这种情况，我们的是可以处理 `T` 为任意类型的 `Promise`。

在 typescript 中，可以通过 **条件类型的类型推断**，将推断结果赋值给 类型参数，这里需要借助 关键词 `infer`。
需要注意的是，条件类型的类型推断，只能在条件分支为 `true` 中可以使用 类型参数。

```ts
type MyAwaited<T> = T extends Promise<infer R> ? R : T
```

同时，我们还需要考虑 `<Promise<Promise<string>>` 等情况。这时候需要运用到 typescript 的 **类型递归**，
直到不能展开为止，这个过程是调用 `MyAwaited` 自身实现。

## 答案

```ts
type MyAwaited<T> = T extends Promise<infer R> ? MyAwaited<R> : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type MyAwaited<T> = T extends Promise<infer R> ? MyAwaited<R> : T

// ---cut---
type StringAwaited = MyAwaited<Promise<string>>
type NumberAwaited = MyAwaited<Promise<number>>
type DeepAwaited = MyAwaited<Promise<Promise<Promise<string>>>>

type cases = [
  Expect<Equal<StringAwaited, string>>,
  Expect<Equal<NumberAwaited, number>>,
  Expect<Equal<DeepAwaited, string>>,
]
```

## 参考

> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /czxBlog/type-challenges/easy/concat/index.md
---
# Concat
## 题目

Github: [Concat](https://github.com/type-challenges/type-challenges/blob/main/questions/00533-easy-concat/)

在类型系统里实现 JavaScript 内置的 `Array.concat` 方法，这个类型接受两个参数，
返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。

```ts
type Result = Concat<[1], [2]> // expected to be [1, 2]
```

## 解题思路

泛型参数 `T` `U` 约束为可变元组类型，通过 数组展开，合并到新的数组中。

## 答案

```ts
type Concat<T extends unknown[], U extends unknown[]> = [...T, ...U]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Concat<T extends unknown[], U extends unknown[]> = [...T, ...U]
// ---cut---
type Result = Concat<[1], [2]>

type test = Expect<Equal<Result, [1, 2]>>
```

## 参考

> * [可变元组 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /czxBlog/type-challenges/easy/exclude/index.md
---
# 实现 Exclude
## 题目

Github: [Exclude](https://github.com/type-challenges/type-challenges/blob/main/questions/)

实现内置的`Exclude <T, U>`类型，但不能直接使用它本身。

> 从联合类型T中排除U的类型成员，来构造一个新的类型。

```ts
type Result = MyExclude<'a' | 'b' | 'c', 'a'> // 'b' | 'c'
```

## 解题思路

在 typescript 中， 条件类型是 可分配的。

在 `T extends U` 且 `T` 是联合类型时，实际上发生的是 typescript 遍历联合类型 `T` 中的每一个元素，并将条件判断应用到每一个元素上。

所以可以通过这一特性，检查 `T` 的元素是否满足 `U` 的约束，如果是，则跳过。

## 答案

```ts
type MyExclude<T, U> = T extends U ? never : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type MyExclude<T, U> = T extends U ? never : T
// ---cut---
type Result = MyExclude<'a' | 'b' | 'c', 'a'>

type test = Expect<Equal<Result, 'b' | 'c'>>
```

## 参考

> [分配条件类型 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)

---

---
url: /czxBlog/type-challenges/easy/first-of-array/index.md
---
# 第一个元素
## 题目

Github: [First of array](https://github.com/type-challenges/type-challenges/blob/main/questions/00014-easy-first/)

实现一个 `First<T>` 泛型，它接受一个数组T并返回它的第一个元素的类型。

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

type head1 = First<arr1> // 应推导出 'a'
type head2 = First<arr2> // 应推导出 3
```

## 解题思路

获取数组的第一个元素类型，首先想到通过 **索引类型**，通过 `T[0]` 获取类型，
但是这里会有一个临界情况，如果传入的是一个空数组，会导致 `T[0]` 不能正常工作，因为它没有元素。

所以在获取数组的第一个元素类型前，需要检查数组是否为空。
可以通过 **条件类型** 推断数组是否为空，如果为空，则什么都不返回。

## 答案

```ts
type First<T extends any[]> = T extends [] ? never : T[0]
```

## 验证

```ts twoslash
// @errors: 2540
import type { Equal, Expect } from '~/tc-utils'
type First<T extends any[]> = T extends [] ? never : T[0]
// ---cut---
type cases = [
  Expect<Equal<First<[]>, never>>,
  Expect<Equal<First<['a', 'b', 'c']>, 'a'>>,
  Expect<Equal<First<[3, 2, 1]>, 3>>
]
```

## 参考

> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /czxBlog/type-challenges/easy/if/index.md
---
# If
## 题目

Github: [If](https://github.com/type-challenges/type-challenges/blob/main/questions/00268-easy-if/)

实现一个 `IF` 类型，它接收一个条件类型 `C` ，一个判断为真时的返回类型 `T` ，以及一个判断为假时的返回类型 `F`。
`C` 只能是 `true` 或者 `false`， `T` 和 `F` 可以是任意类型。

```ts
type A = If<true, 'a', 'b'> // expected to be 'a'
type B = If<false, 'a', 'b'> // expected to be 'b'
```

## 解题思路

通过泛型类型约束 `C` 为 `boolean` , 条件类型推断 `C` 计算结果是否为 `true` 。

## 答案

```ts
type If<C extends boolean, T, F> = C extends true ? T : F
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type If<C extends boolean, T, F> = C extends true ? T : F
// ---cut---
type a = If<true, 'a', 'b'>
type b = If<false, 'a', 'b'>

type cases = [
  Expect<Equal<a, 'a'>>,
  Expect<Equal<b, 'b'>>,
]
```

## 参考

> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /czxBlog/type-challenges/easy/includes/index.md
---
# Includes
## 题目

Github: [Includes](https://github.com/type-challenges/type-challenges/blob/main/questions/00898-easy-includes/)

在类型系统里实现 JavaScript 的 Array.includes 方法，这个类型接受两个参数，返回的类型要么是 true 要么是 false。

```ts
type isPillarMen = Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'> // expected to be `false`
```

::: note
这个挑战归类于 “简单” , 是欠妥的，它的难点在于，如果判断两个类型是 **全等** 的，但它的难度远比这个挑战本身要大得多。
:::

## 解题思路

本题解题的关键难点在于， 如何判断类型`U` 全等于 数组类型 `T` 中的某个成员。比如 `1` 虽然是 `number` 类型，但是
类型 `1`是继承 `number` 类型，而不是全等关系，因此 `1` 不能被认为是 `[number]` 数组的成员。

在 `TS` 类型系统中，实现 **全等判断**，需要通过 `extends` 关键词，以及 函数的返回值类型，才能正确的判断两个类型是否完全一致。

假设需要对比泛型参数 `<X, Y>` 是否全等，需要通过构造函数类型 `<T>() => T extends X ? 1 : 2`， 以及函数类型
`<T>() => T extends Y ? 1 : 2`，再通过 `extends` 关键词做条件类型，判断两个函数类型是否具有继承关系，即可间接推断
出类型 `X` 是否全等于类型`Y`。

```ts
type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
  ? true
  : false
```

有了 `Equal<X, Y>` 类型工具，继续进一步的通过类型递归的方式，遍历数组类型`T`中的每一个成员，是否全等于类型`U`，
即可实现 `includes`。

通过构造 `T extends [infer F, ...infer O]` 条件类型推断，在条件为真时，使用 `infer F`取出数组的第一个元素
与 类型`U` 进行 `Equal`。如果对比为 `false` ，则继续将 `infer O` 获取的数组`T`剩余成员，继续传入 `Includes` 类型中递归对比。

## 答案

```ts
type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
  ? true
  : false

type Includes<T extends readonly any[], U> = T extends [infer F, ...infer O]
  ? Equal<F, U> extends true
    ? true
    : Includes<O, U>
  : false
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Includes<T extends readonly any[], U> = T extends [infer F, ...infer O]
  ? Equal<F, U> extends true
    ? true
    : Includes<O, U>
  : false

// ---cut---
type cases = [
  Expect<Equal<Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Kars'>, true>>,
  Expect<Equal<Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'>, false>>,
  Expect<Equal<Includes<[1, 2, 3, 5, 6, 7], 7>, true>>,
  Expect<Equal<Includes<[1, 2, 3, 5, 6, 7], 4>, false>>,

  Expect<Equal<Includes<[{}], { a: 'A' }>, false>>,
  Expect<Equal<Includes<[boolean, 2, 3, 5, 6, 7], false>, false>>,
  Expect<Equal<Includes<[true, 2, 3, 5, 6, 7], boolean>, false>>,
  Expect<Equal<Includes<[false, 2, 3, 5, 6, 7], false>, true>>,
  Expect<Equal<Includes<[{ a: 'A' }], { readonly a: 'A' }>, false>>,
  Expect<Equal<Includes<[{ readonly a: 'A' }], { a: 'A' }>, false>>,
  Expect<Equal<Includes<[1], 1 | 2>, false>>,
  Expect<Equal<Includes<[1 | 2], 1>, false>>,
  Expect<Equal<Includes<[null], undefined>, false>>,
  Expect<Equal<Includes<[undefined], null>, false>>,
]
```

## 参考

> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [泛型约束 Generics Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)
> * [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /czxBlog/type-challenges/easy/length-of-tuple/index.md
---
# 获取元组长度
## 题目

Github: [length of tuple](https://github.com/type-challenges/type-challenges/blob/main/questions/00018-easy-tuple-length/)

创建一个 `Length` 泛型，这个泛型接受一个只读的元组，返回这个元组的长度。

```ts
type tesla = ['tesla', 'model 3', 'model X', 'model Y']
type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']

type teslaLength = Length<tesla> // expected 4
type spaceXLength = Length<spaceX> // expected 5
```

## 解题思路

在 javascript 中， 通过 `length` 属性获取数组的长度，在类型上，也同样可以通过 `length` 获取数组的长度。
同时，需要约束 `T` 的类型为 只读数组。

## 答案

```ts
type Length<T extends readonly any[]> = T['length']
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Length<T extends readonly any[]> = T['length']
// ---cut---
type tesla = Length<['tesla', 'model 3', 'model X', 'model Y']>
type spaceX = Length<['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']>

type cases = [
  Expect<Equal<tesla, 4>>,
  Expect<Equal<spaceX, 5>>,
]
```

## 参考

> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/easy/parameters/index.md
---
# Parameters
## 题目

Github: [Parameters](https://github.com/type-challenges/type-challenges/blob/main/questions/03312-easy-parameters/)

实现内置的 `Parameters<T>` 类型，而不是直接使用它，可参考[TypeScript官方文档](https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype)。

```ts
function foo(arg1: string, arg2: number): void {}

type FunctionParamsType = MyParameters<typeof foo> // [arg1: string, arg2: number]
```

## 解题思路

通过 条件类型推断，获取函数的参数类型

## 答案

```ts
type MyParameters<T> = T extends (...args: infer R) => any ? R : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type MyParameters<T> = T extends (...args: infer R) => any ? R : never

// ---cut---
function foo(arg1: string, arg2: number): void {}
function bar(arg1: boolean, arg2: { a: 'A' }): void {}
function baz(): void {}

type cases = [
  Expect<Equal<MyParameters<typeof foo>, [string, number]>>,
  Expect<Equal<MyParameters<typeof bar>, [boolean, { a: 'A' }]>>,
  Expect<Equal<MyParameters<typeof baz>, []>>,
]
```

## 参考

> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [条件类型内推断 Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /czxBlog/type-challenges/easy/pick/index.md
---
# 实现 Pick
## 题目

[Type-Challenges - **Pick**](https://github.com/type-challenges/type-challenges/blob/main/questions/00004-easy-pick/){.read-more}

实现 TS 内置的 `Pick<T, K>`，但不可以使用它。

**从类型 T 中选择出属性 K，构造成一个新的类型。**

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false,
}
```

## 解题思路

本题需要使用到 **查找类型** 和 **映射类型** 。

* **查找类型** 允许通过名称从另一个类型中提取一个新的类型。
* **映射类型** 允许将一个类型中的每个属性转换为一个新的类型。

在这个挑战中，需要从 `联合(union) K` 中取得所有内容，遍历并返回一个仅包含这些键的新的类型。
同时 `联合(union) K` 仅能包含 `T` 的键值。

## 答案

```ts
type MyPick<T, K extends keyof T> = {
  [P in K]: T[P]
}
```

最终结果为，从 `K` 中获取所有内容，命名为 `P` 并将其作为新对象的一个新键，其值的类型取自输入类型。

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type MyPick<T, K extends keyof T> = {
  [P in K]: T[P]
}
// ---cut---
interface Todo {
  title: string
  description: string
  completed: boolean
}

type Todo2 = MyPick<Todo, 'title' | 'completed'>

type Test = Expect<Equal<Todo2, { title: string, completed: boolean }>>
```

## 参考

> * [查找类型 Lookup Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)
> * [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/easy/push/index.md
---
# Push
## 题目

Github: [Push](https://github.com/type-challenges/type-challenges/blob/main/questions/03057-easy-push/)

在类型系统里实现通用的 `Array.push` 。

```ts
type Result = Push<[1, 2], '3'> // [1, 2, '3']
```

## 解题思路

通过 泛型约束`T` 为数组类型，对 `T` 进行展开到新数组中，并将 `U` 合并到新数组的末尾。

## 答案

```ts
type Push<T extends any[], U> = [...T, U]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Push<T extends any[], U> = [...T, U]

// ---cut---
type cases = [
  Expect<Equal<Push<[], 1>, [1]>>,
  Expect<Equal<Push<[1, 2], '3'>, [1, 2, '3']>>,
  Expect<Equal<Push<['1', 2, '3'], boolean>, ['1', 2, '3', boolean]>>,
]
```

## 参考

> * [可变元组 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [泛型约束 Generics Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)

---

---
url: /czxBlog/type-challenges/easy/readonly/index.md
---
# 对象属性只读
## 题目

Github: [ReadOnly](https://github.com/type-challenges/type-challenges/blob/main/questions/00007-easy-readonly/)

不要使用内置的 `Readonly<T>` ，自己实现一个。

泛型 `Readonly<T>` 会接收一个 *泛型参数* ，并返回一个完全一样的类型，只是所有属性都会是只读 (readonly) 的。

也就是不可以再对该对象的属性赋值。

```ts
interface Todo {
  title: string
  description: string
}

const todo: MyReadonly<Todo> = {
  title: 'Hey',
  description: 'foobar'
}

todo.title = 'Hello' // Error: cannot reassign a readonly property
todo.description = 'barFoo' // Error: cannot reassign a readonly property
```

## 解题思路

使一个对象的所有属性都是只读属性，需要遍历对象的每一个键，并使用 `readonly` 修饰符。

在这里，直接使用 **映射类型** ，对该类型的每个属性，获取它的键并为其添加 `readonly` 修饰符

## 答案

```ts
type MyReadonly<T> = {
  readonly [P in keyof T]: T[P]
}
```

## 验证

```ts twoslash
// @errors: 2540
import type { Equal, Expect } from '~/tc-utils'
type MyReadonly<T> = {
  readonly [P in keyof T]: T[P]
}
// ---cut---
interface Todo {
  title: string
  description: string
}

interface TodoReadonly {
  readonly title: string
  readonly description: string
}

type test = Expect<Equal<MyReadonly<Todo>, TodoReadonly>>

const todo: MyReadonly<Todo> = {
  title: 'Hey',
  description: 'foobar'
}

todo.title = 'Hello'
todo.description = 'barFoo'
```

## 参考

> * [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)

---

---
url: /czxBlog/type-challenges/easy/tuple-to-object/index.md
---
# 元组转换为对象
## 题目

Github: [Tuple to Object](https://github.com/type-challenges/type-challenges/blob/main/questions/)

将一个元组类型转换为对象类型，这个对象类型的键/值和元组中的元素对应。

```ts
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple>
// expected { 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```

## 解题思路

解题的关键在于获取元组中的所有值，并将其作为新对象中的键和值。

可以使用 **索引类型** `T[number]` 从数组中获取所有值，通过 **映射类型**，遍历 `T[number]` 中的值，并返回新的类型，
其中 键 和 值 是 `T[number]` 的类型。

## 答案

```ts
type TupleToObject<T extends readonly PropertyKey[]> = {
  [P in T[number]]: P
}
```

## 验证

```ts twoslash
// @errors: 2540
import type { Equal, Expect } from '~/tc-utils'
type TupleToObject<T extends readonly PropertyKey[]> = {
  [P in T[number]]: P
}
// ---cut---
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type test = Expect<Equal<
  TupleToObject<typeof tuple>,
  { 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y' }
>>
```

## 参考

> * [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/easy/unshift/index.md
---
# Unshift
## 题目

Github: [Unshift](https://github.com/type-challenges/type-challenges/blob/main/questions/03060-easy-unshift/)

实现类型版本的 `Array.unshift`。

```ts
type Result = Unshift<[1, 2], 0> // [0, 1, 2,]
```

## 解题思路

通过 泛型约束`T` 为数组类型，对 `T` 进行展开到新数组中，并将 `U` 合并到新数组的首位。

## 答案

```ts
type Unshift<T extends any[], U> = [U, ...T]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Unshift<T extends any[], U> = [U, ...T]

// ---cut---
type cases = [
  Expect<Equal<Unshift<[], 1>, [1]>>,
  Expect<Equal<Unshift<[1, 2], 0>, [0, 1, 2]>>,
  Expect<Equal<Unshift<['1', 2, '3'], boolean>, [boolean, '1', 2, '3']>>,
]
```

## 参考

> * [可变元组 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [泛型约束 Generics Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)

---

---
url: /czxBlog/type-challenges/medium/absolute/index.md
---
# 正数字符串
## 题目

Github: [Absolute](https://github.com/type-challenges/type-challenges/blob/main/questions/00529-medium-absolute/)

实现一个接收 `string`, `number` 或 `bigInt` 类型参数的 `Absolute` 类型,返回一个 正数字符串。

```ts
type Test = -100
type Result = Absolute<Test> // expected to be "100"
```

## 解题思路

将一个负数转为正数的方法，很容易想到就是直接把负号 `-` 去掉，因此，可以使用模板字面量来实现。

首先将 `T` 转为字符串，然后判断是否该字符串是否以 `-` 字符开始。
如果是，就去掉 `-` 字符，否则返回原字符串。

## 答案

```ts
type Absolute<T extends number | string | bigint> =
  `${T}` extends `-${infer R}` ? R : `${T}`
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Absolute<T extends number | string | bigint> = `${T}` extends `-${infer R}` ? R : `${T}`

// ---cut---
type cases = [
  Expect<Equal<Absolute<0>, '0'>>,
  Expect<Equal<Absolute<-0>, '0'>>,
  Expect<Equal<Absolute<10>, '10'>>,
  Expect<Equal<Absolute<-5>, '5'>>,
  Expect<Equal<Absolute<'0'>, '0'>>,
  Expect<Equal<Absolute<'-0'>, '0'>>,
  Expect<Equal<Absolute<'10'>, '10'>>,
  Expect<Equal<Absolute<'-5'>, '5'>>,
  Expect<Equal<Absolute<-1_000_000n>, '1000000'>>,
  Expect<Equal<Absolute<9_999n>, '9999'>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/all-combinations/index.md
---
# AllCombinations
## 题目

Github: [AllCombinations](https://github.com/type-challenges/type-challenges/blob/main/questions/04260-medium-nomiwase/README.md)

实现类型 `AllCombinations<S>` ，该类型返回使用 `S` 中的字符且每个字符最多使用一次的所有字符串组合。

```ts
type AllCombinations_ABC = AllCombinations<'ABC'>
// should be '' | 'A' | 'B' | 'C' | 'AB' | 'AC' | 'BA' | 'BC' | 'CA' | 'CB' | 'ABC' | 'ACB' | 'BAC' | 'BCA' | 'CAB' | 'CBA'
```

## 解题思路

参考 [#16430](https://github.com/type-challenges/type-challenges/issues/16430)

## 答案

```ts
type StringToUnion<S extends string> = S extends `${infer F}${infer O}`
  ? F | StringToUnion<O>
  : never

type AllCombinations<
  S extends string,
  U extends string = StringToUnion<S>
> = [U] extends [never]
  ? ''
  : '' | {
    [P in U]: `${P}${AllCombinations<never, Exclude<U, P>>}`
  }[U]
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type StringToUnion<S extends string> = S extends `${infer F}${infer O}`
  ? F | StringToUnion<O>
  : never

type AllCombinations<
  S extends string,
  U extends string = StringToUnion<S>
> = [U] extends [never]
  ? ''
  : '' | {
    [P in U]: `${P}${AllCombinations<never, Exclude<U, P>>}`
  }[U]

// ---cut---
type cases = [
  Expect<Equal<AllCombinations<''>, ''>>,
  Expect<Equal<AllCombinations<'A'>, '' | 'A'>>,
  Expect<Equal<AllCombinations<'AB'>, '' | 'A' | 'B' | 'AB' | 'BA'>>,
  Expect<Equal<AllCombinations<'ABC'>, '' | 'A' | 'B' | 'C' | 'AB' | 'AC' | 'BA' | 'BC' | 'CA' | 'CB' | 'ABC' | 'ACB' | 'BAC' | 'BCA' | 'CAB' | 'CBA'>>,
  Expect<Equal<AllCombinations<'ABCD'>, '' | 'A' | 'B' | 'C' | 'D' | 'AB' | 'AC' | 'AD' | 'BA' | 'BC' | 'BD' | 'CA' | 'CB' | 'CD' | 'DA' | 'DB' | 'DC' | 'ABC' | 'ABD' | 'ACB' | 'ACD' | 'ADB' | 'ADC' | 'BAC' | 'BAD' | 'BCA' | 'BCD' | 'BDA' | 'BDC' | 'CAB' | 'CAD' | 'CBA' | 'CBD' | 'CDA' | 'CDB' | 'DAB' | 'DAC' | 'DBA' | 'DBC' | 'DCA' | 'DCB' | 'ABCD' | 'ABDC' | 'ACBD' | 'ACDB' | 'ADBC' | 'ADCB' | 'BACD' | 'BADC' | 'BCAD' | 'BCDA' | 'BDAC' | 'BDCA' | 'CABD' | 'CADB' | 'CBAD' | 'CBDA' | 'CDAB' | 'CDBA' | 'DABC' | 'DACB' | 'DBAC' | 'DBCA' | 'DCAB' | 'DCBA'>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)

---

---
url: /czxBlog/type-challenges/medium/all/index.md
---
# All
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/any-of/index.md
---
# AnyOf
## 题目

Github: [AnyOf](https://github.com/type-challenges/type-challenges/blob/main/questions/00949-medium-anyof/)

在类型系统中实现类似于 `Python` 中 `any` 函数。类型接收一个数组，如果数组中任一个元素为真，
则返回 `true`，否则返回 `false`。如果数组为空，返回 `false`。

```ts
type Sample1 = AnyOf<[1, '', false, [], {}]> // expected to be true.
type Sample2 = AnyOf<[0, '', false, [], {}]> // expected to be false.
```

## 解题思路

我们可以使用 `T[number]` 从 `T` 中获取每个元素的类型，然后使用 `extends` 来判断每个元素是否不为真。

为方便比较，我们可以使用 `Falsely` 类型来表示不为真的元素。

## 答案

```ts
type Falsely = 0 | '' | false | undefined | null | [] | { [k: string]: never }
type AnyOf<T extends readonly any[]> = T[number] extends Falsely ? false : true
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Falsely = 0 | '' | false | undefined | null | [] | { [k: string]: never }
type AnyOf<T extends readonly any[]> = T[number] extends Falsely ? false : true

// ---cut---
type cases = [
  Expect<Equal<AnyOf<[1, 'test', true, [1], { name: 'test' }, { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[1, '', false, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, 'test', false, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', true, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [1], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { name: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { name: 'test' }, { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], {}, undefined, null]>, false>>,
  Expect<Equal<AnyOf<[]>, false>>,
]
```

## 参考

* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

---

---
url: /czxBlog/type-challenges/medium/appear-only-once/index.md
---
# appearOnlyOnce
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/append-argument/index.md
---
# 追加参数
## 题目

Github: [Append Argument](https://github.com/type-challenges/type-challenges/blob/main/questions/00191-medium-append-argument/)

实现一个泛型 `AppendArgument<Fn, A>`，对于给定的函数类型 `Fn`，以及一个任意类型 `A`，返回一个新的函数 `G`。
`G` 拥有 `Fn` 的所有参数并在末尾追加类型为 `A` 的参数。

```ts
type Fn = (a: number, b: string) => number

type Result = AppendArgument<Fn, boolean>
// 期望是 (a: number, b: string, x: boolean) => number
```

## 解题思路

首先我们可以使用 `infer` 关键字来推断出函数的参数类型和返回值类型。通过条件类型的类型推断来实现这一点。

```ts
type AppendArgument<Fn, A> = Fn extends (args: infer P) => infer R
  ? (args: P) => R
  : never
```

但需要注意的是，这里的 `(args:infer P)` 只能获取首个参数的类型，因此我们需要使用 `...` 展开语法来获取所有参数的类型。

```ts
type AppendArgument<Fn, A> = Fn extends (...args: infer P) => infer R
  ? (...args: P) => R
  : never
```

此时获取的类型参数 `P` 为一个可变元组类型，可以使用 `...` 展开语法来获取参数的类型，并添加 `A` 类型的参数。
构造新的函数参数签名。

## 答案

```ts
type AppendArgument<Fn extends (...args: any[]) => any, A> =
  Fn extends (...args: infer P) => infer R ? (...args: [...P, A]) => R : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type AppendArgument<Fn extends (...args: any[]) => any, A> =
  Fn extends (...args: infer P) => infer R ? (...args: [...P, A]) => R : never
// ---cut---
type Case1 = AppendArgument<(a: number, b: string) => number, boolean>
type Result1 = (a: number, b: string, x: boolean) => number

type Case2 = AppendArgument<() => void, undefined>
type Result2 = (x: undefined) => void

type cases = [
  Expect<Equal<Case1, Result1>>,
  Expect<Equal<Case2, Result2>>,
  // @ts-expect-error
  AppendArgument<unknown, undefined>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [可变参数和参数 Rest Parameters and Arguments](https://www.typescriptlang.org/docs/handbook/2/functions.html#rest-parameters-and-arguments)

---

---
url: /czxBlog/type-challenges/medium/append-to-object/index.md
---
# 追加字段到对象
## 题目

Github: [AppendToObject](https://github.com/type-challenges/type-challenges/blob/main/questions/00527-medium-appendtoobject/)

实现一个为接口添加一个新字段的类型。该类型接收三个参数，返回带有新字段的接口类型。

```ts
interface Test { id: '1' }
type Result = AppendToObject<Test, 'value', 4> // expected to be { id: '1', value: 4 }
```

## 解题思路

一开始可能会想到使用交叉类型来解决此挑战：

```ts
type AppendToObject<T, U extends PropertyKey, V> = T & { [K in U]: V }
```

然而我们需要留意到此挑战，需要 **返回带有新字段的接口类型**，这需要的是一个新的普通类型，而不是一个交叉类型。

首先我们可以先将 `T` 映射为一个普通类型：

```ts
type AppendToObject<T, U extends PropertyKey, V> = {
  [K in keyof T]: T[K]
}
```

接下来，我们可以就可以在 `keyof T` 的联合类型中，添加 泛型 `U`，

```ts
type AppendToObject<T, U extends PropertyKey, V> = {
  [K in keyof T | U]: T[K]
}
```

但是 `K` 如果为类型 `U` 时，很明显 `T[K]` 不满足要求，它的值类型应为 `V`：

```ts
type AppendToObject<T, U extends PropertyKey, V> = {
  [K in keyof T | U]: K extends keyof T ? T[K] : V
}
```

## 答案

```ts
type AppendToObject<T, U extends PropertyKey, V> = {
  [K in keyof T | U]: K extends keyof T ? T[K] : V
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type AppendToObject<T, U extends PropertyKey, V> = {
  [K in keyof T | U]: K extends keyof T ? T[K] : V
}
// ---cut---
interface test1 {
  key: 'cat'
  value: 'green'
}

interface testExpect1 {
  key: 'cat'
  value: 'green'
  home: boolean
}

interface test2 {
  key: 'dog' | undefined
  value: 'white'
  sun: true
}

interface testExpect2 {
  key: 'dog' | undefined
  value: 'white'
  sun: true
  home: 1
}

interface test3 {
  key: 'cow'
  value: 'yellow'
  sun: false
}

interface testExpect3 {
  key: 'cow'
  value: 'yellow'
  sun: false
  moon: false | undefined
}

type cases = [
  Expect<Equal<AppendToObject<test1, 'home', boolean>, testExpect1>>,
  Expect<Equal<AppendToObject<test2, 'home', 1>, testExpect2>>,
  Expect<Equal<AppendToObject<test3, 'moon', false | undefined>, testExpect3>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)

---

---
url: /czxBlog/type-challenges/medium/bem-style-string/index.md
---
# BemStyleString
## 题目

Github: [BemStyleString](https://github.com/type-challenges/type-challenges/blob/main/questions/03326-medium-bem-style-string/)

块、元素、修饰符方法（BEM）是CSS中一种流行的类命名规范。

例如，块组件可以表示为`btn`，依赖于该块的元素可以表示为`btn__price`，改变块样式的修饰符可以表示为`btn--big`或`btn__price--warning`。

实现`BEM<B, E, M>`，从这三个参数生成字符串联合类型。其中`B`是字符串字面量，`E`和`M`是字符串数组（可以为空）。

## 解题思路

略。

## 答案

```ts
type BEM<B extends string, E extends string[], M extends string[]> =
  `${B}${E extends [] ? '' : `__${E[number]}`}${M extends [] ? '' : `--${M[number]}`}`
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type BEM<B extends string, E extends string[], M extends string[]> =
  `${B}${E extends [] ? '' : `__${E[number]}`}${M extends [] ? '' : `--${M[number]}`}`

// ---cut---
type cases = [
  Expect<Equal<BEM<'btn', ['price'], []>, 'btn__price'>>,
  Expect<Equal<BEM<'btn', ['price'], ['warning', 'success']>, 'btn__price--warning' | 'btn__price--success'>>,
  Expect<Equal<BEM<'btn', [], ['small', 'medium', 'large']>, 'btn--small' | 'btn--medium' | 'btn--large'>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /czxBlog/type-challenges/medium/capitalize/index.md
---
# 首字母大写
## 题目

Github: [Capitalize](https://github.com/type-challenges/type-challenges/blob/main/questions/00110-medium-capitalize/)

实现 `Capitalize<T>` 它将字符串的第一个字母转换为大写，其余字母保持原样。

```ts
type capitalized = Capitalize<'hello world'> // expected to be 'Hello world'
```

## 解题思路

此挑战可以拆分为两个问题：

1. 提取字符串的第一个字母；
2. 将这个字母转换为大写。

我们可以使用 **模板字面量类型** 提取字符串的第一个字母，然后使用 内置 `Uppercase` 将其转换为大写字母。

## 答案

```ts
type MyCapitalize<S extends string> =
  S extends `${infer F}${infer R}` ? `${Uppercase<F>}${R}` : S
```

::: details `${infer F}${infer R}` 是如何工作的？

在 模板字面量类型中，如果字符串仅使用 `infer` 进行推导，而不掺杂其他信息，
那么前面的 `infer` 每一次只会推导一个字符。最后的 `infer` 会推导剩下的所有字符。

比如 `abcd`， 推导出 `F = a`， `R = bcd`。

而如果在其中加入某些推导条件，如 `${infer F}-${infer R}`，那么则会按照推导条件进行分割：

比如 `ab-cc-dd` ， 推导出 `F = ab`， `R = cc-dd`

:::

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type MyCapitalize<S extends string> = S extends `${infer F}${infer R}` ? `${Uppercase<F>}${R}` : S

// ---cut---
type cases = [
  Expect<Equal<MyCapitalize<'foobar'>, 'Foobar'>>,
  Expect<Equal<MyCapitalize<'FOOBAR'>, 'FOOBAR'>>,
  Expect<Equal<MyCapitalize<'foo bar'>, 'Foo bar'>>,
  Expect<Equal<MyCapitalize<''>, ''>>,
  Expect<Equal<MyCapitalize<'a'>, 'A'>>,
  Expect<Equal<MyCapitalize<'b'>, 'B'>>,
  Expect<Equal<MyCapitalize<'c'>, 'C'>>,
  Expect<Equal<MyCapitalize<'d'>, 'D'>>,
  Expect<Equal<MyCapitalize<'e'>, 'E'>>,
  Expect<Equal<MyCapitalize<'f'>, 'F'>>,
  Expect<Equal<MyCapitalize<'g'>, 'G'>>,
  Expect<Equal<MyCapitalize<'h'>, 'H'>>,
  Expect<Equal<MyCapitalize<'i'>, 'I'>>,
  Expect<Equal<MyCapitalize<'j'>, 'J'>>,
  Expect<Equal<MyCapitalize<'k'>, 'K'>>,
  Expect<Equal<MyCapitalize<'l'>, 'L'>>,
  Expect<Equal<MyCapitalize<'m'>, 'M'>>,
  Expect<Equal<MyCapitalize<'n'>, 'N'>>,
  Expect<Equal<MyCapitalize<'o'>, 'O'>>,
  Expect<Equal<MyCapitalize<'p'>, 'P'>>,
  Expect<Equal<MyCapitalize<'q'>, 'Q'>>,
  Expect<Equal<MyCapitalize<'r'>, 'R'>>,
  Expect<Equal<MyCapitalize<'s'>, 'S'>>,
  Expect<Equal<MyCapitalize<'t'>, 'T'>>,
  Expect<Equal<MyCapitalize<'u'>, 'U'>>,
  Expect<Equal<MyCapitalize<'v'>, 'V'>>,
  Expect<Equal<MyCapitalize<'w'>, 'W'>>,
  Expect<Equal<MyCapitalize<'x'>, 'X'>>,
  Expect<Equal<MyCapitalize<'y'>, 'Y'>>,
  Expect<Equal<MyCapitalize<'z'>, 'Z'>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [模板字面量类型中的大写字符串类型](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)

---

---
url: /czxBlog/type-challenges/medium/cartesian-product/index.md
---
# cartesianProduct
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/chainable-options/index.md
---
# 可串联构造器
## 题目

Github: [Chainable options](https://github.com/type-challenges/type-challenges/blob/main/questions/00012-medium-chainable-options/)

在 `JavaScript` 中我们经常会使用可串联（Chainable/Pipeline）的函数构造一个对象，
但在 `TypeScript` 中，你能合理的给它赋上类型吗？

在这个挑战中，你可以使用任意你喜欢的方式实现这个类型 - `Interface`, `Type` 或 `Class` 都行。
你需要提供两个函数 `option(key, value)` 和 `get()`。
在 `option` 中你需要使用提供的 `key` 和 `value` 扩展当前的对象类型，通过 `get` 获取最终结果。

```ts
declare const config: Chainable

const result = config
  .option('foo', 123)
  .option('name', 'type-challenges')
  .option('bar', { value: 'Hello World' })
  .get()

// 期望 result 的类型是：
interface Result {
  foo: number
  name: string
  bar: {
    value: string
  }
}
```

你只需要在类型层面实现这个功能 - 不需要实现任何 `TS/JS` 的实际逻辑。

你可以假设 `key` 只接受字符串而 `value` 接受任何类型，你只需要暴露它传递的类型而不需要进行任何处理。
同样的 `key` 只会被使用一次。

## 解题思路

这是一个实用性非常高的挑战。我们很容易会想到可以在 [`webpack-chain`](https://github.com/neutrinojs/webpack-chain)
\~~(此库以归档不再维护)~~ 中使用它。

在这个挑战中，我们需要实现 `options(key, value)` 和 `get()` 两个方法。
在每次调用 `options(key, value)` 方法时，需要累加 `key` 和 `value` 的类型信息，
累加操作需要持续进行，直到 `get()` 被调用，返回最终的类型信息。

我们从最基础的类型开始，定义一个 `Chainable` 接口，它包含了 `option` 方法和 `get` 方法。

```ts
interface Chainable {
  option: (key: any, value: any) => any
  get: () => any
}
```

首先我们需要得到 `options(key, value)` 的类型信息，这里我们可以使用 类型参数替换 `any`，
以便 TypeScript 可以推断出它们的类 型并将其分配给类型参数。

`option(key, value)` 需要被连续调用，因此，`option(key, value)` 需要返回 `Chainable` 类型本身。

```ts
interface Chainable {
  option: <K, V>(key: K, value: V) => Chainable
  get: () => any
}
```

TypeScript 会将 `key` 推断 为字符串字面量类型，而将 `value` 推断为常见的类型。
例如，调用 `option('foo', 123)` 将得出的类型为：`key = 'foo'` 和 `value = number`。

接下来，我们需要保存 `key` 和 `value` 的类型信息，它必须在能够在连续调用 `option` 方法后能够保存
其状态，因此我们可以把这些信息保存在 `Chainable` 的类型参数中。

```ts
interface Chainable<T = {}> {
  option: <K, V>(key: K, value: V) => Chainable<T & { [P in K]: V }>
  get: () => any
}
```

这里我们使用 交叉类型，将 `T` 的类型信息和 `key` 和 `value` 的类型信息进行了合并，
最终得到的类型是：`T & { [P in K]: V }`。

但在这里我们还需要对 `K` 进行类型检查，因为 `K` 的类型可能不是字符串字面量类型。

```ts
interface Chainable<T = {}> {
  option: <K extends string, V>(key: K, value: V) => Chainable<T & { [P in K]: V }>
  get: () => any
}
```

接下来，我们需要在 `get` 方法 返回 `T` 的类型信息。

```ts
interface Chainable<T = {}> {
  option: <K extends string, V>(key: K, value: V) => Chainable<T & { [P in K]: V }>
  get: () => T
}
```

到这一步，已经基本可以满足挑战的要求了。

但我们还可以进一步思考，当连续调用`option(key, value)` 时传入的 相同的 `key` ，又或者 给相同的 `key` 传入
不同类型的 `value` 时，会发生什么情况？

```ts twoslash
interface Chainable<T = {}> {
  option: <K extends string, V>(key: K, value: V) => Chainable<T & { [P in K]: V }>
  get: () => T
}
// ---cut---
declare const config: Chainable

const result = config
  .option('name', 'foo') // step 1
  .option('name', 'bar') // step 2
  .option('name', 123) // step 3
  .get()
```

很明显可以看到，属性 `name` 的值类型被合并为 `string | number`。

我们不妨增加一些挑战难度，
**不允许合并 `key` 值的类型，重复调用的 `key` 的值类型应该与上一次调用的值类型保持一致，允许值被覆盖。**

这里需要对 `K` 进行类型检查，当 `K` 满足 `keyof T` 约束，即在 `T` 类型上已存在 `K` 这个属性时,
我们需要对 `V` 也进行类型检查，`V` 的类型是否可以分配给 `T[K]`，如果可以的话，那么 `K` 就可以作为 `key`，
否则应该返回 `never`，抛出错误。（由于 `never` 不能给其他类型使用，此时传入其他类型都会报错）

`K extends keyof T ? (V extends T[K] ? K : never) : K`

还需要对 `option()` 的返回类型进行检查，如果 `K` 满足 `keyof T` 约束时，需要先 `T` 上移除 `K` 这个属性，
然后再和 `V` 进行交叉类型，最终得到的类型是：`Omit<T, K> & { [P in K]: V }`。
而不满足 `keyof T` 约束时，直接和 `V` 进行交叉类型，最终得到的类型是：`T & { [P in K]: V }`。

## 答案

```ts
interface Chainable<T extends Record<string, unknown> = object> {
  option: <K extends string, V>(
    key: K extends keyof T ? (V extends T[K] ? K : never) : K,
    value: V,
  ) => K extends keyof T
    ? Chainable<Omit<T, K> & { [P in K]: V }>
    : Chainable<T & { [P in K]: V }>
  get: () => T
}
```

## 验证

```ts twoslash
import type { Alike, Expect } from '~/tc-utils'

interface Chainable<T extends Record<string, unknown> = {}> {
  option: <K extends string, V>(
    key: K extends keyof T ? (V extends T[K] ? K : never) : K,
    value: V
  ) => K extends keyof T
    ? Chainable<Omit<T, K> & { [P in K]: V }>
    : Chainable<T & { [P in K]: V }>
  get: () => T
}

// ---cut---
declare const a: Chainable

const result1 = a
  .option('foo', 123)
  .option('bar', { value: 'Hello World' })
  .option('name', 'type-challenges')
  .get()

const result2 = a
  .option('name', 'another name')
  .option('name', 'last name')
  .get()

const result3 = a
  .option('name', 'another name')
  // @ts-expect-error ignore
  .option('name', 123)
  .get()

type cases = [
  Expect<Alike<typeof result1, Expected1>>,
  Expect<Alike<typeof result2, Expected2>>,
  Expect<Alike<typeof result3, Expected3>>,
]

interface Expected1 {
  foo: number
  bar: {
    value: string
  }
  name: string
}

interface Expected2 {
  name: string
}

interface Expected3 {
  name: number
}
```

## 参考

* [交叉类型 Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

---

---
url: /czxBlog/type-challenges/medium/check-repeated-chars/index.md
---
# checkRepeatedChars
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/check-repeated-tuple/index.md
---
# checkRepeatedTuple
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/chunk/index.md
---
# Chunk
## 题目

Github: [Chunk](https://github.com/type-challenges/type-challenges/blob/main/questions/04499-medium-chunk/README.md)

你知道 `lodash` 吗？其中的 `Chunk` 是一个非常实用的函数，现在让我们来实现它。
`Chunk<T, N>` 接受两个必需的类型参数，`T` 必须是一个元组，而 `N` 必须是一个大于等于 `1` 的整数。

```ts
type exp1 = Chunk<[1, 2, 3], 2> // expected to be [[1, 2], [3]]
type exp2 = Chunk<[1, 2, 3], 4> // expected to be [[1, 2, 3]]
type exp3 = Chunk<[1, 2, 3], 1> // expected to be [[1], [2], [3]]
```

## 解题思路

首先我们从类型声明开始，类型 `Chunk` 接受三个参数 `T`，`N`，`R`，`T` 是一个元组，`N` 是一个大于等于 `1` 的整数，
`R` 是一个可选的参数，用于保存单个分块的结果。

```ts
type Chunk<
  T extends unknown[],
  N extends number,
  R extends unknown[] = []
> = any
```

对于单个分块 `R`，当其长度为 `N` 时，即满足 `R['length'] extends N`，则表示分块已经填满，需要继续填充下一个分块：

```ts
type Chunk<T extends unknown[], N extends number, R extends unknown[] = []> =
  R['length'] extends N ? [...R, Chunk<T, N>] : any
```

当分块未填满且数组 `T` 中还有元素时 `T extends [infer F, ...infer U]`，需要继续分块：

```ts
type Chunk<T extends unknown[], N extends number, R extends unknown[] = []> =
  R['length'] extends N
    ? [...R, Chunk<T, N>]
    : T extends [infer F, ...infer U]
      ? Chunk<U, N, [...R, F]>
      : any
```

也要考虑，当数组 `T` 已清空时，如果 `R` 中还有元素，需要将 `[R]` 返回，否则返回 `[]` 。

## 答案

```ts
type Chunk<
  T extends unknown[],
  N extends number,
  R extends unknown[] = []
> = R['length'] extends N
  ? [R, ...Chunk<T, N>]
  : T extends [infer F, ...infer U]
    ? Chunk<U, N, [...R, F]>
    : R extends [] ? [] : [R]
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type Chunk<T extends unknown[], N extends number, R extends unknown[] = []> = R['length'] extends N
  ? [R, ...Chunk<T, N>]
  : T extends [infer F, ...infer U]
    ? Chunk<U, N, [...R, F]>
    : R extends [] ? [] : [R]

// ---cut---
type cases = [
  Expect<Equal<Chunk<[], 1>, []>>,
  Expect<Equal<Chunk<[1, 2, 3], 1>, [[1], [2], [3]]>>,
  Expect<Equal<Chunk<[1, 2, 3], 2>, [[1, 2], [3]]>>,
  Expect<Equal<Chunk<[1, 2, 3, 4], 2>, [[1, 2], [3, 4]]>>,
  Expect<Equal<Chunk<[1, 2, 3, 4], 5>, [[1, 2, 3, 4]]>>,
  Expect<Equal<Chunk<[1, true, 2, false], 2>, [[1, true], [2, false]]>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [泛型约束 Generics constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/medium/combination-key-type/index.md
---
# combinationKeyType
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/combination/index.md
---
# Combination
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/compare-array-length/index.md
---
# compareArrayLength
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/construct-tuple/index.md
---
# ConstructTuple
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/count-element-number-to-object/index.md
---
# count Element Number To Object
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/deep-mutable/index.md
---
# DeepMutable
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/deep-omit/index.md
---
# deepOmit
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/deep-readonly/index.md
---
# 对象属性只读（递归）
## 题目

Github: [Deep Readonly](https://github.com/type-challenges/type-challenges/blob/main/questions/00009-medium-deep-readonly/)

实现一个通用的`DeepReadonly<T>`，它将对象的每个参数及其子对象递归地设为只读。

您可以假设在此挑战中我们仅处理对象。数组，函数，类等都无需考虑。但是，您仍然可以通过覆盖尽可能多的不同案例来挑战自己。

```ts
interface X {
  x: {
    a: 1
    b: 'hi'
  }
  y: 'hey'
}

interface Expected {
  readonly x: {
    readonly a: 1
    readonly b: 'hi'
  }
  readonly y: 'hey'
}

type Todo = DeepReadonly<X> // should be same as `Expected`
```

## 解题思路

通过 `readonly` 修饰属性为 只读属性。

通过 `T extends Record<any, any>` 判断是否为对象，如果是，使用 `readonly` 修饰属性为 只读属性，
并对 `T[P]` 递归调用 `DeepReadonly` 。

由于 `Function` 继承自 `Object`，所以需要单独处理 `Function` 类型。

## 答案

```ts
type DeepReadonly<T> = T extends Function
  ? T
  : T extends Record<any, any>
    ? { readonly [P in keyof T]: DeepReadonly<T[P]> }
    : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type DeepReadonly<T> = T extends Function
  ? T
  : T extends Record<any, any>
    ? { readonly [P in keyof T]: DeepReadonly<T[P]> }
    : T

// ---cut---
type cases = [
  Expect<Equal<DeepReadonly<X1>, Expected1>>,
  Expect<Equal<DeepReadonly<X2>, Expected2>>,
]

interface X1 {
  a: () => 22
  b: string
  c: {
    d: boolean
    e: {
      g: {
        h: {
          i: true
          j: 'string'
        }
        k: 'hello'
      }
      l: [
        'hi',
        {
          m: ['hey']
        },
      ]
    }
  }
}

type X2 = { a: string } | { b: number }

interface Expected1 {
  readonly a: () => 22
  readonly b: string
  readonly c: {
    readonly d: boolean
    readonly e: {
      readonly g: {
        readonly h: {
          readonly i: true
          readonly j: 'string'
        }
        readonly k: 'hello'
      }
      readonly l: readonly [
        'hi',
        {
          readonly m: readonly ['hey']
        },
      ]
    }
  }
}

type Expected2 = { readonly a: string } | { readonly b: number }
```

## 参考

* [索引类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/defined-partial-record/index.md
---
# definedPartialRecord
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/diff/index.md
---
# Diff
## 题目

Github: [Diff](https://github.com/type-challenges/type-challenges/blob/main/questions/00645-medium-diff/)

获取两个接口类型中的差值属性。

```ts
interface Foo {
  a: string
  b: number
}
interface Bar {
  a: string
  c: boolean
}

type Result1 = Diff<Foo, Bar> // { b: number, c: boolean }
type Result2 = Diff<Bar, Foo> // { b: number, c: boolean }
```

## 解题思路

::: tip 此解题思路来自 [type-challenges#3014](https://github.com/type-challenges/type-challenges/issues/3014)
:::

在对象中使用 `|` 与 `&` ，与在非对象中使用存在语义上的差异。

在集合对象中使用联合类型 `|` ，
官网 [working-with-union-types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#working-with-union-types) 有如下说明:

> Notice that given two sets with corresponding facts about each set, only the intersection of those facts applies to the union of the sets themselves.

```ts
interface Foo {
  name: string
  age: string
}
interface Bar {
  name: string
  age: string
  gender: number
}

type result = keyof (Foo | Bar) // "name" | "age"
```

在集合对象中使用交集类型 `&` ，可以见 [intersection-types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types) 给出的 demo:

```ts
interface Colorful {
  color: string
}
interface Circle {
  radius: number
}

type ColorfulCircle = keyof (Colorful & Circle) // "color" | "radius"
```

结合 `&` 与 `|` 的使用，我们能立马写出比如类型 `diff`

## 答案

```ts
type Diff<O, O1> = Omit<O & O1, keyof (O | O1)>
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Diff<O, O1> = Omit<O & O1, keyof (O | O1)>

// ---cut---
interface Foo {
  name: string
  age: string
}
interface Bar {
  name: string
  age: string
  gender: number
}
interface Coo {
  name: string
  gender: number
}

type cases = [
  Expect<Equal<Diff<Foo, Bar>, { gender: number }>>,
  Expect<Equal<Diff<Bar, Foo>, { gender: number }>>,
  Expect<Equal<Diff<Foo, Coo>, { age: string, gender: number }>>,
  Expect<Equal<Diff<Coo, Foo>, { age: string, gender: number }>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [映射类型中的键重映射 Key Remapping In Mapped Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types)
* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [交叉类型 Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [keyof 和查找类型 Keyof And Lookup Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)

---

---
url: /czxBlog/type-challenges/medium/drop-char/index.md
---
# Drop Char
## 题目

Github: [DropChar](https://github.com/type-challenges/type-challenges/blob/main/questions/02070-medium-drop-char/)

从字符串中剔除指定字符。

```ts
type Butterfly = DropChar<' b u t t e r f l y ! ', ' '> // 'butterfly!'
```

## 解题思路

这个挑战相对来说很简单，可以通过 模板字面量类型 和 条件类型 快速解决。

需要注意的是， 当`C` 是 `''` 时，可能会导致递归太深的问题，因此当 `C` 为 `''` 时，需要直接返回 `S` 。

## 答案

```ts
type DropChar<S extends string, C extends string> = C extends ''
  ? S
  : S extends `${infer L}${C}${infer R}`
    ? DropChar<`${L}${R}`, C>
    : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type DropChar<S extends string, C extends string> = C extends ''
  ? S
  : S extends `${infer L}${C}${infer R}`
    ? DropChar<`${L}${R}`, C>
    : S

// ---cut---
type cases = [
  // @ts-expect-error
  Expect<Equal<DropChar<'butter fly!', ''>, 'butterfly!'>>,
  Expect<Equal<DropChar<'butter fly!', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<'butter fly!', '!'>, 'butter fly'>>,
  Expect<Equal<DropChar<'    butter fly!        ', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', 'b'>, '  u t t e r f l y ! '>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', 't'>, ' b u   e r f l y ! '>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/ends-with/index.md
---
# EndsWith
## 题目

实现 `EndsWith<T, U>` ,接收两个 `string` 类型参数,然后判断 `T` 是否以 `U` 结尾,根据结果返回 `true` 或 `false`

```ts
type a = EndsWith<'abc', 'bc'> // expected to be true
type b = EndsWith<'abc', 'abc'> // expected to be true
type c = EndsWith<'abc', 'd'> // expected to be false
```

## 解题思路

略。

## 答案

```ts
type EndsWith<T extends string, U extends string> = T extends `${string}${U}` ? true : false
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type EndsWith<T extends string, U extends string> = T extends `${string}${U}` ? true : false

// ---cut---
type cases = [
  Expect<Equal<EndsWith<'abc', 'bc'>, true>>,
  Expect<Equal<EndsWith<'abc', 'abc'>, true>>,
  Expect<Equal<EndsWith<'abc', 'd'>, false>>,
  Expect<Equal<EndsWith<'abc', 'ac'>, false>>,
  Expect<Equal<EndsWith<'abc', ''>, true>>,
  Expect<Equal<EndsWith<'abc', ' '>, false>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [泛型约束 Generics constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /czxBlog/type-challenges/medium/extract-to-object/index.md
---
# extractToObject
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/fibonacci-sequence/index.md
---
# FibonacciSequence
## 题目

Github: [FibonacciSequence](https://github.com/type-challenges/type-challenges/blob/main/questions/04182-medium-fibonacci-sequence/README.zh-CN.md)

实现一个通用的斐波那契函数 `Fibonacci<T>`，它接受一个数字 `T` 并返回其对应的 [斐波那契数](https://en.wikipedia.org/wiki/Fibonacci_number)。

序列开始为：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...

```ts
type Result1 = Fibonacci<3> // 2
type Result2 = Fibonacci<8> // 21
```

## 解题思路

斐波那契数列通常从0和1开始，后续的每一项都是前两项的和。数列的前几项如下：

$$
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \dots
$$

用数学公式表示为：

$$
F(0) = 0, \quad F(1) = 1
$$
$$
F(n) = F(n-1) + F(n-2) \quad (n \geq 2)
$$

在 Typescript 中不支持直接的加减乘除运算，但是对于 加法，我们可以通过 两个元组的合并，
取新合并的元组的长度来间接实现 加法 （对数字有范围限制，这通常由 Typescript 递归深度限制）。

已知 类型 `T` 表示 `n`，求 $F(n)$ 。因此我们需要知道 $F(n-1)$ 和 $F(n-2)$ ，
对 $F(n-1)$ 需要知道 $F(n-2)$ 和 $F(n-3)$ ， 以此类推，最终回到 $F(1)$ 和 $F(0)$ ，这也是我们已知的值。
换句话来说，我们需要知道 `n` 之前的所有 斐波那契数。

因此，不妨从 `n = 2` 开始，即求 $F(0)$ 和 $F(1)$ 的和，通过递归知道 `n = T` 时得到结果：

* 使用元组类型 `CurrentIndex` 的长度表示 `n` ，其默认长度为 `1` ，即 $n=1$ 。
* 使用元组类型 `Prev` 的长度表示 `n - 2` 的值，当 `n = 2` 时，即为 $F(0) = 0$ 。
* 使用元组类型 `Current` 的长度表示 `n - 1` 的值，当 `n = 2` 时，即为 $F(1) = 1$ 。

由于 `CurrentIndex` 默认长度为 `1`，此时 `Current` 即为 `n = 1` 时的 斐波那契数。

通过条件类型 `CurrentIndex['length'] extends T` 当为真时， `Current` 的长度即为 `n = T` 时的斐波那契数。

```ts
type Fibonacci<
  T extends number,
  CurrentIndex extends any[] = [1],
  Prev extends any[] = [],
  Current extends any[] = [1]
> = CurrentIndex['length'] extends T
  ? Current['length']
  : any
```

当为假时，我们继续迭代, 将 `Current` 传给 `Prev`, 并使用 `Current` 和 `Prev` 合并的新元组
作为 `Current` 的新值。同时别忘了需要对 `CurrentIndex` 新增一个成员：

```ts
type Fibonacci<
  T extends number,
  CurrentIndex extends any[] = [1],
  Prev extends any[] = [],
  Current extends any[] = [1]
> = CurrentIndex['length'] extends T
  ? Current['length']
  : Fibonacci<T, [...CurrentIndex, 1], Current, [...Prev, ...Current]> // [!code ++]
```

## 答案

```ts
type Fibonacci<
  T extends number,
  CurrentIndex extends any[] = [1],
  Prev extends any[] = [],
  Current extends any[] = [1]
> = CurrentIndex['length'] extends T
  ? Current['length']
  : Fibonacci<T, [...CurrentIndex, 1], Current, [...Prev, ...Current]>
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type Fibonacci<
  T extends number,
  CurrentIndex extends any[] = [1],
  Prev extends any[] = [],
  Current extends any[] = [1]
> = CurrentIndex['length'] extends T
  ? Current['length']
  : Fibonacci<T, [...CurrentIndex, 1], Current, [...Prev, ...Current]>

// ---cut---
type cases = [
  Expect<Equal<Fibonacci<1>, 1>>,
  Expect<Equal<Fibonacci<2>, 1>>,
  Expect<Equal<Fibonacci<3>, 2>>,
  Expect<Equal<Fibonacci<8>, 21>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /czxBlog/type-challenges/medium/fill/index.md
---
# Fill
## 题目

Github: [Fill](https://github.com/type-challenges/type-challenges/blob/main/questions/04518-medium-fill/README.md)

Fill，一个常见的JavaScript函数，现在让我们用类型来实现它。
`Fill<T, N, Start?, End?>`，如你所见，`Fill` 接受四种类型的参数，其中 `T` 和 `N` 是必需参数，
而 `Start` 和 `End` 是可选参数。
这些参数的要求是：`T` 必须是元组，`N` 可以是任何类型的值，`Start` 和 `End` 必须是大于或等于 `0` 的整数。

```ts
type exp = Fill<[1, 2, 3], 0> // expected to be [0, 0, 0]
```

## 解题思路

首先，我们从类型声明开始，类型 `Fill` 接受五个参数 `T`，`N`，`Start`，`End`，`Count`，`Flag`，
`T` 是一个元组，`N` 可以是任何类型的值, `Start` 和 `End` 必须是大于或等于 `0` 的整数。

**通过 `Count` 数组隐式追踪索引：**

* 在 `Count` 等于 `End` 的时候需要结束替换，也就是结束条件
* 当 `Count` 等于 `Start` 的时候是开始替换的条件，递归处理数组替换即可，注意需要把 `T` 换成新的

**使用 `Flag` 标记当前是否需要替换：**

* 通过 `Flag` 的默认值 `Count['length'] extends Start ? true : false` 智能触发状态切换。
* 仅在未显式传递 `Flag` 时 重新计算状态，实现状态锁存：
  * 当第一次进入填充区间时，`Flag` 被设置为 `true`
  * 后续递归中显式传递 `Flag` 参数，保持状态不变

**`Count['length'] extends End` 作为终止条件**

剩余元素直接保留原样，确保处理效率

## 答案

```ts
type Fill<
  T extends unknown[],
  N,
  Start extends number = 0,
  End extends number = T['length'],
  Count extends any[] = [],
  Flag extends boolean = Count['length'] extends Start ? true : false
> =
  Count['length'] extends End
    ? T
    : T extends [infer R, ...infer U]
      ? Flag extends false
        ? [R, ...Fill<U, N, Start, End, [...Count, 0]>]
        : [N, ...Fill<U, N, Start, End, [...Count, 0], Flag>]
      : T
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type Fill<
  T extends unknown[],
  N,
  Start extends number = 0,
  End extends number = T['length'],
  Count extends any[] = [],
  Flag extends boolean = Count['length'] extends Start ? true : false
> =
  Count['length'] extends End
    ? T
    : T extends [infer R, ...infer U]
      ? Flag extends false
        ? [R, ...Fill<U, N, Start, End, [...Count, 0]>]
        : [N, ...Fill<U, N, Start, End, [...Count, 0], Flag>]
      : T

// ---cut---
type cases = [
  Expect<Equal<Fill<[], 0>, []>>,
  Expect<Equal<Fill<[], 0, 0, 3>, []>>,
  Expect<Equal<Fill<[1, 2, 3], 0, 0, 0>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], 0, 2, 2>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], 0>, [0, 0, 0]>>,
  Expect<Equal<Fill<[1, 2, 3], true>, [true, true, true]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 0, 1>, [true, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 1, 3>, [1, true, true]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 10, 0>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 10, 20>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 0, 10>, [true, true, true]>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/medium/filter/index.md
---
# Filter
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/find-all/index.md
---
# findAll
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/first-unique-char-index/index.md
---
# FirstUniqueCharIndex
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/flatten-depth/index.md
---
# FlattenDepth
## 题目

递归地将数组扁平化，最多进行 `depth` 次。

```ts
type a = FlattenDepth<[1, 2, [3, 4], [[[5]]]], 2> // [1, 2, 3, 4, [5]]. 展开 2 次
type b = FlattenDepth<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, [[5]]]. 深度默认为 1
```

如果提供了深度，则保证其为正整数。

## 解题思路

我们已经在 [Flatten](./459.flatten.md) 这个挑战中知道应该如何将一个数组完全扁平化。

```ts
type Flatten<T extends unknown[]> = T extends [infer F, ...infer R]
  ? F extends unknown[]
    ? [...Flatten<F>, ...Flatten<R>]
    : [F, ...Flatten<R>]
  : T
```

同样的思路可以应用到这个挑战多，只是多了一个限制条件，即最多进行 `depth` 次。

在 类型参数中添加一个 `Depth` 类型参数，表示最大次数。由于在 Typescript 中并不支持运算操作，
但我们可以通过给 元组添加成员，再获取元组的长度 来实现累加，添加一个 `R` 类型参数保存元组：

```ts
type FlattenDepth<
  T extends unknown[],
  Depth extends number = 1,
  R extends unknown[] = []
> = T extends [infer F, ...infer O]
  ? F extends unknown[]
    ? [...FlattenDepth<F, Depth, R>, ...FlattenDepth<O, Depth, R>]
  //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  //     实际只在这里进行一次展开
    : [F, ...FlattenDepth<O, Depth, R>]
  : T
```

我们只需要在实际展开的位置，在类型参数 `R` 中添加成员，通过 `R['length']` 获取最新长度，
判断是否达到 `Depth` 的最大限制。

## 答案

```ts
type FlattenDepth<
  T extends unknown[],
  Depth extends number = 1,
  R extends unknown[] = []
> = R['length'] extends Depth
  ? T
  : T extends [infer F, ...infer O]
    ? F extends unknown[]
      ? [...FlattenDepth<F, Depth, [unknown, ...R]>, ...FlattenDepth<O, Depth, R>]
      : [F, ...FlattenDepth<O, Depth, R>]
    : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type FlattenDepth<
  T extends unknown[],
  Depth extends number = 1,
  R extends unknown[] = []
> = R['length'] extends Depth
  ? T
  : T extends [infer F, ...infer O]
    ? F extends unknown[]
      ? [...FlattenDepth<F, Depth, [unknown, ...R]>, ...FlattenDepth<O, Depth, R>]
      : [F, ...FlattenDepth<O, Depth, R>]
    : T

// ---cut---
type cases = [
  Expect<Equal<FlattenDepth<[]>, []>>,
  Expect<Equal<FlattenDepth<[1, 2, 3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<FlattenDepth<[1, [2]]>, [1, 2]>>,
  Expect<Equal<FlattenDepth<[1, 2, [3, 4], [[[5]]]], 2>, [1, 2, 3, 4, [5]]>>,
  Expect<Equal<FlattenDepth<[1, 2, [3, 4], [[[5]]]]>, [1, 2, 3, 4, [[5]]]>>,
  Expect<Equal<FlattenDepth<[1, [2, [3, [4, [5]]]]], 3>, [1, 2, 3, 4, [5]]>>,
  Expect<Equal<FlattenDepth<[1, [2, [3, [4, [5]]]]], 19260817>, [1, 2, 3, 4, 5]>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /czxBlog/type-challenges/medium/flatten/index.md
---
# 数组扁平化
## 题目

Github: [Flatten](https://github.com/type-challenges/type-challenges/blob/main/questions/00459-medium-flatten/)

在这个挑战中，你需要写一个接受数组的类型，并且返回扁平化的数组类型。

```ts
type flatten = Flatten<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, 5]
```

## 解题思路

首先挑战限制了只能接受数组，因此我们需要使用条件类型限制泛型参数 `T`

```ts
type Flatten<T extends unknown[]> = any
```

由于我们不知道数组的每个成员是数组类型还是其他类型，所以我们需要依次对数组的每个成员进行判断。
这需要使用条件类型类型推断，获取数组的成员。

```ts
type Flatten<T extends unknown[]> = T extends [infer L, ...infer R] ? L : T
```

在获取到第一个成员 `L` 后，我们需要判断它是否是数组类型，以检查它是否需要继续扁平化。
并对剩余成员进行递归处理，直到没有成员需要继续扁平化。

## 答案

```ts
type Flatten<T extends unknown[]> = T extends [infer L, ...infer R]
  ? L extends unknown[]
    ? [...Flatten<L>, ...Flatten<R>]
    : [L, ...Flatten<R>]
  : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Flatten<T extends unknown[]> = T extends [infer L, ...infer R]
  ? L extends unknown[] ? [...Flatten<L>, ...Flatten<R>] : [L, ...Flatten<R>]
  : T
// ---cut---
type cases = [
  Expect<Equal<Flatten<[]>, []>>,
  Expect<Equal<Flatten<[1, 2, 3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<Flatten<[1, [2]]>, [1, 2]>>,
  Expect<Equal<Flatten<[1, 2, [3, 4], [[[5]]]]>, [1, 2, 3, 4, 5]>>,
  Expect<Equal<Flatten<[{ foo: 'bar', 2: 10 }, 'foobar']>, [{ foo: 'bar', 2: 10 }, 'foobar']>>,
]

// @ts-expect-error ignore
type error = Flatten<'1'>
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /czxBlog/type-challenges/medium/flip-arguments/index.md
---
# FlipArguments
## 题目

Github: [FlipArguments](https://github.com/type-challenges/type-challenges/blob/main/questions/03196-medium-flip-arguments/)

实现 `lodash` 的 `_.flip` 的类型版本。

类型 `FlipArguments<T>` 要求函数类型 `T`，并返回一个新的函数类型，该类型具有与 `T` 相同的返回类型，但参数顺序相反。

```ts
type Flipped = FlipArguments<(arg0: string, arg1: number, arg2: boolean) => void>
// (arg0: boolean, arg1: number, arg2: string) => void
```

## 解题思路

由于我们已经在 [Reverse](./3192.reverse.md) 中实现了数组翻转。此挑战剩余的问题已十分简单，
利用条件类型推断获取 参数数组，对齐翻转 即可完成挑战。

## 答案

```ts
type Reverse<T extends unknown[]> = T extends [infer L, ...infer O]
  ? [...Reverse<O>, L]
  : T

type FlipArguments<
  T extends (...args: any[]) => any
> = T extends (...args: infer P) => infer R
  ? (...args: Reverse<P>) => R
  : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Reverse<T extends unknown[]> = T extends [infer L, ...infer O]
  ? [...Reverse<O>, L]
  : T

type FlipArguments<
  T extends (...args: any[]) => any
> = T extends (...args: infer P) => infer R
  ? (...args: Reverse<P>) => R
  : never

// ---cut---
type cases = [
  Expect<Equal<FlipArguments<() => boolean>, () => boolean>>,
  Expect<Equal<FlipArguments<(foo: string) => number>, (foo: string) => number>>,
  Expect<Equal<FlipArguments<(arg0: string, arg1: number, arg2: boolean) => void>, (arg0: boolean, arg1: number, arg2: string) => void>>,
]

type errors = [
  // @ts-expect-error
  FlipArguments<'string'>,
  // @ts-expect-error
  FlipArguments<{ key: 'value' }>,
  // @ts-expect-error
  FlipArguments<['apple', 'banana', 100, { a: 1 }]>,
  // @ts-expect-error
  FlipArguments<null | undefined>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive conditional types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/flip/index.md
---
# Flip
## 题目

Github: [Flip](https://github.com/type-challenges/type-challenges/blob/main/questions/04179-medium-flip/)

实现仅翻转对象的类型。

```ts
Flip<{ a: 'x', b: 'y', c: 'z' }> // {x: 'a', y: 'b', z: 'c'}
Flip<{ a: 1, b: 2, c: 3 }> // {1: 'a', 2: 'b', 3: 'c'}
Flip<{ a: false, b: true }> // {false: 'a', true: 'b'}
```

无需支持嵌套对象以及无法作为对象键的值（如数组）。

## 解题思路

这道题目相对简单，只需使用 映射类型，然后对 对象的 `key` 重映射为预期的类型即可。

## 答案

```ts
type AllowedTypes = string | number | boolean

type Flip<T> = {
  [P in keyof T as T[P] extends AllowedTypes ? `${T[P]}` : never]: P
}
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type AllowedTypes = string | number | boolean

type Flip<T> = {
  [P in keyof T as T[P] extends AllowedTypes ? `${T[P]}` : never]: P
}

// ---cut---
type cases = [
  Expect<Equal<{ a: 'pi' }, Flip<{ pi: 'a' }>>>,
  Expect<NotEqual<{ b: 'pi' }, Flip<{ pi: 'a' }>>>,
  Expect<Equal<{ 3.14: 'pi', true: 'bool' }, Flip<{ pi: 3.14, bool: true }>>>,
  Expect<Equal<{ val2: 'prop2', val: 'prop' }, Flip<{ prop: 'val', prop2: 'val2' }>>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [通过 `as` 进行按键重映射 Key remapping via `as`](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)

---

---
url: /czxBlog/type-challenges/medium/get-middle-element/index.md
---
# GetMiddleElement
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/get-return-type/index.md
---
# 获取函数返回类型
## 题目

Github: [Get return type](https://github.com/type-challenges/type-challenges/blob/main/questions/00002-medium-return-type/)

不使用 `ReturnType` 实现 `TypeScript` 的 `ReturnType<T>` 泛型。

```ts
function fn(v: boolean) {
  if (v)
    return 1
  else return 2
}

type a = MyReturnType<typeof fn> // 应推导出 "1 | 2"
```

## 解题思路

使用条件类型中的类型推断，泛型参数 `T` 是否可以分配给 `() => void`。

通过类型参数从条件类型推断为真时，获取函数返回类型 `() => infer R` 。

我们并不关心函数是否带参数，需要带上参数 `...args: any[]` 表示可以接受任何参数。

## 答案

```ts
type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never

// ---cut---
type cases = [
  Expect<Equal<string, MyReturnType<() => string>>>,
  Expect<Equal<123, MyReturnType<() => 123>>>,
  Expect<Equal<ComplexObject, MyReturnType<() => ComplexObject>>>,
  Expect<Equal<Promise<boolean>, MyReturnType<() => Promise<boolean>>>>,
  Expect<Equal<() => 'foo', MyReturnType<() => () => 'foo'>>>,
  Expect<Equal<1 | 2, MyReturnType<typeof fn>>>,
  Expect<Equal<1 | 2, MyReturnType<typeof fn1>>>,
]

interface ComplexObject {
  a: [12, 'foo']
  bar: 'hello'
  prev: () => number
}

const fn = (v: boolean) => v ? 1 : 2
const fn1 = (v: boolean, w: any) => v ? 1 : 2
```

## 参考

> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/greater-than/index.md
---
# GreaterThan
## 题目

Github: [GreaterThan](https://github.com/type-challenges/type-challenges/blob/main/questions/04425-medium-greater-than/)

在此挑战中，您需要实现一个类型 `GreaterThan<T, U>`，类似于 `T > U`。

无需考虑负数。

```ts
GreaterThan<2, 1> // should be true
GreaterThan<1, 1> // should be false
GreaterThan<10, 100> // should be false
GreaterThan<111, 11> // should be true
```

## 解题思路

比较大小在 JavaScript 中是非常容易的事情，但是放到 typescript 的类型系统中，就不那么容易了。
typescript 的类型系统并不支持这些数学运算。

对于这个挑战，一开始很容易想到利用 数组 的特性来解决，通过构建两个长度为 `T` 和 `U` 的数组，判断
`ArrU` 是否是 `ArrT` 的子集，如果是的话，那么 `T` 就比 `U` 大，反之则不是。对于构建特定长度的数组，
可以使用递归的方式来实现。

```ts
type LenToArr<T extends number, R extends any[] = []> = R['length'] extends T
  ? R
  : LenToArr<T, [...R, 0]>

type GreaterThan<T extends number, U extends number> =
  LenToArr<U> extends [...LenToArr<T>, ...infer _] ? false : true
```

我们使用这个实现来进行验证：

```ts twoslash
// @errors: 2589
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type LenToArr<T extends number, R extends any[] = []> = R['length'] extends T
  ? R
  : LenToArr<T, [...R, 0]>

type GreaterThan<T extends number, U extends number> =
  LenToArr<U> extends [...LenToArr<T>, ...infer _] ? false : true

// ---cut---
type cases = [
  Expect<Equal<GreaterThan<1, 0>, true>>,
  Expect<Equal<GreaterThan<5, 4>, true>>,
  Expect<Equal<GreaterThan<4, 5>, false>>,
  Expect<Equal<GreaterThan<0, 0>, false>>,
  Expect<Equal<GreaterThan<10, 9>, true>>,
  Expect<Equal<GreaterThan<20, 20>, false>>,
  Expect<Equal<GreaterThan<10, 100>, false>>,
  Expect<Equal<GreaterThan<111, 11>, true>>,
  Expect<Equal<GreaterThan<13, 12>, true>>,
  Expect<Equal<GreaterThan<1234567891011, 1234567891010>, true>>,
]
```

可以看到，在数字比较小时，通过 递归实现的类型是可以通过的，但是在大数字时，会出现错误，
这是因为 typescript 的类型系统对递归有深度限制。

因此，通过递归实现并不是最优解。

我们不妨将数字转为字符串，通过比对字符串来实现，这可以避免递归深度的问题。

我们可以延续 [minus one](./2257.minusOne.md) 挑战中的思路，将数字转为字符串，然后分别对相对应
的位数进行比较，最终得到结果。

**对于两个不同的十以内的数，通过检查这两个数分别位于 `0123456789` 的位置判断大小：**

```ts
type GreaterThan<T extends number, U extends number> =
  '0123456789' extends `${string}${T}${string}${U}${string}`
    ? false
    : true
```

当 `T` 位于 `U` 的左侧时，则说明 `T` 小于 `U`, 反之则 `T` 大于 `U`。

**检查两个数字字符串的长度，根据长度判断大小：**

```ts
type DigitCountArr<T extends string> = T extends `${string}${infer R}`
  ? [0, ...DigitCountArr<R>]
  : []

type DigitCountCompare<
  T extends number,
  U extends number
> = '0123456789' extends `${string}${T}${string}${U}${string}`
  ? '<'
  : '0123456789' extends `${string}${U}${string}${T}${string}`
    ? '>'
    : '='
```

**当两个数字字符串的长度相同时，分别对每位位数进行比较：**

```ts
type GreaterThanSameDigitCount<
  T extends number | string,
  U extends number | string
> = `${T}` extends `${infer TF}${infer TR}`
  ? `${U}` extends `${infer UF}${infer UR}`
    ? TF extends UF
      ? GreaterThanSameDigitCount<TR, UR>
      : '0123456789' extends `${string}${TF}${string}${UF}${string}`
        ? false
        : true
    : true
  : false
```

## 答案

```ts
type DigitCountArr<T extends string> = T extends `${string}${infer R}`
  ? [0, ...DigitCountArr<R>]
  : []

type DigitCountCompare<
  T extends number,
  U extends number
> = '0123456789' extends `${string}${T}${string}${U}${string}`
  ? '<'
  : '0123456789' extends `${string}${U}${string}${T}${string}`
    ? '>'
    : '='

type GreaterThanSameDigitCount<
  T extends number | string,
  U extends number | string
> = `${T}` extends `${infer TF}${infer TR}`
  ? `${U}` extends `${infer UF}${infer UR}`
    ? TF extends UF
      ? GreaterThanSameDigitCount<TR, UR>
      : '0123456789' extends `${string}${TF}${string}${UF}${string}`
        ? false
        : true
    : true
  : false

type GreaterThan<
  T extends number | string,
  U extends number | string,
  C = DigitCountCompare<DigitCountArr<`${T}`>['length'], DigitCountArr<`${U}`>['length']>
> = C extends '='
  ? GreaterThanSameDigitCount<T, U>
  : C extends '>'
    ? true
    : false
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type DigitCountArr<T extends string> = T extends `${string}${infer R}` ? [0, ...DigitCountArr<R>] : []
type DigitCountCompare<T extends number, U extends number> = '0123456789' extends `${string}${T}${string}${U}${string}`
  ? '<'
  : '0123456789' extends `${string}${U}${string}${T}${string}`
    ? '>'
    : '='
type GreaterThanSameDigitCount<T extends number | string, U extends number | string> =
  `${T}` extends `${infer TF}${infer TR}`
    ? `${U}` extends `${infer UF}${infer UR}`
      ? TF extends UF
        ? GreaterThanSameDigitCount<TR, UR>
        : '0123456789' extends `${string}${TF}${string}${UF}${string}`
          ? false
          : true
      : true
    : false

type GreaterThan<
  T extends number | string,
  U extends number | string,
  C = DigitCountCompare<DigitCountArr<`${T}`>['length'], DigitCountArr<`${U}`>['length']>
> = C extends '='
  ? GreaterThanSameDigitCount<T, U>
  : C extends '>'
    ? true
    : false

// ---cut---
type cases = [
  Expect<Equal<GreaterThan<1, 0>, true>>,
  Expect<Equal<GreaterThan<5, 4>, true>>,
  Expect<Equal<GreaterThan<4, 5>, false>>,
  Expect<Equal<GreaterThan<0, 0>, false>>,
  Expect<Equal<GreaterThan<10, 9>, true>>,
  Expect<Equal<GreaterThan<20, 20>, false>>,
  Expect<Equal<GreaterThan<10, 100>, false>>,
  Expect<Equal<GreaterThan<111, 11>, true>>,
  Expect<Equal<GreaterThan<13, 12>, true>>,
  Expect<Equal<GreaterThan<1234567891011, 1234567891010>, true>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [泛型约束 Generics constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/in-order-traversal/index.md
---
# InorderTraversal
## 题目

Github: [InorderTraversal](https://github.com/type-challenges/type-challenges/blob/main/questions/03376-medium-inordertraversal/README.md)

实现二叉树中序遍历的类型版本。

```ts
const tree1 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: {
      val: 3,
      left: null,
      right: null,
    },
    right: null,
  },
} as const

type A = InorderTraversal<typeof tree1> // [1, 3, 2]
```

## 解题思路

在二叉树的有序遍历中，我们遍历一个节点的子树，然后“访问”这个节点，然后遍历它的另 一个子树。通常，我们会先遍历左子树，然后再遍历节点的右子树。

```txt
      A
    /   \
   B     C
 /   \
D     E

In-order Traversal: D, B, E, A, C
```

## 答案

```ts
interface TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
}

type InorderTraversal<
  T extends TreeNode | null,
  R extends TreeNode = NonNullable<T>
> =
  T extends null
    ? []
    : [...InorderTraversal<R['left']>, R['val'], ...InorderTraversal<R['right']>]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

interface TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
}

type InorderTraversal<
  T extends TreeNode | null,
  R extends TreeNode = NonNullable<T>
> =
  T extends null
    ? []
    : [...InorderTraversal<R['left']>, R['val'], ...InorderTraversal<R['right']>]

// ---cut---
const tree1 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: {
      val: 3,
      left: null,
      right: null,
    },
    right: null,
  },
} as const

const tree2 = {
  val: 1,
  left: null,
  right: null,
} as const

const tree3 = {
  val: 1,
  left: {
    val: 2,
    left: null,
    right: null,
  },
  right: null,
} as const

const tree4 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: null,
    right: null,
  },
} as const

type cases = [
  Expect<Equal<InorderTraversal<null>, []>>,
  Expect<Equal<InorderTraversal<typeof tree1>, [1, 3, 2]>>,
  Expect<Equal<InorderTraversal<typeof tree2>, [1]>>,
  Expect<Equal<InorderTraversal<typeof tree3>, [2, 1]>>,
  Expect<Equal<InorderTraversal<typeof tree4>, [1, 2]>>,
]
```

## 参考

* [Tree Traversal Techniques](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /czxBlog/type-challenges/medium/index-of/index.md
---
# IndexOf
## 题目

Github: [IndexOf](https://github.com/type-challenges/type-challenges/blob/main/questions/05153-medium-indexof/)

实现数组的索引查找类型版本，`indexOf<T, U>` 接收一个数组 `T` 和任意类型 `U`，
并返回数组 `T` 中第一个 `U` 类型的元素的索引。

```ts
type Res = IndexOf<[1, 2, 3], 2> // expected to be 1
type Res1 = IndexOf<[2, 6, 3, 8, 4, 1, 7, 3, 9], 3> // expected to be 2
type Res2 = IndexOf<[0, 0, 0], 2> // expected to be -1
```

## 解题思路

本挑战的难点在于 如何判断一个类型是否严格等于另一个类型。

对于此难点，请参考 [类型系统的真假美猴王：破解 IsEqual\<X, Y> 之谜](../../../1.前端/12.TypeScript/isEqual.md)

通过 条件类型 `infer`，从数组 `T` 中，通过递归的方式取出一个个元素，判断是否严格等于类型 `U`，
如果是，则直接返回 `R['length']` 的长度，否则继续递归取下一个元素，并为 `R` 添加一个元素。

由于开始递归时，类型`R` 为空数组，因此此时的 `R['length']` 恰好 为 `0`。

## 答案

```ts
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2) ? true : false

type IndexOf<T extends unknown[], U, R extends unknown[] = []> =
  T extends [infer F, ...infer O]
    ? Equal<U, F> extends true
      ? R['length']
      : IndexOf<O, U, [unknown, ...R]>
    : -1
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type IndexOf<T extends unknown[], U, R extends unknown[] = []> =
  T extends [infer F, ...infer O]
    ? Equal<U, F> extends true
      ? R['length']
      : IndexOf<O, U, [unknown, ...R]>
    : -1

// ---cut---
type cases = [
  Expect<Equal<IndexOf<[1, 2, 3], 2>, 1>>,
  Expect<Equal<IndexOf<[2, 6, 3, 8, 4, 1, 7, 3, 9], 3>, 2>>,
  Expect<Equal<IndexOf<[0, 0, 0], 2>, -1>>,
  Expect<Equal<IndexOf<[string, 1, number, 'a'], number>, 2>>,
  Expect<Equal<IndexOf<[string, 1, number, 'a', any], any>, 4>>,
  Expect<Equal<IndexOf<[string, 'a'], 'a'>, 1>>,
  Expect<Equal<IndexOf<[any, 1], 1>, 1>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/medium/integer/index.md
---
# Integer
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/is-alphabet/index.md
---
# isAlphabet
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/is-never/index.md
---
# IsNever
## 题目

Github: [IsNever](https://github.com/type-challenges/type-challenges/blob/main/questions/01042-medium-isnever/)

实现一个类型 `IsNever`，它接受输入类型 `T`。如果 `T` 解析为 `never`，则返回 `true`，否则返回 `false`。

```ts
type A = IsNever<never> // expected to be true
type B = IsNever<undefined> // expected to be false
type C = IsNever<null> // expected to be false
type D = IsNever<[]> // expected to be false
type E = IsNever<number> // expected to be false
```

## 解题思路

在 typescript 中，我们不能通过 `T extends never ？ true : false` 判断一个类型是否为 `never`，
因为 在 `T extends never` 中 `never` 本质上是一个没有成员的联合类型，
这导致了 `never extends never ? true : false` 整体被跳过了，得到的结果为 `never` , 而不是 `true/false`。

要避免这种情况，可以在`extends` 两边的类型用方括号包裹，这可以避免 触发条件类型分支。

## 答案

```ts
type IsNever<T> = [T] extends [never] ? true : false
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type IsNever<T> = [T] extends [never] ? true : false

// ---cut---
type cases = [
  Expect<Equal<IsNever<never>, true>>,
  Expect<Equal<IsNever<never | string>, false>>,
  Expect<Equal<IsNever<''>, false>>,
  Expect<Equal<IsNever<undefined>, false>>,
  Expect<Equal<IsNever<null>, false>>,
  Expect<Equal<IsNever<[]>, false>>,
  Expect<Equal<IsNever<{}>, false>>,
]
```

## 参考

* [Never Types](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

---

---
url: /czxBlog/type-challenges/medium/is-odd/index.md
---
# isOdd
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/is-tuple/index.md
---
# IsTuple
## 题目

Github: [IsTuple](https://github.com/type-challenges/type-challenges/blob/main/questions/04484-medium-istuple/README.md)

实现一个类型 `IsTuple`，它接受一个输入类型 `T` 并返回 `T` 是否为元组类型。

```ts
type case1 = IsTuple<[number]> // true
type case2 = IsTuple<readonly [number]> // true
type case3 = IsTuple<number[]> // false
```

## 解题思路

在 typescript 类型系统中，普通数组类型和元组类型的核心区别在于其 `length` 属性的类型。
数组的 `length` 是泛用的 `number` 类型，而 元组类型的 `length` 是具体的数组字面量类型（如 `2`）。
根据这个差异，我们可以通过条件类型来判断一个类型是否为元组类型。

**检查是否为数组类型：**

首先确定 `T` 是否继承自 `readonly any[]`（兼容普通数组和元组，包括只读元组）。

**判断 length 类型：**

若 `T` 是数组类型，进一步检查其 `length` 属性的类型是否为 `number`。若 `number extends T['length']` 成立，
说明 `T` 是普通数组（`length` 是 `number`），否则是元组（length 是具体数字）。

**别忘了处理传入的类型参数为 `never` 类型时的情况**

## 答案

```ts
type IsTuple<T> = [T] extends [never]
  ? false
  : T extends readonly any[]
    ? number extends T['length']
      ? false
      : true
    : false
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type IsTuple<T> = [T] extends [never]
  ? false
  : T extends readonly any[]
    ? number extends T['length']
      ? false
      : true
    : false

// ---cut---
type cases = [
  Expect<Equal<IsTuple<[]>, true>>,
  Expect<Equal<IsTuple<[number]>, true>>,
  Expect<Equal<IsTuple<readonly [1]>, true>>,
  Expect<Equal<IsTuple<{ length: 1 }>, false>>,
  Expect<Equal<IsTuple<number[]>, false>>,
  Expect<Equal<IsTuple<never>, false>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/medium/is-union/index.md
---
# IsUnion
## 题目

Github: [IsUnion](https://github.com/type-challenges/type-challenges/blob/main/questions/01097-medium-isunion/)

实现一个类型 `IsUnion`，它接受一个输入类型 `T` 并返回 `T` 是否解析为联合类型。

```ts
type case1 = IsUnion<string> // false
type case2 = IsUnion<string | number> // true
type case3 = IsUnion<[string | number]> // false
```

## 解题思路

> 起初看到这道题目时，我有些无从下手，在看了 [#1140](https://github.com/type-challenges/type-challenges/issues/1140#issue-838282400) 的回答后才恍然大悟。

首先，我们需要思考 联合类型 及其含义。

当我们指定一个普通类型时，比如 `string`，它将永远是字符串。当我们指定一个联合类型时，比如 `string | number` ,
它可以是 字符串，也可以是 数值 。

普通类型并不能表示一组值，但是 联合类型 可以。因此，在 普通类型 上进行分布式迭代是没有意义的，但对于 联合类型
来说是有意义的。

这就是我们如何检测是否是 联合类型 的关键点。但对 类型 `T` （普通类型）进行分布式迭代时，它不会产生变化，
但如果 类型 `T` 是 联合类型，它会产生比较大的变化。

当我们构造一个 `T extends T ? ConditionTrue<T> : never` 时，比如 `T` 为 联合类型 `string | number`:

```mermaid
---
title: "T extends T ? ConditionTrue<T> : never"
---
flowchart TD
A["T extends string | number"]
B["string extends string | number"]
C["number extends string | number"]
D["ConditionTrue&lt;string&gt;"]
E["ConditionTrue&lt;number&gt;"]
A --> B -- true --> D
A --> C -- true --> E
```

我们继续构造 `ConditionTrue<T> = string | number extends T ? true : false`：

```mermaid
---
title: "string | number extends T ? true : false"
---
flowchart TD
A["string | number extends string"]
B["string | number extends number"]
C["string extends string"]
D["number extends string"]
E["string extends number"]
F["number extends number"]
A --> C --> G[true] --> K[false] --> M[false]
A --> D --> H[false] --> K
B --> E --> I[false] --> L[false] --> M
B --> F --> J[true] --> L

```

看到了吧！如果 `T` 是联合类型，那么它的每个元素 `subT` 必然不能满足 `T extends subT` 。

基于以上，我们可以开始实现 `IsUnion` 类型。

首先保存一个类型 `T` 的副本，以方便后续的使用：

```ts
type IsUnion<T, C extends T = T> = never
```

通过应用条件类型，我们得到了分布式语义。在条件类型的 true 分支中，我们将获取联合 类型中的每一项。

```ts
type IsUnion<T, C extends T = T> = T extends T ? true : never
```

接下来，将每一项与原来的输入类型T进行比较：

```ts
type IsUnion<T, C extends T = T> = T extends T
  ? C extends T
    ? false : true
  : never
```

当然，我们还需要完善一些边界情况。

## 答案

```ts
type IsUnion<T, C extends T = T> = (T extends T
  ? C extends T
    ? true
    : unknown
  : never) extends true
  ? false
  : true
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type IsUnion<T, C extends T = T> = (T extends T ? C extends T ? true : unknown : never) extends true ? false : true

// ---cut---
type cases = [
  Expect<Equal<IsUnion<string>, false>>,
  Expect<Equal<IsUnion<string | number>, true>>,
  Expect<Equal<IsUnion<'a' | 'b' | 'c' | 'd'>, true>>,
  Expect<Equal<IsUnion<undefined | null | void | ''>, true>>,
  Expect<Equal<IsUnion<{ a: string } | { a: number }>, true>>,
  Expect<Equal<IsUnion<{ a: string | number }>, false>>,
  Expect<Equal<IsUnion<[string | number]>, false>>,
  // Cases where T resolves to a non-union type.
  Expect<Equal<IsUnion<string | never>, false>>,
  Expect<Equal<IsUnion<string | unknown>, false>>,
  Expect<Equal<IsUnion<string | any>, false>>,
  Expect<Equal<IsUnion<string | 'a'>, false>>,
  Expect<Equal<IsUnion<never>, false>>,
]
```

## 参考

* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)
* [元组类型 Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-3.html#tuple-types)

---

---
url: /czxBlog/type-challenges/medium/join/index.md
---
# Join
## 题目

Github: [Join](https://github.com/type-challenges/type-challenges/blob/main/questions/05310-medium-join/)

实现数组类型的 `Array.join` 版本，`Join<T, U>` 接受一个数组 `T`，字符串或数字 `U`，并返回用 `U` 拼接后的数组 `T`。

```ts
type Res = Join<['a', 'p', 'p', 'l', 'e'], '-'> // expected to be 'a-p-p-l-e'
type Res1 = Join<['Hello', 'World'], ' '> // expected to be 'Hello World'
type Res2 = Join<['2', '2', '2'], 1> // expected to be '21212'
type Res3 = Join<['o'], 'u'> // expected to be 'o'
```

## 解题思路

略。

## 答案

```ts
type Join<T extends any[], U extends string | number = ','> =
  T extends [infer F, ...infer O]
    ? O['length'] extends 0
      ? `${F & string}`
      : `${F & string}${U}${Join<O, U>}`
    : ''
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Join<T extends any[], U extends string | number = ','> =
  T extends [infer F, ...infer O]
    ? O['length'] extends 0
      ? `${F & string}`
      : `${F & string}${U}${Join<O, U>}`
    : ''

// ---cut---
type cases = [
  Expect<Equal<Join<['a', 'p', 'p', 'l', 'e'], '-'>, 'a-p-p-l-e'>>,
  Expect<Equal<Join<['Hello', 'World'], ' '>, 'Hello World'>>,
  Expect<Equal<Join<['2', '2', '2'], 1>, '21212'>>,
  Expect<Equal<Join<['o'], 'u'>, 'o'>>,
  Expect<Equal<Join<[], 'u'>, ''>>,
  Expect<Equal<Join<['1', '1', '1']>, '1,1,1'>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /czxBlog/type-challenges/medium/json-schema-to-typescript/index.md
---
# jsonSchemaToTypeScript
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/kebab-case/index.md
---
# kebabCase
## 题目

Github: [KebabCase](https://github.com/type-challenges/type-challenges/blob/main/questions/00612-medium-kebabcase/)

将 `camelCase` 或 `PascalCase` 字符串替换为 `kebab-case` 。

`FooBarBaz` -> `foo-bar-baz`

```ts
type FooBarBaz = KebabCase<'FooBarBaz'>
const foobarbaz: FooBarBaz = 'foo-bar-baz'

type DoNothing = KebabCase<'do-nothing'>
const doNothing: DoNothing = 'do-nothing'
```

## 解题思路

使用模板字面量类型，以及条件类型推断，获取字符串中的首个字符和剩下的字符串：

```ts
type KebabCase<S extends string, > = S extends `${infer L}${infer O}` ? never : never
```

对于首个字符，因为它总是小写的，所以直接使用 `Uncapitalize` 将首个字符转为小写。

```ts
type KebabCase<S extends string, > = S extends `${infer L}${infer O}`
  ? `${Uncapitalize<L>}${O}`
  : never
```

但是对于剩下的字符串，我们需要考虑其首个字母是否是大写，如果是大写，则需要拼接 `-` 并转为小写，
如果是小写，则不需要进行处理。

同样的，借助内置类型 `Uncapitalize`，先将 `O` 转为小写，然后再使用 `T extends Uncapitalize<O>` 来判断首字母是否小写

```ts
type KebabCase<S extends string, > = S extends `${infer L}${infer O}`
  ? T extends Uncapitalize<T>
    ? `${Uncapitalize<L>}${O}`
    : `${Uncapitalize<L>}-${O}`
  : never
```

很显然，我们还需要对 类型 `O` 进行递归处理，直到没有剩余的字符串为止。

```ts
type KebabCase<S extends string, > = S extends `${infer L}${infer O}`
  ? O extends Uncapitalize<O>
    ? `${Uncapitalize<L>}${KebabCase<O>}`
    : `${Uncapitalize<L>}-${KebabCase<O>}`
  : never
```

别忘了，在不满足 `S extends ${infer L}${infer O}` 的情况下，需要返回原字符串 `S` 。

## 答案

```ts
type KebabCase<S extends string, > = S extends `${infer L}${infer O}`
  ? O extends Uncapitalize<O>
    ? `${Uncapitalize<L>}${KebabCase<O>}`
    : `${Uncapitalize<L>}-${KebabCase<O>}`
  : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type KebabCase<S extends string, > = S extends `${infer L}${infer O}`
  ? O extends Uncapitalize<O>
    ? `${Uncapitalize<L>}${KebabCase<O>}`
    : `${Uncapitalize<L>}-${KebabCase<O>}`
  : S

// ---cut---
type cases = [
  Expect<Equal<KebabCase<'FooBarBaz'>, 'foo-bar-baz'>>,
  Expect<Equal<KebabCase<'fooBarBaz'>, 'foo-bar-baz'>>,
  Expect<Equal<KebabCase<'foo-bar'>, 'foo-bar'>>,
  Expect<Equal<KebabCase<'foo_bar'>, 'foo_bar'>>,
  Expect<Equal<KebabCase<'Foo-Bar'>, 'foo--bar'>>,
  Expect<Equal<KebabCase<'ABC'>, 'a-b-c'>>,
  Expect<Equal<KebabCase<'-'>, '-'>>,
  Expect<Equal<KebabCase<''>, ''>>,
  Expect<Equal<KebabCase<'😎'>, '😎'>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/last-index-of/index.md
---
# LastIndexOf
## 题目

实现类型版本的 `Array.lastIndexOf`, `LastIndexOf<T, U>` 接受数组 `T`, `any` 类型 `U`, 如果 `U` 存在于 `T` 中,
返回 `U` 在数组 `T` 中最后一个位置的索引, 不存在则返回 `-1`

```ts
type Res1 = LastIndexOf<[1, 2, 3, 2, 1], 2> // 3
type Res2 = LastIndexOf<[0, 0, 0], 2> // -1
```

## 解题思路

本挑战的难点在于 如何判断一个类型是否严格等于另一个类型。

对于此难点，请参考 [类型系统的真假美猴王：破解 IsEqual\<X, Y> 之谜](../../../1.前端/12.TypeScript/isEqual.md)

通过 条件类型 `infer`，从数组 `T` 中，通过递归的方式取出一个个元素，判断是否严格等于类型 `U`，
如果是，则直接返回 `R['length']` 的长度，否则继续递归取下一个元素，并为 `R` 添加一个元素。

递归时，类型`R` 的剩余数组长度，恰好为 `T` 的最后一个元素的索引。

## 答案

```ts
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2) ? true : false

type LastIndexOf<T extends unknown[], U> = T extends [...infer R, infer F]
  ? Equal<F, U> extends true
    ? R['length']
    : LastIndexOf<R, U>
  : -1
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type LastIndexOf<T extends unknown[], U> = T extends [...infer R, infer F]
  ? Equal<F, U> extends true
    ? R['length']
    : LastIndexOf<R, U>
  : -1

// ---cut---
type cases = [
  Expect<Equal<LastIndexOf<[1, 2, 3, 2, 1], 2>, 3>>,
  Expect<Equal<LastIndexOf<[2, 6, 3, 8, 4, 1, 7, 3, 9], 3>, 7>>,
  Expect<Equal<LastIndexOf<[0, 0, 0], 2>, -1>>,
  Expect<Equal<LastIndexOf<[string, 2, number, 'a', number, 1], number>, 4>>,
  Expect<Equal<LastIndexOf<[string, any, 1, number, 'a', any, 1], any>, 5>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/medium/last-of-array/index.md
---
# 最后一个元素
## 题目

Github: [Last of array](https://github.com/type-challenges/type-challenges/blob/main/questions/00015-medium-last/)

实现一个通用`Last<T>`，它接受一个数组T并返回其最后一个元素的类型。

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

type tail1 = Last<arr1> // expected to be 'c'
type tail2 = Last<arr2> // expected to be 1
```

## 解题思路

我们可以直接使用 **条件类型** 将数组的最后一个元素推导出来。

## 答案

```ts
type Last<T extends any[]> = T extends [...any[], infer R] ? R : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Last<T extends any[]> = T extends [...any[], infer R] ? R : never

// ---cut---
type cases = [
  Expect<Equal<Last<[]>, never>>,
  Expect<Equal<Last<[2]>, 2>>,
  Expect<Equal<Last<[3, 2, 1]>, 1>>,
  Expect<Equal<Last<[() => 123, { a: string }]>, { a: string }>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型内推断 Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变参数元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /czxBlog/type-challenges/medium/length-of-string/index.md
---
# 字符串长度
## 题目

[Github](https://github.com/type-challenges/type-challenges/blob/main/questions/00298-medium-length-of-string/)

计算字符串的长度，类似于 `String#length` 。

```ts
type length = LengthOfString<'Hello World'> // 11
```

## 解题思路

Typescript 类型系统不支持 `String['length']` 获取字符串的长度，同时，类型系统也没有提供可供累加计算的支持。

但幸运的是，我们可以很容易想到元组类型支持 `Tuple['length']` 获取元组的长度，因此我们可以把字符串转换为元组，
每个字符对应元组中的每个成员，通过元组的长度间接获取字符串的长度。

通过模板字面量类型，以及条件类型来实现字符串转换为元组。

## 答案

```ts
type LengthOfString<S extends string, U extends string[] = []> =
  S extends `${infer F}${infer T}`
    ? LengthOfString<T, [F, ...U]>
    : U['length']
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type LengthOfString<S extends string, U extends string[] = []> =
  S extends `${infer F}${infer T}`
    ? LengthOfString<T, [F, ...U]>
    : U['length']

// ---cut---
type cases = [
  Expect<Equal<LengthOfString<''>, 0>>,
  Expect<Equal<LengthOfString<'kumiko'>, 6>>,
  Expect<Equal<LengthOfString<'reina'>, 5>>,
  Expect<Equal<LengthOfString<'Sound! Euphonium'>, 16>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/medium/longest-common-prefix/index.md
---
# longestCommonPrefix
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/map-types/index.md
---
# MapTypes
## 题目

实现 `MapTypes<T, R>`，它将对象 `T` 中的类型转换为由类型 `R` 定义的不同类型，`R` 的结构如下：

```ts
interface StringToNumber {
  mapFrom: string // 值为字符串的键的值
  mapTo: number // 将被转换为数字
}
```

示例：

```ts
interface StringToNumber { mapFrom: string, mapTo: number }
MapTypes<{ iWillBeANumberOneDay: string }, StringToNumber>
// gives { iWillBeANumberOneDay: number; }
```

请注意，用户可以提供一个联合类型：

```ts
interface StringToNumber { mapFrom: string, mapTo: number }
interface StringToDate { mapFrom: string, mapTo: Date }

MapTypes<{ iWillBeNumberOrDate: string }, StringToDate | StringToNumber>
// gives { iWillBeNumberOrDate: number | Date; }
```

如果我们在映射中不存在这种类型，就让它保持原样：

```ts
interface StringToNumber { mapFrom: string, mapTo: number }
MapTypes<{ iWillBeANumberOneDay: string, iWillStayTheSame: Function }, StringToNumber>
// // gives { iWillBeANumberOneDay: number, iWillStayTheSame: Function }
```

## 解题思路

## 答案

```ts
type MapTypes<T, R extends { mapFrom: unknown, mapTo: unknown }> = {
  [P in keyof T]: T[P] extends R['mapFrom']
    ? R extends { mapFrom: T[P] }
      ? R['mapTo']
      : never
    : T[P]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type MapTypes<T, R extends { mapFrom: unknown, mapTo: unknown }> = {
  [P in keyof T]: T[P] extends R['mapFrom']
    ? R extends { mapFrom: T[P] }
      ? R['mapTo']
      : never
    : T[P]
}
// ---cut---
type cases = [
  Expect<Equal<MapTypes<{ stringToArray: string }, { mapFrom: string, mapTo: [] }>, { stringToArray: [] }>>,
  Expect<Equal<MapTypes<{ stringToNumber: string }, { mapFrom: string, mapTo: number }>, { stringToNumber: number }>>,
  Expect<Equal<MapTypes<{ stringToNumber: string, skipParsingMe: boolean }, { mapFrom: string, mapTo: number }>, { stringToNumber: number, skipParsingMe: boolean }>>,
  Expect<Equal<MapTypes<{ date: string }, { mapFrom: string, mapTo: Date } | { mapFrom: string, mapTo: null }>, { date: null | Date }>>,
  Expect<Equal<MapTypes<{ date: string }, { mapFrom: string, mapTo: Date | null }>, { date: null | Date }>>,
  Expect<Equal<MapTypes<{ fields: Record<string, boolean> }, { mapFrom: Record<string, boolean>, mapTo: string[] }>, { fields: string[] }>>,
  Expect<Equal<MapTypes<{ name: string }, { mapFrom: boolean, mapTo: never }>, { name: string }>>,
  Expect<Equal<MapTypes<{ name: string, date: Date }, { mapFrom: string, mapTo: boolean } | { mapFrom: Date, mapTo: string }>, { name: boolean, date: string }>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /czxBlog/type-challenges/medium/merge-all/index.md
---
# mergeAll
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/merge/index.md
---
# 合并两个类型
## 题目

Github: [Merge](https://github.com/type-challenges/type-challenges/blob/main/questions/00599-medium-merge/)

将两个类型合并成一个类型，第二个类型的键会覆盖第一个类型的键。

```ts
interface foo {
  name: string
  age: string
}

interface coo {
  age: number
  sex: string
}

type Result = Merge<foo, coo> // expected to be {name: string, age: number, sex: string}
```

## 解题思路

首先使用 `keyof` 和联合类型获取两个类型的所有 `key`

```ts
type Merge<F, S> = {
  [K in keyof F | keyof S]: any
}
```

接下来，判断 `K` 是否在 `S` 中，如果在，返回 `S[K]`：

```ts
type Merge<F, S> = {
  [K in keyof F | keyof S]: K extends keyof S ? S[K] : any
}
```

最后，判断 `K` 是否在 `F` 中，如果在，返回 `F[K]`

```ts
type Merge<F, S> = {
  [K in keyof F | keyof S]: K extends keyof S ? S[K] : K extends keyof F ? F[K] : never
}
```

## 答案

```ts
type Merge<F, S> = {
  [K in keyof F | keyof S]: K extends keyof S
    ? S[K]
    : K extends keyof F
      ? F[K]
      : never
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Merge<F, S> = {
  [K in keyof F | keyof S]: K extends keyof S
    ? S[K]
    : K extends keyof F
      ? F[K]
      : never
}

// ---cut---
interface Foo {
  a: number
  b: string
}
interface Bar {
  b: number
  c: boolean
}

type cases = [
  Expect<Equal<Merge<Foo, Bar>, {
    a: number
    b: number
    c: boolean
  }>>,
]
```

## 参考

* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [查找类型 Lookup Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /czxBlog/type-challenges/medium/minus-one/index.md
---
# Minus One
## 题目

Github: [MinusOne](https://github.com/type-challenges/type-challenges/blob/main/questions/02257-medium-minusone/)

给定一个正整数作为类型的参数，要求返回的类型是该数字减 1。

```ts
type Zero = MinusOne<1> // 0
type FiftyFour = MinusOne<55> // 54
```

## 解题思路

这个挑战咋一看似乎很简单，但是别忘了，Typescript 类型系统是不支持 算术运算 的，即无法直接进行
加减乘除运算，这让我们即便是实现 **减去一** 都变得不那么简单了。

一开始，我想到的是利用 可变元祖类型 的长度，通过 将特定长度的元组删去一个成员，然后通过 `T['length']` 获取
新的长度 实现 减一。

```ts
type MinusOne<T extends number, R extends unknown[] = []> = R['length'] extends T
  ? R extends [infer _, ...infer O] ? O['length'] : never
  : MinusOne<T, [unknown, ...R]>
```

这个实现看起来完成了这个挑战，但是却存在潜在的问题。

**发现了吗，`T` 的值越大，递归的深度越深！**

我们找一个比较大一点的数试试：

```ts twoslash
// @errors: 2589
type MinusOne<T extends number, R extends unknown[] = []> = R['length'] extends T
  ? R extends [infer _, ...infer O] ? O['length'] : never
  : MinusOne<T, [unknown, ...R]>
// ---cut---
type n = MinusOne<1100>
```

很显然，这已经超过 Typescript 的递归深度限制了，而且由于 递归深度太深，需要消耗的时间也非常夸张，
这显然是不可接受的。

> 以下解答来自于 [#13507](https://github.com/type-challenges/type-challenges/issues/13507) 。

我们回归到 减法运算本身，对数字减去 `1`，以个位数的运算如下：

* `9 - 1 = 8`
* `8 - 1 = 7`
* `7 - 1 = 6`
* ...
* `1 - 1 = 0`

当个位数为 `0` ，减去 `1`时 ，则 个位数 变为 `9`，同时 十位数 也需要减去 `1`。

在十位数上为 `0` 减去 `1` 时，十位数变更为 `9`，同时 百位数也需要减去 `1`。

千位数、万位数、 ... 以此类推。

这告诉我们，可以单独处理每位数的运算，在当前位数为 `0`时，则继续对下一位数进行处理。

太棒了，我们不再需要创建一个冗长的元组，再用元组的长度去求值！现在，迭代深度只跟数字的位数相关！

为了便于处理，我们需要先将 数字转为 字符串，然后通过 模板字面量类型中的类型推理，取出数字中的每一位数。

由于 `T extends ${infer F}${infer R}` 是从左往右依次提取单个字符 `F`, 我们可以先将 数字字符串进行翻转，
在完成处理后再翻转回来。

```ts
type ReverseString<S extends string> = S extends `${infer First}${infer Rest}`
  ? `${ReverseString<Rest>}${First}`
  : ''

type MinusOne<T extends number> = ReverseString<`${T}`>
```

接下来，我们对单个位数进行 减 `1` 处理。由于现在我们只需要考虑 10 个 数字的 减 `1` 操作，因为我们
可以取巧，直接用元组保存运算结果，以 元组索引作为原始值，以索引对应的值作为 减 `1` 后的结果：

```ts
type Result<Index extends number> = [9, 0, 1, 2, 3, 4, 5, 6, 7, 8][Index]
```

比如索引为 `7` 时，取得的值为 `6`。

现在，我们从 数字字符串中取出每一位数，进行处理：

```ts
type InternalMinusOne<
  S extends string
> = S extends `${infer Digit extends number}${infer Rest}`
  ? never
  : never
```

你可能注意到，`infer Digit extends number`，这是为了约束在 模板字面量类型中的类型推理时， `Digit` 约束为
`number` 类型，因为 **元组的索引类型应该为 `number`** ，否则无法访问元组中的成员。

对于取出的 `Digit` ，当其值为 `0` 时，我们需要继续处理剩余位数，而非 `0` 时，则可以直接从 `Result<T>`
中取出结果，与剩余的 `Rest` 拼接得到结果：

```ts
type InternalMinusOne<
  S extends string
> = S extends `${infer Digit extends number}${infer Rest}`
  ? Digit extends 0
    ? `9${InternalMinusOne<Rest>}`
    : `${[9, 0, 1, 2, 3, 4, 5, 6, 7, 8][Digit]}${Rest}`
  : never

type MinusOne<T extends number> = InternalMinusOne<ReverseString<`${T}`>>
```

处理完成后，得到的结果别忘了需要重新翻转回来：

```ts
type MinusOne<T extends number> = ReverseString<InternalMinusOne<ReverseString<`${T}`>>>
```

同时还需要注意，在数字的高位数，可能是以 `0` 开头，还需要删除起始的 `0`：

```ts
type RemoveLeadingZeros<S extends string> = S extends '0'
  ? S
  : S extends `${'0'}${infer R}`
    ? RemoveLeadingZeros<R>
    : S

type MinusOne<T extends number> = RemoveLeadingZeros<
  ReverseString<InternalMinusOne<ReverseString<`${T}`>>>
>
```

此时，我们已经得到了 减 `1` 结果的 数字字符串，还需要将其转为 `number` 类型：

```ts
type ParseInt<T extends string> = T extends `${infer Digit extends number}`
  ? Digit
  : never

type MinusOne<T extends number> = ParseInt<RemoveLeadingZeros<
  ReverseString<InternalMinusOne<ReverseString<`${T}`>>>
>>
```

理论上此方法可以处理非常大的数，但由于 `number` 类型的限制，它允许的边界最大值为 2^53^ 。
即 `9007199254740991` 。

## 答案

```ts
type ParseInt<T extends string> = T extends `${infer Digit extends number}`
  ? Digit
  : never

type ReverseString<S extends string> = S extends `${infer First}${infer Rest}`
  ? `${ReverseString<Rest>}${First}`
  : ''

type RemoveLeadingZeros<S extends string> = S extends '0'
  ? S
  : S extends `${'0'}${infer R}`
    ? RemoveLeadingZeros<R>
    : S

type InternalMinusOne<
  S extends string
> = S extends `${infer Digit extends number}${infer Rest}`
  ? Digit extends 0
    ? `9${InternalMinusOne<Rest>}`
    : `${[9, 0, 1, 2, 3, 4, 5, 6, 7, 8][Digit]}${Rest}`
  : never

type MinusOne<T extends number> = ParseInt<RemoveLeadingZeros<
  ReverseString<InternalMinusOne<ReverseString<`${T}`>>>
>>
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type ParseInt<T extends string> = T extends `${infer Digit extends number}`
  ? Digit
  : never

type ReverseString<S extends string> = S extends `${infer First}${infer Rest}`
  ? `${ReverseString<Rest>}${First}`
  : ''

type RemoveLeadingZeros<S extends string> = S extends '0'
  ? S
  : S extends `${'0'}${infer R}`
    ? RemoveLeadingZeros<R>
    : S

type InternalMinusOne<
  S extends string
> = S extends `${infer Digit extends number}${infer Rest}`
  ? Digit extends 0
    ? `9${InternalMinusOne<Rest>}`
    : `${[9, 0, 1, 2, 3, 4, 5, 6, 7, 8][Digit]}${Rest}`
  : never

type MinusOne<T extends number> = ParseInt<RemoveLeadingZeros<
  ReverseString<InternalMinusOne<ReverseString<`${T}`>>>
>>

// ---cut---
type cases = [
  Expect<Equal<MinusOne<1>, 0>>,
  Expect<Equal<MinusOne<55>, 54>>,
  Expect<Equal<MinusOne<3>, 2>>,
  Expect<Equal<MinusOne<100>, 99>>,
  Expect<Equal<MinusOne<1101>, 1100>>,
  Expect<Equal<MinusOne<9_007_199_254_740_992>, 9_007_199_254_740_991>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [改进模板字符串类型中推断类型的推理能力 improved inference for infer types in template string types](https://devblogs.microsoft.com/typescript/announcing-typescript-4-8-beta/#improved-inference-for-infer-types-in-template-string-types)

---

---
url: /czxBlog/type-challenges/medium/mutable/index.md
---
# Mutable
## 题目

Github: [Mutable](https://github.com/type-challenges/type-challenges/blob/main/questions/02793-medium-mutable/)

实现一个通用的类型 `Mutable<T>` ，使类型 `T` 的全部属性可变（非只读）。

```ts
interface Todo {
  readonly title: string
  readonly description: string
  readonly completed: boolean
}

type MutableTodo = Mutable<Todo>
// { title: string; description: string; completed: boolean; }
```

## 解题思路

略。

## 答案

```ts
type Mutable<T extends object> = {
  -readonly [P in keyof T]: T[P]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Mutable<T extends object> = {
  -readonly [P in keyof T]: T[P]
}

// ---cut---
interface Todo1 {
  title: string
  description: string
  completed: boolean
  meta: {
    author: string
  }
}

type List = [1, 2, 3]

type cases = [
  Expect<Equal<Mutable<Readonly<Todo1>>, Todo1>>,
  Expect<Equal<Mutable<Readonly<List>>, List>>,
]

type errors = [
  // @ts-expect-error
  Mutable<'string'>,
  // @ts-expect-error
  Mutable<0>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [映射修饰符 Mapping modifiers](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers)

---

---
url: /czxBlog/type-challenges/medium/number-range/index.md
---
# NumberRange
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/object-entries/index.md
---
# ObjectEntries
## 题目

Github: [ObjectEntries](https://github.com/type-challenges/type-challenges/blob/main/questions/02946-medium-objectentries/)

实现 `Object.entries` 的类型版本

```ts
interface Model {
  name: string
  age: number
  locations: string[] | null
}
type modelEntries = ObjectEntries<Model>
// ['name', string] | ['age', number] | ['locations', string[] | null];
```

## 解题思路

在 Typescript 中，条件类型推断是分布式的，因此我们可以通过条件类型推断，从 对象类型 中，利用 `key` 推断
形成新的元组：

```ts
type ObjectEntries<T extends object, K extends keyof T = keyof T>
 = K extends K ? [K, T[K]] : never
```

也许会觉得到这里这个挑战就完成了，但是实际情况稍微有些麻烦。

我们知道，在 对象类型中，存在 必要属性 和 可选属性：

```ts twoslash
interface Mode {
  name: string // 必要属性
  arg?: number // 可选属性
// ^?
}
```

那么 `Mode` 应用 `ObjectEntries`, 得到的结果为：

```ts twoslash
type ObjectEntries<T extends object, K extends keyof T = keyof T>
 = K extends K ? [K, T[K]] : never

interface Mode {
  name: string // 必要属性
  arg?: number // 可选属性
}
// ---cut---
type a = ObjectEntries<Mode>
//   ^?
//
```

可以看到，在结果中， `arg` 的 `value` 类型被转为了包含 `undefined` 的 联合类型，它应该只是 `number` 类型 。

这里我们可以通过 `Required<T>` 将 对象类型的所有属性全部转为 必要属性，以消除 可选属性中的 `undefined`：

```ts
type ObjectEntries<T extends object, K extends keyof T = keyof T>
 = K extends K ? [K, Required<T>[K]] : never
```

```ts twoslash
type ObjectEntries<T extends object, K extends keyof T = keyof T>
 = K extends K ? [K, Required<T>[K]] : never

interface Mode {
  name: string // 必要属性
  arg?: number // 可选属性
}
// ---cut---
type a = ObjectEntries<Mode>
//   ^?
//
```

但是，如果可选属性的值类型就是 `undefined` 呢？

```ts twoslash
type ObjectEntries<T extends object, K extends keyof T = keyof T>
 = K extends K ? [K, Required<T>[K]] : never
// ---cut---
interface Mode {
  name: string // 必要属性
  arg?: undefined // 可选属性
}

type a = ObjectEntries<Mode>
//   ^?
//
```

可以看到，其结果为 `['arg', never]`，很明显不符合预期，它应该是 `undefined` 类型。
针对此情况，还需要通过条件类型推断对 值类型为 `undefined` 进行处理。

## 答案

```ts
type ObjectEntries<T extends object, K extends keyof T = keyof T>
 = K extends K ? [K, T[K] extends undefined ? undefined : Required<T>[K]] : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type ObjectEntries<T extends object, K extends keyof T = keyof T>
 = K extends K ? [K, T[K] extends undefined ? undefined : Required<T>[K]] : never

// ---cut---
interface Model {
  name: string
  age: number
  locations: string[] | null
}

type ModelEntries = ['name', string] | ['age', number] | ['locations', string[] | null]

type cases = [
  Expect<Equal<ObjectEntries<Model>, ModelEntries>>,
  Expect<Equal<ObjectEntries<Partial<Model>>, ModelEntries>>,
  Expect<Equal<ObjectEntries<{ key?: undefined }>, ['key', undefined]>>,
  Expect<Equal<ObjectEntries<{ key: undefined }>, ['key', undefined]>>,
  Expect<Equal<ObjectEntries<{ key: string | undefined }>, ['key', string | undefined]>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [`keyof` 和查找类型 `keyof` and lookup types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)

---

---
url: /czxBlog/type-challenges/medium/omit-by-type/index.md
---
# OmitByType
## 题目

Github: [OmitByType](https://github.com/type-challenges/type-challenges/blob/main/questions/02852-medium-omitbytype/README.md)

从 `T` 中选取一组属性，这些属性的类型不可分配给 `U` 。

```ts
type OmitBoolean = OmitByType<{
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}, boolean> // { name: string; count: number }
```

## 解题思路

略。

## 答案

```ts
type OmitByType<T, U> = {
  [P in keyof T as T[P] extends U ? never : P]: T[P]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type OmitByType<T, U> = {
  [P in keyof T as T[P] extends U ? never : P]: T[P]
}

// ---cut---
interface Model {
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}

type cases = [
  Expect<Equal<OmitByType<Model, boolean>, { name: string, count: number }>>,
  Expect<Equal<OmitByType<Model, string>, { count: number, isReadonly: boolean, isEnable: boolean }>>,
  Expect<Equal<OmitByType<Model, number>, { name: string, isReadonly: boolean, isEnable: boolean }>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [通过 `as` 进行按键重映射 Key remapping via `as`](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [`keyof` 和查找类型 `keyof` and lookup types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)

---

---
url: /czxBlog/type-challenges/medium/omit/index.md
---
# 实现 Omit
## 题目

Github: [Omit](https://github.com/type-challenges/type-challenges/blob/main/questions/00003-medium-omit/)

不使用 `Omit` 实现 `TypeScript` 的 `Omit<T, K>` 泛型。

`Omit` 会创建一个省略 `K` 中字段的 `T` 对象。

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyOmit<Todo, 'description' | 'title'>

const todo: TodoPreview = {
  completed: false,
}
```

## 解题思路

首先这里需要创建一个新的对象类型，但不指定健，因此这里需要使用 **映射类型**。

```ts
type MyOmit<T, K> = {
  [P in keyof T]: T[P]
}
```

这里通过 `keyof` 遍历 `T` 中的所有键，然后将其映射到类型 `P`，使其成为新对象类型的键，其值为 `T[P]` 。

在此基础上，还需要对 `keyof T` 进行过滤，排除 `K` 中的所有健。

这里可以使用 `as` 语法重新映射键类型，最后新对象的值为 原类型的相对应键的值类型。

## 答案

```ts
type MyOmit<T, K extends keyof T> = {
  [Key in keyof T as Key extends K ? never : Key]: T[Key]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type MyOmit<T, K extends keyof T> = {
  [Key in keyof T as Key extends K ? never : Key]: T[Key]
}
// ---cut---
type cases = [
  Expect<Equal<Expected1, MyOmit<Todo, 'description'>>>,
  Expect<Equal<Expected2, MyOmit<Todo, 'description' | 'completed'>>>,
  Expect<Equal<Expected3, MyOmit<Todo1, 'description' | 'completed'>>>,
]

// @ts-expect-error ignore
type error = MyOmit<Todo, 'description' | 'invalid'>

interface Todo {
  title: string
  description: string
  completed: boolean
}

interface Todo1 {
  readonly title: string
  description: string
  completed: boolean
}

interface Expected1 {
  title: string
  completed: boolean
}

interface Expected2 {
  title: string
}

interface Expected3 {
  readonly title: string
}
```

## 参考

> * [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
> * [索引类型 indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [映射类型中的键重映射 Key Remapping in Mapped Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types)

---

---
url: /czxBlog/type-challenges/medium/parse-url-params/index.md
---
# parseURLParams
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/partial-by-keys/index.md
---
# PartialByKeys
## 题目

Github: [PartialByKeys](https://github.com/type-challenges/type-challenges/blob/main/questions/02757-medium-partialbykeys/)

实现一个通用的 `PartialByKeys<T, K>` ，它接收两个类型参数 `T` 和 `K` 。

`K` 指定应设置为可选的T的属性集。当没有提供 `K` 时，它就和普通的 `Partial<T>` 一样使所有属性都是可选的。

```ts
interface User {
  name: string
  age: number
  address: string
}

type UserPartialName = PartialByKeys<User, 'name'>
// { name?:string; age:number; address:string }
```

## 解题思路

略。

## 答案

```ts
type PartialByKeys<T, K extends keyof T = keyof T> = Omit<{
  [P in keyof T as P extends K ? P : never]?: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}, never>
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type PartialByKeys<T, K extends keyof T = keyof T> = Omit<{
  [P in keyof T as P extends K ? P : never]?: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}, never>

// ---cut---
interface User {
  name: string
  age: number
  address: string
}

interface UserPartialName {
  name?: string
  age: number
  address: string
}

interface UserPartialNameAndAge {
  name?: string
  age?: number
  address: string
}

type cases = [
  Expect<Equal<PartialByKeys<User, 'name'>, UserPartialName>>,
  Expect<Equal<PartialByKeys<User, 'name' | 'age'>, UserPartialNameAndAge>>,
  Expect<Equal<PartialByKeys<User>, Partial<User>>>,
  // @ts-expect-error
  Expect<Equal<PartialByKeys<User, 'name' | 'unknown'>, UserPartialName>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [通过 `as` 进行按键重映射 Key remapping via `as`](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [`keyof` 和查找类型 `keyof` and lookup types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)
* [交叉类型 Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)

---

---
url: /czxBlog/type-challenges/medium/pascals-triangle/index.md
---
# pascalsTriangle
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/percentage-parser/index.md
---
# Percentage Parser
## 题目

Github: [Percentage Parser](https://github.com/type-challenges/type-challenges/blob/main/questions/01978-medium-percentage-parser/)

实现类型 `PercentageParser`。根据规则 `/^(\+|\-)?(\d*)?(\%)?$/` 匹配类型 `T` 。

匹配的结果由三部分组成，分别是：\[正负号, 数字, 单位]，如果没有匹配，则默认是空字符串。

```ts
type R1 = PercentageParser<''> // expected ['', '', '']
type R2 = PercentageParser<'+85%'> // expected ["+", "85", "%"]
type R3 = PercentageParser<'-85%'> // expected ["-", "85", "%"]
type R4 = PercentageParser<'85%'> // expected ["", "85", "%"]
type R5 = PercentageParser<'85'> // expected ["", "85", ""]
```

## 解题思路

一开始，我想到的最粗暴的解题方式如下：

```ts
type PercentageParser<
  A extends string,
  R extends readonly [string, string, string] = ['', '', '']
> = A extends ''
  ? R
  : A extends `${infer F}${infer O}`
    ? F extends '-' | '+'
      ? PercentageParser<O, [F, '', '']>
      : F extends `${number}`
        ? PercentageParser<O, [R[0], `${R[1]}${F}`, '']>
        : F extends '%'
          ? PercentageParser<O, [R[0], R[1], F]>
          : PercentageParser<O, [R[0], R[1], '']>
    : R
```

但这样做需要迭代每一个字符，处理起来并不简洁高效。

我们回归的挑战本身，对于 百分比字符串，它的首位字符 可能是 `+`、 `-`，以及不带符号为 `''` 的情况；
它的末尾则可能是 `%` ；剩下的字符则没有特殊的情况。

这告诉我们，可以将挑战分开为两个问题来解决：

1. 首个字符是否是 `+`, `-`;
2. 剩下字符是否以 `%` 结尾。

问题已经变得非常简单，我们可以使用 模板字面量类型 和 条件类型 解决：

字符是否是 `+`, `-`：

```ts
type CheckPrefix<T> = T extends '+' | '-' ? T : never
```

字符是否以 `%` 结尾：

```ts
type CheckSuffix<T> = T extends `${infer P}%` ? [P, '%'] : [T, '']
```

接下来，从原字符串中提取首个字符和剩下的字符，分别交给对应的类型处理即可，这里同样使用
模板字面量类型 和 条件类型 解决：

```ts
type PercentageParser<A extends string> = A extends `${CheckPrefix<infer L>}${infer R}`
  ? [L, ...CheckSuffix<R>] // 首字符是 + -
  : ['', ...CheckSuffix<A>]
```

## 答案

```ts
type CheckPrefix<T> = T extends '+' | '-' ? T : never
type CheckSuffix<T> = T extends `${infer P}%` ? [P, '%'] : [T, '']
type PercentageParser<A extends string> = A extends `${CheckPrefix<infer L>}${infer R}`
  ? [L, ...CheckSuffix<R>]
  : ['', ...CheckSuffix<A>]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type CheckPrefix<T> = T extends '+' | '-' ? T : never
type CheckSuffix<T> = T extends `${infer P}%` ? [P, '%'] : [T, '']
type PercentageParser<A extends string> = A extends `${CheckPrefix<infer L>}${infer R}` ? [L, ...CheckSuffix<R>] : ['', ...CheckSuffix<A>]

// ---cut---
type cases = [
  Expect<Equal<PercentageParser<''>, ['', '', '']>>,
  Expect<Equal<PercentageParser<'+'>, ['+', '', '']>>,
  Expect<Equal<PercentageParser<'+1'>, ['+', '1', '']>>,
  Expect<Equal<PercentageParser<'+100'>, ['+', '100', '']>>,
  Expect<Equal<PercentageParser<'+100%'>, ['+', '100', '%']>>,
  Expect<Equal<PercentageParser<'100%'>, ['', '100', '%']>>,
  Expect<Equal<PercentageParser<'-100%'>, ['-', '100', '%']>>,
  Expect<Equal<PercentageParser<'-100'>, ['-', '100', '']>>,
  Expect<Equal<PercentageParser<'-1'>, ['-', '1', '']>>,
  Expect<Equal<PercentageParser<'%'>, ['', '', '%']>>,
  Expect<Equal<PercentageParser<'1'>, ['', '1', '']>>,
  Expect<Equal<PercentageParser<'100'>, ['', '100', '']>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /czxBlog/type-challenges/medium/permutation/index.md
---
# 联合类型全排列
## 题目

实现联合类型的全排列，将联合类型转换成所有可能的全排列数组的联合类型。

```ts
type perm = Permutation<'A' | 'B' | 'C'>
// ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']
```

## 解题思路

这个挑战需要我们深入理解
[条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)。
在我们对联合类型进行条件类型推断时：

```ts
type Permutation<T> = T extends T ? [T] : never
```

假设 `T` 为 `'A' | 'B' | 'C'`:

```ts twoslash
type Permutation<T> = T extends T ? [T] : never
// ---cut---
type Result = Permutation<'A' | 'B' | 'C'>
//    ^?
//
```

`T extends T` 从语法上看起来很怪，但它实际上是从泛型 `T` 中取出每一个成员，判断该成员是否在联合类型 `T` 中。

```mermaid
---
title: 条件类型分支
---
flowchart TD
  A["T extends T ? [T] : never"]
  B["T extends 'A' | 'B' | 'C'"]
  C["'A' extends 'A' | 'B' | 'C'"]
  D["'B' extends 'A' | 'B' | 'C'"]
  E["'C' extends 'A' | 'B' | 'C'"]
  CC["['A']"]
  DD["['B']"]
  EE["['C']"]
  R["['A'] | ['B'] | ['C']"]
  A --> B
  B --> C --> CC --> R
  B --> D --> DD --> R
  B --> E --> EE --> R
```

在理解了 条件类型分支后，再来看 联合类型的全排列，当 `T` 为 `'A' | 'B' | 'C'` 时，存在以下的所有排列：

| 首位成员 | 全部成员 | 去除首位成员 |
| -------- | -------- | ------------ |
| A        | A, B, C  | B, C         |
|          | A, C, B  | C, B         |
| B        | B, A, C  | A, C         |
|          | B, C, A  | C, A         |
| C        | C, A, B  | A, B         |
|          | C, B, A  | B, A         |

观察可以发现，在首位成员确定时，全排列就是 首位成员 加上 剩余成员的全排列 的集合。

| 首位成员 | 剩余成员 | 全排列  |
| -------- | -------- | ------- |
| A        | B, C     | A, B, C |
|          | C, B     | A, C, B |

因此可以通过递归的方式，在 `type Permutation<T> = T extends T ? [T] : never` 中添加剩余成员全排列集合：

```ts
type Permutation<T, U = T> = U extends U
  ? [U, ...Permutation<Exclude<T, U>>]
  : never
```

这里我们使用一个泛型参数 `U` 保存条件类型分支中的成员。

同时，还需要考虑递归应该在何时停止，当 联合类型 `T` 中没有成员时，即 `never` 时，应该终止递归。

在 typescript 中，我们不能通过 `T extends never ？ true : false` 判断一个类型是否为 `never`，
因为 在 `T extends never` 中 `never` 本质上是一个没有成员的联合类型，
这导致了 `never extends never ? true : false` 整体被跳过了，得到的结果为 `never` , 而不是 `true/false`。

要避免这种情况，可以在`extends` 两边的类型用方括号包裹，这可以避免 触发条件类型分支：

```ts
type Permutation<T, U = T> = [T] extends [never]
  ? []
  : T
```

## 答案

```ts
type Permutation<T, U = T> = [T] extends [never]
  ? []
  : U extends U
    ? [U, ...Permutation<Exclude<T, U>>]
    : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Permutation<T, U = T> = [T] extends [never]
  ? []
  : U extends U
    ? [U, ...Permutation<Exclude<T, U>>]
    : never

// ---cut---
type cases = [
  Expect<Equal<Permutation<'A'>, ['A']>>,
  Expect<Equal<Permutation<'A' | 'B' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']>>,
  Expect<Equal<Permutation<'B' | 'A' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']>>,
  Expect<Equal<Permutation<boolean>, [false, true] | [true, false]>>,
  Expect<Equal<Permutation<never>, []>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /czxBlog/type-challenges/medium/permutations-of-tuple/index.md
---
# permutationsOfTuple
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/pick-by-type/index.md
---
# PickByType
## 题目

Github: [PickByType](https://github.com/type-challenges/type-challenges/blob/main/questions/02595-medium-pickbytype/)

从 `T` 中选取一组类型可分配给 `U` 的属性。

```ts
type OnlyBoolean = PickByType<{
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}, boolean> // { isReadonly: boolean; isEnable: boolean; }
```

## 解题思路

这个挑战比较简单。让我们从 映射类型 开始，从 `T` 中获取所有的 键，以及对应的 值：

```ts
type PickByType<T, U> = {
  [P in keyof T]: T[P]
}
```

接下来，我们通过 `as` 对 键进行重映射，过滤不满足 `U` 的情况：

```ts
type PickByType<T, U> = {
  [P in keyof T as T[P] extends U ? P : never]: T[P]
}
```

## 答案

```ts
type PickByType<T, U> = {
  [P in keyof T as T[P] extends U ? P : never]: T[P]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type PickByType<T, U> = {
  [P in keyof T as T[P] extends U ? P : never]: T[P]
}

// ---cut---
interface Model {
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}

type cases = [
  Expect<Equal<PickByType<Model, boolean>, { isReadonly: boolean, isEnable: boolean }>>,
  Expect<Equal<PickByType<Model, string>, { name: string }>>,
  Expect<Equal<PickByType<Model, number>, { count: number }>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [通过 `as` 进行按键重映射 Key remapping via `as`](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [`keyof` 和查找类型 `keyof` and lookup types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)

---

---
url: /czxBlog/type-challenges/medium/pop/index.md
---
# 排除最后一项
## 题目

Github: [Pop](https://github.com/type-challenges/type-challenges/blob/main/questions/00016-medium-pop/)

实现一个通用`Pop<T>`，它接受一个数组 `T`，并返回一个由数组T的前 `N-1` 项以相同的顺序组成的数组。

```ts
type arr1 = ['a', 'b', 'c', 'd']
type arr2 = [3, 2, 1]

type re1 = Pop<arr1> // expected to be ['a', 'b', 'c']
type re2 = Pop<arr2> // expected to be [3, 2]
```

## 解题思路

我们需要将数组分成两部份：从头部到最后一个元素之前的所有内容和最后一个元素本身。
然后去掉最后一个元素并返回头部部分。

## 答案

```ts
type Pop<T extends any[]> = T extends [...infer R, unknown] ? R : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Pop<T extends any[]> = T extends [...infer R, unknown] ? R : T

// ---cut---
type cases = [
  Expect<Equal<Pop<[3, 2, 1]>, [3, 2]>>,
  Expect<Equal<Pop<['a', 'b', 'c', 'd']>, ['a', 'b', 'c']>>,
  Expect<Equal<Pop<[]>, []>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型内推断 Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /czxBlog/type-challenges/medium/promise-all/index.md
---
# Promise.all
## 题目

Github: [Promise.all](https://github.com/type-challenges/type-challenges/blob/main/questions/00020-medium-promise-all/)

传入函数`PromiseAll`，它接受PromiseLike对象数组，返回值应为`Promise<T>`，其中`T`是解析的结果数组。

```ts
const promise1 = Promise.resolve(3)
const promise2 = 42
const promise3 = new Promise<string>((resolve, reject) => {
  setTimeout(resolve, 100, 'foo')
})

// 应推导出 `Promise<[number, 42, string]>`
const p = PromiseAll([promise1, promise2, promise3] as const)
```

## 解题思路

这个挑战要求我们从 `Promise.all` 方法的入参中，提取出 参数类型。
`Promise.all` 接收一个数组参数，数组的每个成员可以是不同的类型，这也包括 `Promise<T>` 类型,
对于 `Promise<T>` 类型，需要递归展开获取 `T` 类型。

这个挑战实际上可以转换为 对 数组的每个成员进行递归展开，即对每个成员进行 `Awaited` 的展开操作。
我们已经在 [简单 > Awaited](../简单/189.awaited.md) 中完成了该挑战：

```ts
type Awaited<T> = T extends Promise<infer R> ? Awaited<R> : T
```

因此，我们只需要完成 参数的类型约束，再对返回类型进行做 映射类型 的操作即可。

## 答案

```ts
type Awaited<T> = T extends Promise<infer R> ? Awaited<R> : T

declare function PromiseAll<T extends any[]>(
  values: readonly [...T],
): Promise<{
  [K in keyof T]: Awaited<T[K]>
}>
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Awaited<T> = T extends Promise<infer R> ? Awaited<R> : T

declare function PromiseAll<T extends any[]>(
  values: readonly [...T],
): Promise<{
  [K in keyof T]: Awaited<T[K]>
}>

// ---cut---
const promiseAllTest1 = PromiseAll([1, 2, 3] as const)
const promiseAllTest2 = PromiseAll([1, 2, Promise.resolve(3)] as const)
const promiseAllTest3 = PromiseAll([1, 2, Promise.resolve(3)])
const promiseAllTest4 = PromiseAll<Array<number | Promise<number>>>([1, 2, 3])

type cases = [
  Expect<Equal<typeof promiseAllTest1, Promise<[1, 2, 3]>>>,
  Expect<Equal<typeof promiseAllTest2, Promise<[1, 2, number]>>>,
  Expect<Equal<typeof promiseAllTest3, Promise<[number, number, number]>>>,
  Expect<Equal<typeof promiseAllTest4, Promise<number[]>>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型内推断 Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/public-type/index.md
---
# publicType
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/readonly-2/index.md
---
# 对象部分属性只读
## 题目

Github: [Readonly 2](https://github.com/type-challenges/type-challenges/blob/main/questions/00008-medium-readonly-2/)

实现一个泛型 `MyReadonly2<T, K>`，它带有两种类型的参数`T`和`K`。

K指定应设置为`Readonly`的`T`的属性集。如果未提供`K`，则应使所有属性都变为只读，就像普通的`Readonly<T>`一样。

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

const todo: MyReadonly2<Todo, 'title' | 'description'> = {
  title: 'Hey',
  description: 'foobar',
  completed: false,
}

todo.title = 'Hello' // Error: cannot reassign a readonly property
todo.description = 'barFoo' // Error: cannot reassign a readonly property
todo.completed = true // OK
```

## 解题思路

泛型参数`K` 需要约束为 `T` 的属性集，同时默认值为 `T`的属性集；

创建一个只含有 只读属性的对象类型，通过 `in` 操作符，遍历`T` 的所有成员，映射给泛型属性 `P`；

创建一个只含有可读属性的对象类型， 通过 `as` 语法，重新映射给泛型属性 `P`；

合并两个对象类型即可实现 `MyReadonly<T, K>`

## 答案

```ts
type MyReadonly2<T, K extends keyof T = keyof T> = {
  readonly [P in K]: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}
```

## 验证

```ts twoslash
import type { Alike, Expect } from '~/tc-utils'
type MyReadonly2<T, K extends keyof T = keyof T> = {
  readonly [P in K]: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}

// ---cut---
type cases = [
  Expect<Alike<MyReadonly2<Todo1>, Readonly<Todo1>>>,
  Expect<Alike<MyReadonly2<Todo1, 'title' | 'description'>, Expected>>,
  Expect<Alike<MyReadonly2<Todo2, 'title' | 'description'>, Expected>>,
  Expect<Alike<MyReadonly2<Todo2, 'description'>, Expected>>,
]

// @ts-expect-error ignore
type error = MyReadonly2<Todo1, 'title' | 'invalid'>

interface Todo1 {
  title: string
  description?: string
  completed: boolean
}

interface Todo2 {
  readonly title: string
  description?: string
  completed: boolean
}

interface Expected {
  readonly title: string
  readonly description?: string
  completed: boolean
}
```

## 参考

* [交叉类型 Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [索引访问类型 Indexed Access Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [在泛型约束中使用类型参数 Generic Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#using-type-parameters-in-generic-constraints)
* [映射类型中的键重映射 Key Remapping in Mapped Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types)

---

---
url: /czxBlog/type-challenges/medium/remove-index-signature/index.md
---
# Remove Index Signature
## 题目

Github: [RemoveIndexSignature](https://github.com/type-challenges/type-challenges/blob/main/questions/01367-medium-remove-index-signature/README.md)

实现 `RemoveIndexSignature<T>`，从对象类型中排除索引签名。

```ts
interface Foo {
  [key: string]: any
  foo: () => void
}

type A = RemoveIndexSignature<Foo> // expected { foo(): void }
```

## 解题思路

这个挑战需要我们从 对象类型 中排除以 `{ [key: string]: any }` 形式声明的签名，同时需要保留如
`{ name: any }` 形式声明的签名。

这很明显需要使用 映射类型 和 条件类型 来解决。

首先我们知道， `'name' extends string` 的结果为 真，但是反过来，`string extends 'name'` 结果为 假 。
因为 `'name'` 本身就是 `string`，但 `string` 不止 `'name'` 。 我们可以利用这一特性，完成这个挑战。

我们可以使用 Typescript 的内置类型 `PropertyKey` ，它表示 `string | number | symbol` ，即 键类型，
先完成最基础的类型声明：

```ts
type RemoveIndexSignature<T, K extends PropertyKey = PropertyKey> = {
  [P in keyof T]: T[P]
}
```

接下来，我们对 `P` 进行约束，当 `K extends P` 为真时，这表示 `P` 可能是 `string` 、`number` 或 `symbol`。
我们需要排除这些情况：

```ts
type RemoveIndexSignature<T, K extends PropertyKey = PropertyKey> = {
  [P in keyof T as K extends P ? never : P]: T[P]
}
```

这发生了什么？`K` 表示的是 `string | number | symbol`，`K extends P` 相当于：

```ts
type a = string extends P ? never : P
type b = number extends P ? never : P
type c = symbol extends P ? never : P
```

这直接从 键类型中过滤了 `string`, `number`, `symbol` 的 索引签名。

当然这还不够，还需要限制 `P` 应该是一个合法的 键，因此我们还需要使用 `P extends K` 约束 键类型：

```ts
type RemoveIndexSignature<T, K extends PropertyKey = PropertyKey> = {
  [P in keyof T as K extends P ? never : P extends K ? P : never]: T[P]
}
```

这相当于，如果 `P` 为对象中的 `name` 属性，则发生了以下检查：

```ts
type P = 'name' extends string | number | symbol ? 'name' : never
```

此时 `name` 满足 `K` 的约束。

## 答案

```ts
type RemoveIndexSignature<T, K extends PropertyKey = PropertyKey> = {
  [P in keyof T as K extends P
    ? never
    : P extends K
      ? P
      : never
  ]: T[P]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type RemoveIndexSignature<T, K extends PropertyKey = PropertyKey> = {
  [P in keyof T as K extends P ? never : P extends K ? P : never]: T[P]
}

// ---cut---
interface Foo {
  [key: string]: any
  foo: () => void
}

interface Bar {
  [key: number]: any
  bar: () => void
  0: string
}

const foobar = Symbol('foobar')
interface FooBar {
  [key: symbol]: any
  [foobar]: () => void
}

interface Baz {
  bar: () => void
  baz: string
}

type cases = [
  Expect<Equal<RemoveIndexSignature<Foo>, { foo: () => void }>>,
  Expect<Equal<RemoveIndexSignature<Bar>, { bar: () => void, 0: string }>>,
  Expect<Equal<RemoveIndexSignature<FooBar>, { [foobar]: () => void }>>,
  Expect<Equal<RemoveIndexSignature<Baz>, { bar: () => void, baz: string }>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/medium/replace-all/index.md
---
# ReplaceAll
## 题目

Github: [ReplaceAll](https://github.com/type-challenges/type-challenges/blob/main/questions/00119-medium-replaceall/)

实现 `ReplaceAll<S, From, To>` 将一个字符串 `S` 中的所有子字符串 `From` 替换为 `To` 。

```ts
type replaced = ReplaceAll<'t y p e s', ' ', ''> // 期望是 'types'
```

## 解题思路

与 [`Replace`](./116.replace.md) 类似，在 **Replace** 挑战中，我们将字符串 `S` 拆分为 `F` 、 `From` 、 `R` 三个部分，
然后对 `From` 进行替换， 在完成替换后，我们需要继续对 `R` 进行替换，直到 `R` 为不包含 `From` 的字符串。

## 答案

```ts
type ReplaceAll<S extends string, From extends string, To extends string> =
  From extends ''
    ? S
    : S extends `${infer F}${From}${infer R}`
      ? `${F}${To}${ReplaceAll<R, From, To>}`
      : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type ReplaceAll<S extends string, From extends string, To extends string> =
  From extends ''
    ? S
    : S extends `${infer F}${From}${infer R}`
      ? `${F}${To}${ReplaceAll<R, From, To>}`
      : S
// ---cut---
type cases = [
  Expect<Equal<ReplaceAll<'foobar', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<ReplaceAll<'foobar', 'bag', 'foo'>, 'foobar'>>,
  Expect<Equal<ReplaceAll<'foobarbar', 'bar', 'foo'>, 'foofoofoo'>>,
  Expect<Equal<ReplaceAll<'t y p e s', ' ', ''>, 'types'>>,
  Expect<Equal<ReplaceAll<'foobarbar', '', 'foo'>, 'foobarbar'>>,
  Expect<Equal<ReplaceAll<'barfoo', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<ReplaceAll<'foobarfoobar', 'ob', 'b'>, 'fobarfobar'>>,
  Expect<Equal<ReplaceAll<'foboorfoboar', 'bo', 'b'>, 'foborfobar'>>,
  Expect<Equal<ReplaceAll<'', '', ''>, ''>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /czxBlog/type-challenges/medium/replace-first/index.md
---
# replaceFirst
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/replace-keys/index.md
---
# ReplaceKeys
## 题目

Github: [ReplaceKeys](https://github.com/type-challenges/type-challenges/blob/main/questions/01130-medium-replacekeys/README.md)

实现一个类型 `ReplaceKeys`，用于替换联合类型中的键，如果某个类型没有该键，则跳过替换。该类型接受三个参数。

```ts
interface NodeA {
  type: 'A'
  name: string
  flag: number
}

interface NodeB {
  type: 'B'
  id: number
  flag: number
}

interface NodeC {
  type: 'C'
  name: string
  flag: number
}

type Nodes = NodeA | NodeB | NodeC

// 将 name 从 string 替换为 number，将 flag 从 number 替换为 string。
type ReplacedNodes = ReplaceKeys<
  Nodes,
  'name' | 'flag',
  { name: number, flag: string }
>
// {type: 'A', name: number, flag: string} | {type: 'B', id: number, flag: string} | {type: 'C', name: number, flag: string}

// 将 name 替换为 never
type ReplacedNotExistKeys = ReplaceKeys<Nodes, 'name', { aa: number }>
// {type: 'A', name: never, flag: number} | NodeB | {type: 'C', name: never, flag: number}
```

## 解题思路

对于这个挑战，很明显需要使用 映射类型和 条件类型 来解决。

首先需要说明的是，在 Typescript 中，映射类型 也是 **分布式** 的。
这表示我们可以直接编写映 射类型来遍历接口的键，同时对联合类型具有分布性。

我们从最简单的开始。
从联合类型U中取出所有元素 (分布性)，对每个元素遍历其键 并返回一个副本。

```ts
type ReplaceKeys<U, T, Y> = {
  [K in keyof U]: U[K]
}
```

首先，我们需要检查 `K` 是否在需要更新的键列表 `T` 中，
与此同时，我们也不能确定 `Y` 中是否存在相同的键，因此也需要进行检查：

```ts
type ReplaceKeys<U, T, Y> = {
  [K in keyof U]:
  K extends T // 是否在键列表中
    ? K extends keyof Y // 是否在 `Y` 中存在相同的键
      ? Y[K] // 返回新的类型
      : never
    : U[K] // 无需修改
}
```

## 答案

```ts
type ReplaceKeys<U, T, Y> = {
  [K in keyof U]: K extends T ? K extends keyof Y ? Y[K] : never : U[K]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type ReplaceKeys<U, T, Y> = {
  [K in keyof U]: K extends T ? K extends keyof Y ? Y[K] : never : U[K]
}
// ---cut---
interface NodeA {
  type: 'A'
  name: string
  flag: number
}

interface NodeB {
  type: 'B'
  id: number
  flag: number
}

interface NodeC {
  type: 'C'
  name: string
  flag: number
}

interface ReplacedNodeA {
  type: 'A'
  name: number
  flag: string
}

interface ReplacedNodeB {
  type: 'B'
  id: number
  flag: string
}

interface ReplacedNodeC {
  type: 'C'
  name: number
  flag: string
}

interface NoNameNodeA {
  type: 'A'
  flag: number
  name: never
}

interface NoNameNodeC {
  type: 'C'
  flag: number
  name: never
}

type Nodes = NodeA | NodeB | NodeC
type ReplacedNodes = ReplacedNodeA | ReplacedNodeB | ReplacedNodeC
type NodesNoName = NoNameNodeA | NoNameNodeC | NodeB

type cases = [
  Expect<Equal<ReplaceKeys<Nodes, 'name' | 'flag', { name: number, flag: string }>, ReplacedNodes>>,
  Expect<Equal<ReplaceKeys<Nodes, 'name', { aa: number }>, NodesNoName>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/medium/replace/index.md
---
# Replace
## 题目

Github: [Replace](https://github.com/type-challenges/type-challenges/blob/main/questions/00116-medium-replace/)

实现 `Replace<S, From, To>` 将字符串 `S` 中的第一个子字符串 `From` 替换为 `To` 。

```ts
type replaced = Replace<'types are fun!', 'fun', 'awesome'> // 期望是 'types are awesome!'
```

## 解题思路

我们可以使用 **模板字面量类型** 来实现这个挑战。对于字符串 `S` ，我们将其拆分为三个部分，并对每个部分
进行推断。

推断从字符串的左侧开始，直到找到 `Form` 位置，此时 `S` 为拆分为 `F` 、 `From` 、 `R` 三个部分。

```ts
type Replace<S extends string, From extends string, To extends string> =
  S extends `${infer F}${From}${infer R}` ? S : S
```

在找到 `From` 位置后，我们对 `From` 位置的字符串进行替换，将其替换为 `To`，拼接为新的字符串。

```ts
type Replace<S extends string, From extends string, To extends string> =
  S extends `${infer F}${From}${infer R}` ? `${F}${To}${R}` : S
```

我们也需要考虑 `From` 为空字符串的情况，此时我们直接返回 `S`。

## 答案

```ts
type Replace<S extends string, From extends string, To extends string> =
  From extends ''
    ? S
    : S extends `${infer F}${From}${infer R}`
      ? `${F}${To}${R}`
      : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Replace<S extends string, From extends string, To extends string> =
  From extends ''
    ? S
    : S extends `${infer F}${From}${infer R}`
      ? `${F}${To}${R}`
      : S

// ---cut---
type cases = [
  Expect<Equal<Replace<'foobar', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<Replace<'foobarbar', 'bar', 'foo'>, 'foofoobar'>>,
  Expect<Equal<Replace<'foobarbar', '', 'foo'>, 'foobarbar'>>,
  Expect<Equal<Replace<'foobarbar', 'bar', ''>, 'foobar'>>,
  Expect<Equal<Replace<'foobarbar', 'bra', 'foo'>, 'foobarbar'>>,
  Expect<Equal<Replace<'', '', ''>, ''>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /czxBlog/type-challenges/medium/required-by-keys/index.md
---
# requiredByKeys
## 题目

Github: [requiredByKeys](https://github.com/type-challenges/type-challenges/blob/main/questions/02759-medium-requiredbykeys/)

实现一个通用的`RequiredByKeys<T, K>`，它接收两个类型参数`T`和`K`。

`K`指定应设为必选的`T`的属性集。当没有提供`K`时，它就和普通的`Required<T>`一样使所有的属性成为必选的。

```ts
interface User {
  name?: string
  age?: number
  address?: string
}

type UserRequiredName = RequiredByKeys<User, 'name'>
// { name: string; age?: number; address?: string }
```

## 解题思路

略。

## 答案

```ts
type RequiredByKeys<T, K extends keyof T = keyof T> = Omit<{
  [P in keyof T as P extends K ? P : never]-?: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}, never>
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type RequiredByKeys<T, K extends keyof T = keyof T> = Omit<{
  [P in keyof T as P extends K ? P : never]-?: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}, never>

// ---cut---
interface User {
  name?: string
  age?: number
  address?: string
}

interface UserRequiredName {
  name: string
  age?: number
  address?: string
}

interface UserRequiredNameAndAge {
  name: string
  age: number
  address?: string
}

type cases = [
  Expect<Equal<RequiredByKeys<User, 'name'>, UserRequiredName>>,
  Expect<Equal<RequiredByKeys<User, 'name' | 'age'>, UserRequiredNameAndAge>>,
  Expect<Equal<RequiredByKeys<User>, Required<User>>>,
  // @ts-expect-error
  Expect<Equal<RequiredByKeys<User, 'name' | 'unknown'>, UserRequiredName>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [映射修饰符 Mapping modifiers](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers)
* [通过 `as` 进行按键重映射 Key remapping via `as`](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [`keyof` 和查找类型 `keyof` and lookup types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)
* [交叉类型 Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)

---

---
url: /czxBlog/type-challenges/medium/reverse/index.md
---
# Reverse
## 题目

Github: [Reverse](https://github.com/type-challenges/type-challenges/blob/main/questions/03192-medium-reverse/README.zh-CN.md)

实现类型版本的数组反转 `Array.reverse`

```ts
type a = Reverse<['a', 'b']> // ['b', 'a']
type b = Reverse<['a', 'b', 'c']> // ['c', 'b', 'a']
```

## 解题思路

略。

## 答案

```ts
type Reverse<T extends unknown[]> = T extends [infer L, ...infer O]
  ? [...Reverse<O>, L]
  : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Reverse<T extends unknown[]> = T extends [infer L, ...infer O]
  ? [...Reverse<O>, L]
  : T

// ---cut---
type cases = [
  Expect<Equal<Reverse<[]>, []>>,
  Expect<Equal<Reverse<['a', 'b']>, ['b', 'a']>>,
  Expect<Equal<Reverse<['a', 'b', 'c']>, ['c', 'b', 'a']>>,
]

type errors = [
  // @ts-expect-error
  Reverse<'string'>,
  // @ts-expect-error
  Reverse<{ key: 'value' }>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [在条件类型中进行推断 Inferring within conditional types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive conditional types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/shift/index.md
---
# Shift
## 题目

Github: [Shift](https://github.com/type-challenges/type-challenges/blob/main/questions/03062-medium-shift/README.md)

实现 `Array.shift` 的类型版本

```ts
type Result = Shift<[3, 2, 1]> // [2, 1]
```

## 解题思路

略。

## 答案

```ts
type Shift<T extends unknown[]> = T extends [infer _, ...infer O] ? O : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Shift<T extends unknown[]> = T extends [infer _, ...infer O] ? O : T

// ---cut---
type cases = [
  // @ts-expect-error
  Shift<unknown>,
  Expect<Equal<Shift<[]>, []>>,
  Expect<Equal<Shift<[1]>, []>>,
  Expect<Equal<Shift<[3, 2, 1]>, [2, 1]>>,
  Expect<Equal<Shift<['a', 'b', 'c', 'd']>, ['b', 'c', 'd']>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)
* [元组类型 Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-3.html#tuple-types)

---

---
url: /czxBlog/type-challenges/medium/shitariteraru/index.md
---
# shitariteraru
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/square/index.md
---
# square
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/stars-with/index.md
---
# StartsWith
## 题目

Github: [StartsWith](https://github.com/type-challenges/type-challenges/blob/main/questions/02688-medium-startswith/)

实现 `StartsWith<T, U>` ,接收两个 `string` 类型参数,然后判断 `T` 是否以 `U` 开头,根据结果返回 `true` 或 `false`

```ts
type a = StartsWith<'abc', 'ac'> // expected to be false
type b = StartsWith<'abc', 'ab'> // expected to be true
type c = StartsWith<'abc', 'abcd'> // expected to be false
```

## 解题思路

略。

## 答案

```ts
type StartsWith<T extends string, U extends string> = T extends `${U}${string}` ? true : false
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type StartsWith<T extends string, U extends string> = T extends `${U}${string}` ? true : false

// ---cut---
type cases = [
  Expect<Equal<StartsWith<'abc', 'ac'>, false>>,
  Expect<Equal<StartsWith<'abc', 'ab'>, true>>,
  Expect<Equal<StartsWith<'abc', 'abc'>, true>>,
  Expect<Equal<StartsWith<'abc', 'abcd'>, false>>,
  Expect<Equal<StartsWith<'abc', ''>, true>>,
  Expect<Equal<StartsWith<'abc', ' '>, false>>,
  Expect<Equal<StartsWith<'', ''>, true>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [泛型约束 Generics constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /czxBlog/type-challenges/medium/string-to-union/index.md
---
# 字符串转联合类型
## 题目

Github: [StringToUnion](https://github.com/type-challenges/type-challenges/blob/main/questions/00531-medium-string-to-union/)

实现一个将接收到的 `String` 参数转换为一个字母 `Union` 的类型。

```ts
type Test = '123'
type Result = StringToUnion<Test> // expected to be "1" | "2" | "3"
```

## 解题思路

通过模板字面量类型 和 条件类型推断，从字符串中取出一个个字符，并使用 尾递归的方式，将字符串转为联合类型。

## 答案

```ts
type StringToUnion<S extends string> =
  S extends `${infer L}${infer R}` ? `${L | StringToUnion<R>}` : never
```

## 验证

```ts twoslash
import { Equal, Expect } from '~/tc-utils'
type StringToUnion<S extends string> =
  S extends `${infer L}${infer R}` ? `${L | StringToUnion<R>}` : never

// ---cut---
type cases = [
  Expect<Equal<StringToUnion<''>, never>>,
  Expect<Equal<StringToUnion<'t'>, 't'>>,
  Expect<Equal<StringToUnion<'hello'>, 'h' | 'e' | 'l' | 'l' | 'o'>>,
  Expect<Equal<StringToUnion<'coronavirus'>, 'c' | 'o' | 'r' | 'o' | 'n' | 'a' | 'v' | 'i' | 'r' | 'u' | 's'>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)

---

---
url: /czxBlog/type-challenges/medium/subsequence/index.md
---
# Subsequence
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/to-primitive/index.md
---
# ToPrimitive
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/tower-of-hanoi/index.md
---
# towerOfHanoi
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/trace/index.md
---
# trace
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/transpose/index.md
---
# transpose
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/triangular-number/index.md
---
# triangularNumber
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /czxBlog/type-challenges/medium/trim-left/index.md
---
# 去除左侧空白
## 题目

Github: [TrimLeft](https://github.com/type-challenges/type-challenges/blob/main/questions/00106-medium-trimleft/)

实现 `TrimLeft<T>` ，它接收确定的字符串类型并返回一个新的字符串，
其中新返回的字符串删除了原字符串开头的空白字符串。

```ts
type trimed = TrimLeft<'  Hello World  '> // 应推导出 'Hello World  '
```

## 解题思路

这里我们需要使用 [模板字面量类型](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types) ，对 字符串进行建模。

我们需要处理两种情况，左边有空格的字符串和没有空格的字符串。
如果我们有空格，我们需要推断字符串的另一部分并再次检查它是否有空格，否则，我们返回推断的部分而不做任何更改。

```ts
type TrimLeft<S extends string> = S extends `${' '}${infer R}` ? TrimLeft<R> : S
```

除了需要检查 空格，还需要检查换行符和制表符。

## 答案

```ts
type TrimLeft<S extends string> =
  S extends `${' ' | '\n' | '\t'}${infer R}` ? TrimLeft<R> : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type TrimLeft<S extends string> =
  S extends `${' ' | '\n' | '\t'}${infer R}` ? TrimLeft<R> : S

// ---cut---
type cases = [
  Expect<Equal<TrimLeft<'str'>, 'str'>>,
  Expect<Equal<TrimLeft<' str'>, 'str'>>,
  Expect<Equal<TrimLeft<'     str'>, 'str'>>,
  Expect<Equal<TrimLeft<'     str     '>, 'str     '>>,
  Expect<Equal<TrimLeft<'   \n\t foo bar '>, 'foo bar '>>,
  Expect<Equal<TrimLeft<''>, ''>>,
  Expect<Equal<TrimLeft<' \n\t'>, ''>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)

---

---
url: /czxBlog/type-challenges/medium/trim-right/index.md
---
# TrimRight
## 题目

Github: [TrimRight](https://github.com/type-challenges/type-challenges/blob/main/questions/04803-medium-trim-right/)

实现 `TrimRight<T>` ，它接收确定的字符串类型并返回一个新的字符串，
其中新返回的字符串删除了原字符串结尾的空白字符串。

```ts
type Trimed = TrimRight<'  Hello World  '> // 应推导出 '  Hello World'
```

## 解题思路

这里我们需要使用 [模板字面量类型](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types) ，对 字符串进行建模。

我们需要处理两种情况，右边有空格的字符串和没有空格的字符串。
如果我们有空格，我们需要推断字符串的另一部分并再次检查它是否有空格，否则，我们返回推断的部分而不做任何更改。

```ts
type TrimRight<S extends string> = S extends `${infer R}${' '}` ? TrimRight<R> : S
```

除了需要检查 空格，还需要检查换行符和制表符。

## 答案

```ts
type TrimRight<S extends string> =
  S extends `${infer R}${' ' | '\n' | '\t'}` ? TrimRight<R> : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type TrimRight<S extends string> =
  S extends `${infer R}${' ' | '\n' | '\t'}` ? TrimRight<R> : S

// ---cut---
type cases = [
  Expect<Equal<TrimRight<'str'>, 'str'>>,
  Expect<Equal<TrimRight<'str '>, 'str'>>,
  Expect<Equal<TrimRight<'str     '>, 'str'>>,
  Expect<Equal<TrimRight<'     str     '>, '     str'>>,
  Expect<Equal<TrimRight<'   foo bar  \n\t '>, '   foo bar'>>,
  Expect<Equal<TrimRight<''>, ''>>,
  Expect<Equal<TrimRight<'\n\t '>, ''>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)

---

---
url: /czxBlog/type-challenges/medium/trim/index.md
---
# 去除两端空白字符
## 题目

Github: [Trim](https://github.com/type-challenges/type-challenges/blob/main/questions/00108-medium-trim/)

实现 `Trim<T>`，它接受一个明确的字符串类型，并返回一个新字符串，其中两端的空白符都已被删除。

```ts
type trimed = Trim<'  Hello World  '> // 应推导出 'Hello World'
```

## 解题思路

此挑战的解题思路与 [中等 > 去除左侧空白](./trimRight.md) 类似，只是需要处理两端的空白字符。
因此我们可以将问题拆解为，先删除左边的空白字符，然后再删除右边的空白字符。

## 答案

```ts
type Whitespace = ' ' | '\n' | '\t'
type Trim<S extends string> = S extends `${Whitespace}${infer R}`
  ? Trim<R>
  : S extends `${infer L}${Whitespace}`
    ? Trim<L>
    : S
```

## 验证

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Whitespace = ' ' | '\n' | '\t'
type Trim<S extends string> = S extends `${Whitespace}${infer R}`
  ? Trim<R>
  : S extends `${infer L}${Whitespace}`
    ? Trim<L>
    : S

// ---cut---
type cases = [
  Expect<Equal<Trim<'str'>, 'str'>>,
  Expect<Equal<Trim<' str'>, 'str'>>,
  Expect<Equal<Trim<'     str'>, 'str'>>,
  Expect<Equal<Trim<'str   '>, 'str'>>,
  Expect<Equal<Trim<'     str     '>, 'str'>>,
  Expect<Equal<Trim<'   \n\t foo bar \t'>, 'foo bar'>>,
  Expect<Equal<Trim<''>, ''>>,
  Expect<Equal<Trim<' \n\t '>, ''>>,
]
```

## 参考

* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)

---

---
url: /czxBlog/type-challenges/medium/trunc/index.md
---
# Trunc
## 题目

Github: [Trunc](https://github.com/type-challenges/type-challenges/blob/main/questions/05140-medium-trunc/)

实现 `Math.trunc` 的类型版本，该版本接受字符串或数字，并通过移除任何小数部分返回数字的整数部分。

```ts
type A = Trunc<12.34> // 12
```

## 解题思路

这个挑战很容易想到用 模板字面量类型 和 条件类型 `infer` 判断字符串是否包含小数部分，然后进行处理。

需要注意的是，数字字符串中可能包含 `-`，也可能省略整数部分的 `0` 。

## 答案

```ts
type Trunc<T extends number | string> = `${T}` extends `${infer D}.${string}`
  ? D extends '' | '-' ? `${D}0` : D
  : `${T}`
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Trunc<T extends number | string> = `${T}` extends `${infer D}.${string}`
  ? D extends '' | '-' ? `${D}0` : D
  : `${T}`

// ---cut---
type cases = [
  Expect<Equal<Trunc<0.1>, '0'>>,
  Expect<Equal<Trunc<0.2>, '0'>>,
  Expect<Equal<Trunc<1.234>, '1'>>,
  Expect<Equal<Trunc<12.345>, '12'>>,
  Expect<Equal<Trunc<-5.1>, '-5'>>,
  Expect<Equal<Trunc<'.3'>, '0'>>,
  Expect<Equal<Trunc<'1.234'>, '1'>>,
  Expect<Equal<Trunc<'-.3'>, '-0'>>,
  Expect<Equal<Trunc<'-10.234'>, '-10'>>,
  Expect<Equal<Trunc<10>, '10'>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/tuple-to-nested-object/index.md
---
# TupleToNestedObject
## 题目

Github: [TupleToNestedObject](https://github.com/type-challenges/type-challenges/blob/main/questions/03188-medium-tuple-to-nested-object/README.md)

给定一个仅包含字符串类型的元组类型 `T` ，以及一个类型 `U` ，递归地构建一个对象。

```ts
type a = TupleToNestedObject<['a'], string> // {a: string}
type b = TupleToNestedObject<['a', 'b'], number> // {a: {b: number}}
type c = TupleToNestedObject<[], boolean> // boolean. if the tuple is empty, just return the U type
```

## 解题思路

略。

## 答案

```ts
type TupleToNestedObject<T, U> = T extends [infer L extends PropertyKey, ...infer O]
  ? { [P in L]: TupleToNestedObject<O, U> }
  : U
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type TupleToNestedObject<T, U> = T extends [infer L extends PropertyKey, ...infer O]
  ? { [P in L]: TupleToNestedObject<O, U> }
  : U

// ---cut---
type cases = [
  Expect<Equal<TupleToNestedObject<['a'], string>, { a: string }>>,
  Expect<Equal<TupleToNestedObject<['a', 'b'], number>, { a: { b: number } }>>,
  Expect<Equal<TupleToNestedObject<['a', 'b', 'c'], boolean>, { a: { b: { c: boolean } } }>>,
  Expect<Equal<TupleToNestedObject<[], boolean>, boolean>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [在条件类型中进行推断 Inferring within conditional types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive conditional types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/tuple-to-union/index.md
---
# 元组转合集
## 题目

Github: [Tuple to union](https://github.com/type-challenges/type-challenges/blob/main/questions/00010-medium-tuple-to-union/)

实现泛型`TupleToUnion<T>`，它返回元组所有值的合集。

```ts
type Arr = ['1', '2', '3']

type Test = TupleToUnion<Arr> // expected to be '1' | '2' | '3'
```

## 解题思路

在访问元组的成员时，可以通过 `[number]` 索引，访问一个 由元组所有成员构成的联合类型。

同时，需要对 `T` 添加约束，以告知编译器 `T` 是一个可以被索引的数组。

## 答案

```ts
type TupleToUnion<T extends unknown[]> = T[number]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type TupleToUnion<T extends unknown[]> = T[number]

// ---cut---
type cases = [
  Expect<Equal<TupleToUnion<[123, '456', true]>, 123 | '456' | true>>,
  Expect<Equal<TupleToUnion<[123]>, 123>>,
]
```

## 参考

* [查找类型 Lookup Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)

---

---
url: /czxBlog/type-challenges/medium/type-lookup/index.md
---
# 查找类型
## 题目

Github: [Type lookup](https://github.com/type-challenges/type-challenges/blob/main/questions/00062-medium-type-lookup/)

有时，您可能希望根据某个属性在联合类型中查找类型。

在此挑战中，我们想通过在联合类型 `Cat | Dog` 中搜索公共type字段来获取相应的类型。
换句话说，在以下示例中，我们期望 `LookUp<Dog | Cat, 'dog'>` 获得 `Dog` ，`LookUp<Dog | Cat, 'cat'>` 获得 `Cat`。

```ts
interface Cat {
  type: 'cat'
  breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal'
}

interface Dog {
  type: 'dog'
  breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer'
  color: 'brown' | 'white' | 'black'
}

type MyDog = LookUp<Cat | Dog, 'dog'> // expected to be `Dog`
```

## 解题思路

利用 TypeScript 中 的 **条件类型** 来 检查类型是否可分配给某些特定布局。
检查 `U` 是否可以赋值给 `{ type: T }` 。

值得注意的是，条件类型在 TypeScript 中是分布式的，因此联合类型中的每个成员都将按照条件进行检查。

## 答案

```ts
type LookUp<U, T> = U extends { type: T } ? U : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type LookUp<U, T> = U extends { type: T } ? U : never

// ---cut---
interface Cat {
  type: 'cat'
  breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal'
}

interface Dog {
  type: 'dog'
  breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer'
  color: 'brown' | 'white' | 'black'
}

type Animal = Cat | Dog

type cases = [
  Expect<Equal<LookUp<Animal, 'dog'>, Dog>>,
  Expect<Equal<LookUp<Animal, 'cat'>, Cat>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/unique/index.md
---
# Unique
## 题目

Github: [Unique](https://github.com/type-challenges/type-challenges/blob/main/questions/05360-medium-unique/)

实现类型版本的 Lodash.uniq 方法, Unique 接收数组类型 T, 返回去重后的数组类型.

```ts
type Res = Unique<[1, 1, 2, 2, 3, 3]> // expected to be [1, 2, 3]
type Res1 = Unique<[1, 2, 3, 4, 4, 5, 6, 7]> // expected to be [1, 2, 3, 4, 5, 6, 7]
type Res2 = Unique<[1, 'a', 2, 'b', 2, 'a']> // expected to be [1, "a", 2, "b"]
type Res3 = Unique<[string, number, 1, 'a', 1, string, 2, 'b', 2, number]> // expected to be [string, number, 1, "a", 2, "b"]
type Res4 = Unique<[unknown, unknown, any, any, never, never]> // expected to be [unknown, any, never]
```

## 解题思路

本挑战有两个难点：判断数组中是否包含某个元素；判断两个类型是否严格相等。

**判断两个类型是否严格相等**，请参考 [类型系统的真假美猴王：破解 IsEqual\<X, Y> 之谜](../../../1.前端/12.TypeScript/isEqual.md)

```ts
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2) ? true : false
```

有了 `Equal<X, Y>` 类型工具，就可以实现 `Include<T, U>` 类型工具，判断数组 `T` 中是否包含元素 `U`。

```ts
type Include<T extends unknown[], U> = T extends [infer F, ...infer O]
  ? Equal<F, U> extends true
    ? true
    : Include<O, U>
  : false
```

接下来，就可以实现 `Unique<T>` 类型工具，通过 条件类型 `infer`，从数组 `T` 中，
通过递归的方式从末尾取出一个个元素，判断是否严格等于类型 `U`。

## 答案

```ts
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2) ? true : false

type Include<T extends unknown[], U> = T extends [infer F, ...infer O]
  ? Equal<F, U> extends true
    ? true
    : Include<O, U>
  : false

type Unique<T extends unknown[],> = T extends [...infer O, infer F]
  ? Include<O, F> extends true
    ? Unique<O>
    : [...Unique<O>, F]
  : []
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Include<T extends unknown[], U> = T extends [infer F, ...infer O]
  ? Equal<F, U> extends true
    ? true
    : Include<O, U>
  : false

type Unique<T extends unknown[],> = T extends [...infer O, infer F]
  ? Include<O, F> extends true
    ? Unique<O>
    : [...Unique<O>, F]
  : []

// ---cut---
type cases = [
  Expect<Equal<Unique<[1, 1, 2, 2, 3, 3]>, [1, 2, 3]>>,
  Expect<Equal<Unique<[1, 2, 3, 4, 4, 5, 6, 7]>, [1, 2, 3, 4, 5, 6, 7]>>,
  Expect<Equal<Unique<[1, 'a', 2, 'b', 2, 'a']>, [1, 'a', 2, 'b']>>,
  Expect<Equal<Unique<[string, number, 1, 'a', 1, string, 2, 'b', 2, number]>, [string, number, 1, 'a', 2, 'b']>>,
  Expect<Equal<Unique<[unknown, unknown, any, any, never, never]>, [unknown, any, never]>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/without/index.md
---
# Without
## 题目

Github: [Without](https://github.com/type-challenges/type-challenges/blob/main/questions/05117-medium-without/)

实现一个像 `Lodash.without` 函数一样的泛型 `Without<T, U>`，它接收数组类型的 `T` 和数字或数组类型的 `U` 为参数，
会返回一个去除 `U` 中元素的数组 `T`。

```ts
type Res = Without<[1, 2], 1> // expected to be [2]
type Res1 = Without<[1, 2, 4, 1, 5], [1, 2]> // expected to be [4, 5]
type Res2 = Without<[2, 3, 2, 3, 2, 3, 2, 3], [2, 3]> // expected to be []
```

## 解题思路

此挑战很容易想到使用 `infer` 和递归 来实现，从 数组 `T` 中取出一个个元素，判断是否为 `U` 的元素。

但还需要注意一点，即 `U` 可能传入的是 数组，也可能是 非数组。因此，需要将 `U` 转换为 联合类型。

## 答案

```ts
type ToUnion<U> = U extends readonly any[] ? U[number] : U
type Without<T extends any[], U> = T extends [infer F, ...infer O]
  ? F extends ToUnion<U>
    ? Without<O, U>
    : [F, ...Without<O, U>]
  : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type ToUnion<U> = U extends readonly any[] ? U[number] : U
type Without<T extends any[], U> = T extends [infer F, ...infer O]
  ? F extends ToUnion<U>
    ? Without<O, U>
    : [F, ...Without<O, U>]
  : T

// ---cut---
type cases = [
  Expect<Equal<Without<[1, 2], 1>, [2]>>,
  Expect<Equal<Without<[1, 2, 4, 1, 5], [1, 2]>, [4, 5]>>,
  Expect<Equal<Without<[2, 3, 2, 3, 2, 3, 2, 3], [2, 3]>, []>>,
]
```

## 参考

* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /czxBlog/type-challenges/medium/zip/index.md
---
# Zip
## 题目

Github: [Zip](https://github.com/type-challenges/type-challenges/blob/main/questions/04471-medium-zip/)

在此挑战中，您需要实现一个类型 `Zip<T, U>`，其中 `T` 和 `U` 必须是元组。

```ts
type exp = Zip<[1, 2], [true, false]> // expected to be [[1, true], [2, false]]
```

## 解题思路

这个挑战要求我们创建一个分组元素的数组，数组的第一个元素包含数组 `T` 和 `U` 的第一个元素，
数组的第二个元素包含数组 `T` 和 `U`的第二个元素，以此类推。

首先添加类型参数 `L` 用于保存分组元素的数组，初始值为空数组。

当 `L` 为空数组时，此时 数组长度 `L['length']` 为 `0`，我们恰好可以从数组 `T` 和 `U` 中通过索引下标获取第一个元素，
并将其添加到 `L` 中，此时 `L` 的类型结果为 `[T[0], U[0]]`，然后继续递归调用 `Zip` 。

当 `L` 的长度为 数组 `T` 或 `U` 的最小长度时，则表示递归结束。

## 答案

```ts
type Zip<T extends any[], U extends any[], L extends any[] = []> =
  L['length'] extends T['length'] | U['length']
    ? L
    : Zip<T, U, [...L, [T[L['length']], U[L['length']]]]>
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type Zip<T extends any[], U extends any[], L extends any[] = []> =
  L['length'] extends T['length'] | U['length']
    ? L
    : Zip<T, U, [...L, [T[L['length']], U[L['length']]]]>

// ---cut---
type cases = [
  Expect<Equal<Zip<[], []>, []>>,
  Expect<Equal<Zip<[1, 2], [true, false]>, [[1, true], [2, false]]>>,
  Expect<Equal<Zip<[1, 2, 3], ['1', '2']>, [[1, '1'], [2, '2']]>>,
  Expect<Equal<Zip<[], [1, 2, 3]>, []>>,
  Expect<Equal<Zip<[[1, 2]], [3]>, [[[1, 2], 3]]>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [泛型约束 Generics constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /czxBlog/type-challenges/warm-up/hello-world/index.md
---
# Hello World
## 题目

Github: [Hello World](https://github.com/type-challenges/type-challenges/tree/main/questions/00013-warm-hello-world)

这个简单的提问希望让你可以快速上手 Type Challenges。在这里，我们使用了一些神奇的技巧让 TypeScript 通过自身的类型系统来实现自动判题。

在这个挑战中，你需要修改下方的代码使得测试通过（使其没有类型错误）。

```ts
// 期望是一个 string 类型
type HelloWorld = any
```

你需要使得如下这行不会抛出异常

```ts
type test = Expect<Equal<HelloWorld, string>>
```

## 解题思路

这道题目仅作为热身，用于熟悉 `type-challenges`， 了解如何接受挑战。
在这里，只需要将 `any` 改为 `string` 即可。

## 答案

```ts
type HelloWorld = string
```

## 验证

```ts twoslash
import { Equal, Expect } from '~/tc-utils'
type HelloWorld = string
// ---cut---
type test = Expect<Equal<HelloWorld, string>>
```
